from __future__ import annotations
import logging, sys, os, time, json, re, threading, queue, traceback
from typing import *
from vinyltool.core.logging import setup_logging
logger = setup_logging('exporter')

# NOTE: All functions here take `app` (the VinylToolApp instance) as first arg.

def publish_to_ebay(app):
"""Publish selected items from inventory to eBay, including images."""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items from the inventory to publish.")
    return

app.notebook.select(app.inventory_tab) # Switch to see logs

def publish_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        app.append_log(f"SKU {sku}: Starting publish process for eBay...", "black")

        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            # Latest-wins check: warn if remote eBay data is newer than local
            try:
                local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
                remote_ts = record.get("ebay_updated_at")
                proceed = True
                if remote_ts and local_ts:
                    try:
                        ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                        rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                        if rdt > ldt:
                            msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                                   f"Local updated: {ldt.isoformat()}\n"
                                   f"eBay updated: {rdt.isoformat()}\n\n"
                                   "Proceeding will overwrite eBay with local data. Continue?")
                            proceed = messagebox.askyesno("Potential Conflict", msg)
                    except Exception:
                        pass
                if not proceed:
                    app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                    continue
            except Exception:
                pass

            # Ensure categoryId is set before validation; use default if missing
            try:
                if not record.get("categoryId") and not record.get("category_id"):
                    fmt = record.get("format", "LP") or "LP"
                    record = dict(record)
                    record["categoryId"] = EBAY_VINYL_CATEGORIES.get(fmt, "176985")
            except Exception:
                pass
            errors = validate_listing("ebay", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: Validation failed: {', '.join(errors)}", "red")
                continue

            # --- Listing Creation with Correct Condition ---
            format_val = record.get("format", "LP")
            media_cond_str = record.get("media_condition", "")

            # Map media grade to eBay enums/IDs. Use a conservative fallback:
            # for unknown grades default to USED_GOOD (enum) and a numeric
            # ID of 3000. The numeric ID will not be sent for records.
            condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
            condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
            category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

            listing_data = {
                "sku": sku,
                "title": record.get("listing_title") or record.get("title", "")[:80],
                "description": record.get("description", ""),
                "price": record.get("price", 0),
                "quantity": 1,
                "categoryId": category_id,
                "condition_enum": condition_enum,
                "condition_id_numeric": condition_id_numeric,
                "media_condition": record.get("media_condition"),
                "sleeve_condition": record.get("sleeve_condition"),
                "images": record.get("images", []),
                "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
                "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
                "returnPolicyId": app.config.get("ebay_return_policy_id"),
                "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
                "currency": "GBP"
            }

            result = app.ebay_api.create_draft_listing(listing_data)
            if result.get("success"):
                offer_id = result.get('offerId')
                app.append_log(f"SKU {sku}: Successfully created eBay draft (Offer ID: {offer_id})", "green")
                # Write back ID and timestamp
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?",
                            (offer_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with eBay listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save eBay Offer ID to local DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: eBay listing failed: {result.get('error')}", "red")

        except Exception as e:
            app.append_log(f"SKU {sku}: An unexpected error occurred: {e}", "red")
            logger.error(f"Error publishing SKU {sku} to eBay", exc_info=True)
    
    app.safe_after(0, app.populate_inventory_view)
    app.safe_after(0, lambda: app.root.config(cursor=""))

app.root.config(cursor="watch")
app.root.update()
threading.Thread(target=publish_worker, daemon=True).start()

    def publish_to_discogs(self):
"""Publish selected items to Discogs"""
selected = app.inventory_tree.selection()
if not selected: return
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue
        # Latest-wins check: warn if Discogs data is newer
        try:
            local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
            remote_ts = record.get("discogs_updated_at")
            proceed = True
            if remote_ts and local_ts:
                try:
                    ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                    rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                    if rdt > ldt:
                        msg = (f"SKU {sku}: The Discogs data was updated more recently than your local copy.\n"
                               f"Local updated: {ldt.isoformat()}\n"
                               f"Discogs updated: {rdt.isoformat()}\n\n"
                               "Proceeding will overwrite Discogs with local data. Continue?")
                        proceed = messagebox.askyesno("Potential Conflict", msg)
                except Exception:
                    pass
            if not proceed:
                app.append_log(f"SKU {sku}: Skipped due to newer Discogs data.", "orange")
                continue
        except Exception:
            pass

        errors = validate_listing("discogs", record, app.config)
        if errors:
            app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
            continue
        app.append_log(f"Publishing SKU {sku} to Discogs...", "black")
        listing_data = {
            "release_id": record.get("discogs_release_id"),
            "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
            "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
            "price": record.get("price", 0), "status": "Draft", "comments": record.get("description", "")
        }
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.append_log(f"SKU {sku}: Listed as Draft (ID: {listing_id})", "green")
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                        (listing_id, now_iso, sku),
                    )
            except Exception as e:
                logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
        else:
            app.append_log(f"SKU {sku}: Failed to create listing", "red")
    except Exception as e:
        app.append_log(f"SKU {sku}: Error - {e}", "red")

    def save_to_ebay_drafts_inventory(self):
"""
Create a Sell Listings draft for each selected inventory item. This is a safe operation
that does not publish the listing live. The returned draft ID and update timestamp
are saved back to the database.
"""
if globals().get("PUBLISH_HARD_BLOCK"):
    app.append_log("[draft] BLOCKED BY FLAG", "orange")
    return
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items from the inventory to save drafts.")
    return

# Switch to inventory tab to display logs
app.notebook.select(app.inventory_tab)

def draft_worker():
    # Force the eBay API wrapper to refresh the access token on each
    # draft creation. This ensures that any newly added scopes (e.g.
    # sell.listing) are included in the token. Without this, the
    # cached access token may not contain the required scope and
    # draft creation can fail silently.
    try:
        app.ebay_api.access_token = None
    except Exception:
        pass
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue

            # Check latest-wins management: warn if remote data is newer than local
            try:
                local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
                remote_ts = record.get("ebay_updated_at")
                proceed = True
                if remote_ts and local_ts:
                    try:
                        ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                        rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                        if rdt > ldt:
                            msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                                   f"Local updated: {ldt.isoformat()}\n"
                                   f"eBay updated: {rdt.isoformat()}\n\n"
                                   "Proceeding will overwrite eBay with local data. Continue?")
                            proceed = messagebox.askyesno("Potential Conflict", msg)
                    except Exception:
                        pass
                if not proceed:
                    app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                    continue
            except Exception:
                pass

            # Build listing_data similar to publish_to_ebay
            format_val = record.get("format", "LP")
            media_cond_str = record.get("media_condition", "")
            # Map media grade to eBay enums/IDs. Use "USED_GOOD" and 3000 as
            # safe fallbacks for unknown grades. The numeric ID will not be
            # transmitted for the Records category.
            condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
            condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
            category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")
            listing_data = {
                "sku": sku,
                "title": record.get("listing_title") or record.get("title", "")[:80],
                "description": record.get("description", ""),
                "price": record.get("price", 0),
                "quantity": 1,
                "categoryId": category_id,
                "condition_enum": condition_enum,
                "condition_id_numeric": condition_id_numeric,
                "media_condition": record.get("media_condition"),
                "sleeve_condition": record.get("sleeve_condition"),
                "images": record.get("images", []),
                "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
                "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
                "returnPolicyId": app.config.get("ebay_return_policy_id"),
                "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
                "currency": "GBP"
            }
            # Attempt to collect image URLs if necessary
            try:
                # Convert local images to eBay-hosted URLs if none exist
                if not listing_data.get("images") and record.get("image_urls"):
                    listing_data["imageUrls"] = record.get("image_urls")
                else:
                    # Fallback: rely on eBay API wrapper to upload images
                    listing_data["images"] = record.get("images", [])
            except Exception:
                pass

            res = app.ebay_api.create_sell_listing_draft(listing_data)
            if res.get("success"):
                draft_id = res.get("draftId")
                # Write back ID and timestamp
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET ebay_item_draft_id = ?, ebay_updated_at = ? WHERE sku = ?",
                            (draft_id, now_iso, sku),
                        )
                    app.append_log(f"SKU {sku}: eBay draft created (Draft ID: {draft_id}).", "green")
                except Exception as e:
                    app.append_log(f"SKU {sku}: Draft created but failed to save ID to DB: {e}", "red")
            else:
                err = res.get("error") or res.get("body")
                status = res.get("status")
                if status:
                    app.append_log(f"SKU {sku}: Failed to create eBay draft (status {status}): {err}", "red")
                else:
                    app.append_log(f"SKU {sku}: Failed to create eBay draft: {err}", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Unexpected error during draft creation: {e}", "red")

    # Refresh inventory view on the main thread
    app.safe_after(0, lambda: app.populate_inventory_view(app.inventory_search_var.get()))
    app.safe_after(0, lambda: app.root.config(cursor=""))

# Show busy cursor and start background thread
app.root.config(cursor="watch")
app.root.update()
threading.Thread(target=draft_worker, daemon=True).start()

    def open_listing_in_browser(self):
"""
Open the appropriate listing page in the user's default web browser for the selected
inventory item. Priority is given to eBay drafts, then live eBay listings,
then Discogs listings.
"""
selected = app.inventory_tree.focus()
if not selected:
    return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    # Try to open eBay draft if present
    draft_id = record.get("ebay_item_draft_id")
    if draft_id:
        # eBay does not provide direct draft URLs; open drafts overview
        webbrowser.open_new_tab("https://www.ebay.co.uk/sh/lst/drafts")
        return
    live_id = record.get("ebay_listing_id")
    if live_id:
        webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{live_id}")
        return
    discogs_id = record.get("discogs_listing_id")
    if discogs_id:
        webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{discogs_id}")
        return
    messagebox.showinfo("No Listing", "This item does not have any listing IDs yet.")
except Exception as e:
    logger.error(f"Failed to open listing: {e}")
    messagebox.showerror("Error", f"Failed to open listing: {e}")
    
    def append_log(self, message, color="black"):
"""Append message to publish log"""
def do_append():
    timestamp = datetime.datetime.now().strftime("[%H:%M:%S]")
    app.publish_log.config(state="normal")
    app.publish_log.insert("end", f"{timestamp} {message}\n", (color,))
    app.publish_log.tag_configure("red", foreground="red")
    app.publish_log.tag_configure("green", foreground="green")
    app.publish_log.tag_configure("black", foreground="black")
    app.publish_log.see("end")
    app.publish_log.config(state="disabled")
app.safe_after(0, do_append)

    def show_inventory_context_menu(self, event):
"""Show inventory context menu"""
row_id = app.inventory_tree.identify_row(event.y)
if row_id:
    app.inventory_tree.selection_set(row_id)
    app.inventory_tree.focus(row_id)
    app.inventory_context_menu.post(event.x_root, event.y_root)
    
    def show_discogs_context_menu(self, event):
"""Show Discogs results context menu"""
row_id = app.discogs_tree.identify_row(event.y)
if row_id:
    app.discogs_tree.selection_set(row_id)
    app.discogs_tree.focus(row_id)
    app.discogs_context_menu.post(event.x_root, event.y_root)
    
    def open_discogs_listing(self):
"""Open Discogs listing for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("discogs_listing_id"):
        webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{record['discogs_listing_id']}")
    else:
        messagebox.showinfo("No Discogs Listing", "This item has no Discogs listing ID.")
except Exception as e:
    logger.error(f"Failed to open Discogs listing: {e}")
    
    def open_ebay_listing(self):
"""Open eBay listing for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("ebay_listing_id"):
        webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{record['ebay_listing_id']}")
    else:
        messagebox.showinfo("No eBay Listing", "This item has no eBay listing ID.")
except Exception as e:
    logger.error(f"Failed to open eBay listing: {e}")
    
    def open_discogs_release_from_inventory(self):
"""Open Discogs release page for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("discogs_release_id"):
        webbrowser.open_new_tab(f"https://www.discogs.com/release/{record['discogs_release_id']}")
    else:
        messagebox.showinfo("No Release Linked", "This item has no Discogs release ID.")
except Exception as e:
    logger.error(f"Failed to open release page: {e}")
    
    def open_discogs_release_page(self):
"""Open selected release on Discogs website"""
selected = app.discogs_tree.focus()
if not selected: return
release_id = app.discogs_tree.item(selected, "values")[0]
webbrowser.open_new_tab(f"https://www.discogs.com/release/{release_id}")
    
    def open_sold_listings_from_selection(self, platform):
"""Open sold listings search for selected Discogs result"""
selected = app.discogs_tree.focus()
if not selected: return
_, artist, title, catno, _, _, _ = app.discogs_tree.item(selected, "values")
query = f"{artist} {title} {catno}".strip()
url = f"https://www.ebay.co.uk/sch/i.html?_nkw={quote_plus(query)}&_sacat=176985&LH_Sold=1&LH_Complete=1" if platform == "eBay" else f"https://www.discogs.com/search/?q={quote_plus(query)}&type=all"
webbrowser.open_new_tab(url)
    
    def get_price_suggestion(self):
"""Get price suggestions for selected release"""
selected = app.discogs_tree.focus()
if not selected: return
release_id = int(app.discogs_tree.item(selected, "values")[0])
app.root.config(cursor="watch")
app.root.update()
def fetch_worker():
    try:
        suggestions = app.discogs_api.get_price_suggestions(release_id)
        if suggestions:
            msg = "Price Suggestions:\n\n" + "\n".join([f"{condition}: £{price_data['value']:.2f}" for condition, price_data in suggestions.items()])
            app.safe_after(0, lambda: messagebox.showinfo("Price Suggestions", msg))
        else:
            app.safe_after(0, lambda: messagebox.showinfo("No Data", "No price suggestions available"))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=fetch_worker, daemon=True).start()
    
    def refresh_discogs_view(self, event=None):
"""Refresh Discogs results with filter"""
filter_text = app.discogs_search_filter_var.get().lower()
if not app.discogs_search_results: return
for item in app.discogs_tree.get_children(): app.discogs_tree.delete(item)
for result in app.discogs_search_results:
    artist, title = (result.get("title", "").split(" - ", 1) + [""])[:2]
    if filter_text and filter_text not in f"{artist} {title} {result.get('catno', '')} {result.get('year', '')}".lower(): continue
    values = (result.get("id"), artist, title, result.get("catno", "N/A"), result.get("year", "N/A"), result.get("country", "N/A"), ", ".join(result.get("format", [])))
    app.discogs_tree.insert("", "end", values=values)
    
    def sort_discogs_results(self, col):
"""Sort Discogs results by column"""
if app.discogs_sort_column == col:
    app.discogs_sort_direction = "ASC" if app.discogs_sort_direction == "DESC" else "DESC"
else:
    app.discogs_sort_column, app.discogs_sort_direction = col, "ASC"
if app.discogs_search_results:
    def sort_key(item):
        if col == "Artist": return (item.get("title", "").split(" - ", 1) + [""])[0].lower()
        elif col == "Title": return (item.get("title", "").split(" - ", 1) + [""])[1].lower()
        elif col == "Year":
            try: return int(item.get("year", 0))
            except: return 0
        else: return str(item.get(col.lower(), "")).lower()
    app.discogs_search_results.sort(key=sort_key, reverse=(app.discogs_sort_direction == "DESC"))
    app.refresh_discogs_view()
    
    def authenticate_discogs(self):
"""Authenticate with Discogs"""
consumer_key = app.config.get("discogs_consumer_key")
consumer_secret = app.config.get("discogs_consumer_secret")
if not consumer_key or not consumer_secret:
    messagebox.showerror("Configuration Error", "Discogs Consumer Key/Secret not found in config.json.\nPlease add these to your configuration file.")
    return
try:
    client = discogs_client.Client("VinylListingTool/5.1", consumer_key=consumer_key, consumer_secret=consumer_secret)
    token, secret, url = client.get_authorize_url()
    webbrowser.open(url)
    pin = simpledialog.askstring("Discogs Authentication", "Please enter the verification code from Discogs:")
    if not pin: return
    access_token, access_secret = client.get_access_token(pin)
    app.config.save({"discogs_oauth_token": access_token, "discogs_oauth_token_secret": access_secret})
    app.discogs_api = DiscogsAPI(app.config)
    if app.discogs_api.is_connected():
        app._update_connection_status()
        messagebox.showinfo("Success", "Successfully connected to Discogs!")
    else:
        messagebox.showerror("Error", "Failed to connect to Discogs")
except Exception as e:
    logger.error(f"Discogs authentication failed: {e}")
    messagebox.showerror("Authentication Error", str(e))
    
    def test_ebay_connection(self):
"""Test eBay connection"""
if app.ebay_api.test_connection():
    app.ebay_auth_status_var.set("Connected")
    messagebox.showinfo("Success", "Successfully connected to eBay!")
else:
    app.ebay_auth_status_var.set("Not Connected")
    messagebox.showerror("Connection Failed", "Could not connect to eBay.\nPlease check your credentials in config.json")
    
    def check_discogs_sales(self):
"""Check for Discogs sales"""
if not app.discogs_api.is_connected(): return
app.root.config(cursor="watch"); app.root.update()
def sales_worker():
    try:
        orders = app.discogs_api.get_orders(['Payment Received', 'Shipped'])
        app.safe_after(0, lambda: app._display_discogs_sales(orders))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_discogs_sales(self, orders):
"""Display Discogs sales"""
for item in app.sales_tree.get_children(): app.sales_tree.delete(item)
if not orders:
    messagebox.showinfo("No Sales", "No sales with status 'Payment Received' or 'Shipped' found.")
    return
for order in orders:
    for item in order.items:
        artist = item.release.artists[0].name if item.release.artists else "Various"
        title = item.release.title.replace(f"{artist} - ", "", 1).strip()
        sale_date = datetime.datetime.strptime(order.data['created'][:10], "%Y-%m-%d").strftime("%d-%m-%Y")
        sale_price = f"{item.price.value} {item.price.currency}"
        values = (order.id, sale_date, order.buyer.username, artist, title, sale_price, item.release.id)
        app.sales_tree.insert("", "end", values=values)
    
    def sync_discogs_sale(self):
"""Sync selected Discogs sale to inventory"""
selected = app.sales_tree.focus()
if not selected: return
release_id = app.sales_tree.item(selected, "values")[6]
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku FROM inventory WHERE discogs_release_id = ? AND status = 'For Sale'", (release_id,))
        record = cursor.fetchone()
        if record:
            sku = record[0]
            if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
                app.update_inventory_status("Sold")
                messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
        else:
            messagebox.showwarning("No Match", f"Could not find an unsold item with Release ID: {release_id}.")
except Exception as e:
    logger.error(f"Failed to sync sale: {e}")
    messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def check_ebay_sales(self):
"""Check for eBay sales"""
if not app.ebay_api.test_connection(): return
try:
    start_date = datetime.datetime.strptime(app.ebay_start_date_var.get(), "%d-%m-%Y")
    end_date = datetime.datetime.strptime(app.ebay_end_date_var.get(), "%d-%m-%Y")
    if (end_date - start_date).days > 30:
        messagebox.showerror("Date Range Error", "The date range cannot exceed 30 days.")
        return
except ValueError:
    messagebox.showerror("Date Format Error", "Please enter dates in DD-MM-YYYY format.")
    return
app.root.config(cursor="watch"); app.root.update()
def sales_worker():
    try:
        orders = app.ebay_api.get_orders(start_date, end_date)
        app.safe_after(0, lambda: app._display_ebay_sales(orders))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_ebay_sales(self, orders):
"""Display eBay sales"""
for item in app.ebay_sales_tree.get_children(): app.ebay_sales_tree.delete(item)
if not orders:
    messagebox.showinfo("No eBay Sales", "No completed sales found in the specified date range.")
    return
for order in orders:
    order_id, created_date, buyer = order.get("orderId"), order.get("creationDate", "")[:10], order.get("buyer", {}).get("username", "")
    for line_item in order.get("lineItems", []):
        title, price, currency, item_id = line_item.get("title", ""), line_item.get("lineItemCost", {}).get("value", ""), line_item.get("lineItemCost", {}).get("currency", "GBP"), line_item.get("legacyItemId", "")
        artist, album_title = "", title
        if ":" in title:
            parts = title.split(":", 1)
            artist, album_title = parts[0].strip(), parts[1].strip()
        values = (order_id, created_date, buyer, artist, album_title, f"{price} {currency}", item_id)
        app.ebay_sales_tree.insert("", "end", values=values)
    
    def sync_ebay_sale(self):
"""Sync selected eBay sale to inventory"""
selected = app.ebay_sales_tree.focus()
if not selected: return
_, _, _, artist, title, _, item_id = app.ebay_sales_tree.item(selected, "values")
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku FROM inventory WHERE (ebay_listing_id = ? OR (artist LIKE ? AND title LIKE ?)) AND status = 'For Sale'", (item_id, f"%{artist}%", f"%{title}%"))
        record = cursor.fetchone()
        if record:
            sku = record[0]
            if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
                app.update_inventory_status("Sold")
                messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
        else:
            messagebox.showwarning("No Match", f"Could not find an unsold item matching:\n{artist} - {title}")
except Exception as e:
    logger.error(f"Failed to sync sale: {e}")
    messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def start_discogs_import(self):
"""Import inventory from Discogs"""
if not app.discogs_api.is_connected(): return
if not messagebox.askyesno("Confirm Import", "This will import all 'For Sale' items from Discogs.\nExisting items will be skipped.\n\nContinue?"): return
app.root.config(cursor="watch"); app.root.update()
def import_worker():
    try:
        inventory = app.discogs_api.get_inventory()
        app.safe_after(0, lambda: app._process_discogs_import(inventory))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Import Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=import_worker, daemon=True).start()
    
    def _process_discogs_import(self, inventory):
"""Process Discogs import"""
new_items, skipped_items = 0, 0
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        for listing in inventory:
            if listing.status != 'For Sale': continue
            cursor.execute("SELECT COUNT(*) FROM inventory WHERE discogs_listing_id = ?", (listing.id,))
            if cursor.fetchone()[0] > 0:
                skipped_items += 1
                continue
            new_items += 1
            artist = listing.release.artists[0].name if listing.release.artists else "Various"
            title = listing.release.title.replace(f"{artist} - ", "", 1).strip()
            sku = datetime.datetime.now().strftime(f"%Y%m%d-%H%M%S-{new_items}")
            now = datetime.datetime.now(datetime.timezone.utc).isoformat()
            sql = """INSERT INTO inventory (sku, artist, title, cat_no, media_condition, sleeve_condition, price, status, discogs_release_id, discogs_listing_id, date_added, last_modified) 
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"""
            media_cond = DISCOGS_GRADE_MAP.get(listing.condition, listing.condition)
            sleeve_cond = DISCOGS_GRADE_MAP.get(listing.sleeve_condition, listing.sleeve_condition)
            catno = getattr(listing.release, 'catno', '')
            cursor.execute(sql, (sku, artist, title, catno, media_cond, sleeve_cond, listing.price.value, "For Sale", listing.release.id, listing.id, now, now))
    messagebox.showinfo("Import Complete", f"Successfully imported {new_items} new item(s).\nSkipped {skipped_items} existing item(s).")
    app.populate_inventory_view()
except Exception as e:
    logger.error(f"Import failed: {e}")
    messagebox.showerror("Import Error", f"An error occurred during import:\n{e}")
    
    def toggle_auto_sync(self):
"""Toggle automatic sync"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
    app.auto_sync_var.set(False)
    return
app.auto_sync_enabled = app.auto_sync_var.get()
app.config.save({"auto_sync_enabled": app.auto_sync_enabled})
if app.auto_sync_enabled: app.start_auto_sync()
else: app.stop_auto_sync()
    
    def toggle_two_way_sync(self):
"""Toggle two-way sync"""
app.two_way_sync_enabled = app.two_way_sync_var.get()
app.config.save({"two_way_sync_enabled": app.two_way_sync_enabled})
app.log_sync_activity(f"Two-way sync {'enabled' if app.two_way_sync_enabled else 'disabled'}")
    
    def toggle_attempt_updates(self):
"""Toggle attempt to update Discogs"""
app.attempt_discogs_updates = app.attempt_updates_var.get()
app.config.save({"attempt_discogs_updates": app.attempt_discogs_updates})
app.log_sync_activity(f"Discogs update attempts {'enabled' if app.attempt_discogs_updates else 'disabled'}")
    
    def update_sync_interval(self):
"""Update sync interval"""
try:
    minutes = int(app.sync_interval_var.get())
    app.auto_sync_interval = minutes * 60
    app.config.save({"auto_sync_interval": app.auto_sync_interval})
    app.log_sync_activity(f"Sync interval set to {minutes} minutes")
except ValueError: app.sync_interval_var.set("5")
    
    def start_auto_sync(self):
"""Start automatic sync"""
if app.auto_sync_thread and app.auto_sync_thread.is_alive(): return
app.auto_sync_stop_event.clear()
app.auto_sync_thread = threading.Thread(target=app._auto_sync_worker, daemon=True)
app.auto_sync_thread.start()
app.sync_status_var.set("Auto-sync enabled - waiting for next sync...")
app.log_sync_activity("Automatic sync started")
    
    def stop_auto_sync(self):
"""Stop automatic sync"""
app.auto_sync_stop_event.set()
app.sync_status_var.set("Auto-sync disabled")
app.log_sync_activity("Automatic sync stopped")
    
    def _auto_sync_worker(self):
"""Auto sync worker thread"""
while not app.auto_sync_stop_event.is_set():
    try:
        if app.auto_sync_stop_event.wait(app.auto_sync_interval): break
        if app.auto_sync_enabled and app.discogs_api.is_connected():
            app.safe_after(0, lambda: app.sync_status_var.set("Syncing inventory..."))
            sync_result = app._perform_inventory_sync()
            app.safe_after(0, lambda r=sync_result: app._handle_sync_result(r))
    except Exception as e:
        app.safe_after(0, lambda msg=f"Auto-sync error: {e}": app.log_sync_activity(msg))
    
    def manual_sync_now(self):
"""Perform manual sync now"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
    return
app.sync_status_var.set("Manual sync in progress...")
app.root.config(cursor="watch"); app.root.update()
def sync_worker():
    try:
        result = app._perform_inventory_sync()
        app.safe_after(0, lambda: app._handle_sync_result(result))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Sync Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sync_worker, daemon=True).start()
    
    def _perform_inventory_sync(self):
"""Implements true "latest-wins" two-way sync logic."""
sync_start_time = datetime.datetime.now(datetime.timezone.utc)
app.log_sync_activity("=== STARTING SYNC (Latest-Wins) ===")
try:
    discogs_inventory = app.discogs_api.get_inventory()
    discogs_map = {listing.id: listing for listing in discogs_inventory}
    app.log_sync_activity(f"Retrieved {len(discogs_inventory)} active listings from Discogs.")

    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku, discogs_listing_id, price, status, notes, last_modified, last_sync_time FROM inventory WHERE discogs_listing_id IS NOT NULL")
        local_items = [dict(row) for row in cursor.fetchall()]
        local_map = {item['discogs_listing_id']: item for item in local_items}
    app.log_sync_activity(f"Found {len(local_map)} linked local items.")

    updates_to_local, updates_to_discogs, deletions_from_local, new_sales = 0, 0, 0, 0
    
    for local_item in local_items:
        listing_id, last_mod_local_str, last_sync_str = local_item['discogs_listing_id'], local_item.get('last_modified'), app.last_successful_sync_time or local_item.get('last_sync_time')
        if not last_mod_local_str or not last_sync_str: continue
        try:
            last_mod_local, last_sync = datetime.datetime.fromisoformat(last_mod_local_str), datetime.datetime.fromisoformat(last_sync_str)
        except (ValueError, TypeError): continue

        if last_mod_local > last_sync and app.attempt_discogs_updates:
            if listing_id in discogs_map:
                app.log_sync_activity(f"→ Local change detected for SKU {local_item['sku']}. Pushing to Discogs.")
                update_payload = {"price": local_item['price'], "status": app._map_local_to_discogs_status(local_item['status']), "comments": local_item.get('notes', '')}
                if app.discogs_api.update_listing(listing_id, update_payload):
                    updates_to_discogs += 1; app.log_sync_activity(f"  ✓ Pushed update for SKU {local_item['sku']} to Discogs.")
                else: app.log_sync_activity(f"  ✗ Failed to push update for SKU {local_item['sku']}.")
            else: app.log_sync_activity(f"  - SKU {local_item['sku']} changed locally but no longer on Discogs. Skipping push.")

        elif listing_id in discogs_map:
            listing = discogs_map[listing_id]
            mapped_status = app.status_mappings.get(listing.status, "Not For Sale")
            if mapped_status != local_item['status']:
                with app.db.get_connection() as conn:
                    conn.cursor().execute("UPDATE inventory SET status = ?, last_modified = ? WHERE discogs_listing_id = ?", (mapped_status, sync_start_time.isoformat(), listing_id))
                updates_to_local += 1
                if mapped_status == 'Sold' and local_item['status'] != 'Sold': new_sales += 1
                app.log_sync_activity(f"✓ Sync from Discogs: SKU {local_item['sku']} '{local_item['status']}' → '{mapped_status}'")

    ids_to_delete_locally = set(local_map.keys()) - set(discogs_map.keys())
    if ids_to_delete_locally:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            for listing_id in ids_to_delete_locally:
                if local_map[listing_id]['status'] == 'For Sale':
                    sku = local_map[listing_id]['sku']
                    cursor.execute("DELETE FROM inventory WHERE discogs_listing_id = ?", (listing_id,))
                    deletions_from_local += 1
                    app.log_sync_activity(f"✓ Deleted SKU {sku} locally as it's no longer on Discogs.")
    
    with app.db.get_connection() as conn:
        conn.cursor().execute("UPDATE inventory SET last_sync_time = ? WHERE discogs_listing_id IS NOT NULL", (sync_start_time.isoformat(),))
    app.last_successful_sync_time = sync_start_time.isoformat()
    app.config.save({"last_successful_sync_time": app.last_successful_sync_time})
    if updates_to_local > 0 or deletions_from_local > 0: app.safe_after(0, app.populate_inventory_view)
    app.log_sync_activity("=== SYNC COMPLETED ===")
    return {'success': True, 'updates_local': updates_to_local, 'updates_discogs': updates_to_discogs, 'deletions': deletions_from_local, 'new_sales': new_sales, 'total_checked': len(discogs_inventory)}
except Exception as e:
    logger.error(f"Sync failed: {e}", exc_info=True)
    app.log_sync_activity(f"✗ SYNC ERROR: {e}")
    return {'success': False, 'error': str(e)}

    def _map_local_to_discogs_status(self, local_status):
"""Map local status to valid Discogs status"""
return {'For Sale': 'For Sale', 'Sold': 'Sold'}.get(local_status, 'Draft')
    
    def _handle_sync_result(self, result):
"""Handle sync result"""
current_time = datetime.datetime.now().strftime("%H:%M:%S")
if result.get('success'):
    updates_local, updates_discogs, deletions = result.get('updates_local', 0), result.get('updates_discogs', 0), result.get('deletions', 0)
    total_changes = updates_local + updates_discogs + deletions
    if total_changes > 0:
        log_msg = f"[{current_time}] Sync completed: {total_changes} changes from {result['total_checked']} listings"
        if updates_local > 0: log_msg += f"\n  - Pulled from Discogs: {updates_local}"
        if updates_discogs > 0: log_msg += f"\n  - Pushed to Discogs: {updates_discogs}"
        if deletions > 0: log_msg += f"\n  - Items deleted locally: {deletions}"
        if result.get('new_sales', 0) > 0: log_msg += f"\n  - New sales detected: {result['new_sales']}"
        app.log_sync_activity(log_msg)
        status_msg = f"Sync complete - {total_changes} change(s)"
    else:
        status_msg = "Sync complete - no changes needed"
        app.log_sync_activity(f"[{current_time}] Sync completed. No changes needed.")
    app.sync_status_var.set(f"Last sync: {current_time}. {status_msg}")
else:
    app.sync_status_var.set(f"Last sync: {current_time}. FAILED.")
    app.log_sync_activity(f"[{current_time}] Sync FAILED: {result.get('error')}")

    # ========================================================================
    # ENHANCED PUBLISHING ACTION METHODS
    # ========================================================================
    
    def action_ebay_save_unpublished(self):
"""Save eBay listing data locally as 'ready to publish' without sending to eBay"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - save current form
    app._save_ebay_draft_from_lister()
else:
    # From Inventory tab - mark selected items as ready for eBay
    app._save_ebay_draft_from_inventory()

    def action_ebay_publish_live(self):
"""Publish directly to eBay as live listings (Inventory API)"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - publish current form directly
    app.list_on_ebay()
else:
    # From Inventory tab - publish selected items
    app.publish_to_ebay()



    def reconcile_from_ebay(self, skus):


"""Pull eBay state back into local DB so deletions/ends/relists are reflected.


Chooses ACTIVE offer. Prefers Item ID (listingId); falls back to offerId if listingId hasn't propagated yet.


Refreshes the grid when done.


"""


import datetime, logging, requests


logger = logging.getLogger(__name__)


    


token = app.ebay_api.get_access_token()


if not token:


    app.append_log("Cannot reconcile: missing eBay token", "red")


    return


    


headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}


changed = False


    


for sku in (skus or []):


    try:


        url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={sku}"


        r = requests.get(url, headers=headers, timeout=30)


        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()


    


        if r.status_code == 200 and r.json().get("offers"):


            offers = r.json()["offers"]


            # Pick ACTIVE offer if available; otherwise first one


            active = None


            for o in offers:


                if (o.get("status") or "").upper() == "ACTIVE":


                    active = o


                    break


            offer = active or offers[0]


            status = (offer.get("status") or "").upper()


    


            listing_id = offer.get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('legacyItemId') or (offer.get('listing') or {}).get('listingId')


            offer_id = offer.get("offerId") or (offer.get("offer") or {}).get("offerId")


    


            # If ACTIVE but listingId missing, try GET /offer/{offerId} to resolve


            if status in ("ACTIVE","PUBLISHED") and not listing_id and offer_id:


                try:


                    resolved = app.ebay_api.get_offer(str(offer_id))


                    if resolved.get("success"):


                        listing_id = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')


                except Exception as e:


                    logger.warning(f"[reconcile] get_offer failed for offer {offer_id}: {e}")


    


            with app.db.get_connection() as conn:


                c = conn.cursor()


                if status in ("ACTIVE","PUBLISHED"):


                    stored_id = listing_id or (offer_id if offer_id else None)


                    if stored_id:


                        c.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))


                        changed = True


                    else:


                        c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                        changed = True


                else:


                    c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                    changed = True


    


            shown = listing_id or (offer_id if (status in ("ACTIVE","PUBLISHED") and offer_id) else "—")


            label = "Item ID" if listing_id else ("Offer ID" if shown != "—" else "—")  # live


            app.append_log(f"SKU {sku}: reconciled from eBay ({status}; {label}={shown})", "blue")


        else:


            with app.db.get_connection() as conn:


                c = conn.cursor()


                c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


            changed = True


            app.append_log(f"SKU {sku}: no eBay offer found; cleared local mapping.", "orange")


    


    except Exception as e:


        logger.error(f"Reconcile error for {sku}: {e}")


        app.append_log(f"SKU {sku}: reconcile failed: {e}", "red")


    


if changed:


    try:


        app.populate_inventory_view()


    except Exception:


        pass



    def action_open_on_ebay_selected(self):



"""Open the selected item's eBay listing in the browser using stored Item ID."""



import webbrowser, requests, logging



logger = logging.getLogger(__name__)



items = app.inventory_tree.selection()



if not items:



    try:



        messagebox.showinfo("Open on eBay", "Please select a row first.")



    except Exception:



        pass



    return



iid = items[0]



vals = app.inventory_tree.item(iid, "values") or []



item_id = None



# Try visible column first



try:



    headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



    if "eBay ID" in headers:



        idx = headers.index("eBay ID")



        if idx < len(vals):



            item_id = vals[idx]



except Exception:



    item_id = None



# Fallback: DB lookup by SKU (assumes SKU in first column)



if not item_id and vals:



    sku = vals[0]



    try:



        with app.db.get_connection() as conn:



            c = conn.cursor()



            c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



            row = c.fetchone()



            if row and row[0]:



                item_id = row[0]



    except Exception:



        pass



if not item_id:



    try:



        messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



    except Exception:



        pass



    return



# If it's likely an offerId, try resolve to listingId on the fly



if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



    try:



        token = app.ebay_api.get_access_token()



        if token:



            headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



            url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



            r = requests.get(url, headers=headers, timeout=30)



            if r.status_code == 200 and r.json().get("offers"):



                offers = r.json()["offers"]



                active = None



                for o in offers:



                    if (o.get("status") or "").upper() == "ACTIVE":



                        active = o



                        break



                off = active or offers[0]



                lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



                if not lid:



                    oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                    if oid:



                        resolved = app.ebay_api.get_offer(str(oid))



                        if resolved.get("success"):



                            lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



                if lid:



                    item_id = lid



    except Exception as e:



        logger.warning(f"[open] resolution failed: {e}")



try:



    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



except Exception:



    try:



        messagebox.showerror("Open on eBay", "Failed to open browser.")



    except Exception:



        pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




try:




    offers = app._fetch_all_ebay_offers()




except Exception as e:




    messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




    return




work = []




with app.db.get_connection() as conn:




    c = conn.cursor()




    for off in offers:




        sku = (off.get("sku") or "").strip()




        if not sku:




            continue




        c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




        row = c.fetchone()




        if not row or not row[0]:




            work.append(off)




if not work:




    messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




    return




app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def create_or_update_offer(app, listing_data: dict):
"""
Step 2: Common offer creation/update logic extracted.
Returns: dict with at least { 'success': bool, 'offerId': optional, 'error': optional }.
For now, delegates to the existing publish_to_ebay logic so behavior is unchanged.
"""
if globals().get("PUBLISH_HARD_BLOCK"):
    app.append_log("[publish] BLOCKED BY FLAG", "orange")
    return {"success": False, "error": "Blocked"}
# Draft creation/update is no longer supported in this version.  To
# publish a listing on eBay, first save the item to your Inventory and
# then use the "Publish Live to eBay" button on the Inventory tab.  We
# return an informative error here to avoid unexpected calls.
return {
    "success": False,
    "error": "Draft listing functionality has been removed. Please add the item to your Inventory and publish from there."
}
    
    def publish_to_ebay(self):
"""Publish selected items from inventory to eBay, including images."""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items from the inventory to publish.")
    return

app.notebook.select(app.inventory_tab) # Switch to see logs

def publish_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        app.append_log(f"SKU {sku}: Starting publish process for eBay...", "black")

        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            # Latest-wins check: warn if remote eBay data is newer than local
            try:
                local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
                remote_ts = record.get("ebay_updated_at")
                proceed = True
                if remote_ts and local_ts:
                    try:
                        ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                        rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                        if rdt > ldt:
                            msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                                   f"Local updated: {ldt.isoformat()}\n"
                                   f"eBay updated: {rdt.isoformat()}\n\n"
                                   "Proceeding will overwrite eBay with local data. Continue?")
                            proceed = messagebox.askyesno("Potential Conflict", msg)
                    except Exception:
                        pass
                if not proceed:
                    app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                    continue
            except Exception:
                pass

            # Ensure categoryId is set before validation; use default if missing
            try:
                if not record.get("categoryId") and not record.get("category_id"):
                    fmt = record.get("format", "LP") or "LP"
                    record = dict(record)
                    record["categoryId"] = EBAY_VINYL_CATEGORIES.get(fmt, "176985")
            except Exception:
                pass
            errors = validate_listing("ebay", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: Validation failed: {', '.join(errors)}", "red")
                continue

            # --- Listing Creation with Correct Condition ---
            format_val = record.get("format", "LP")
            media_cond_str = record.get("media_condition", "")

            # Map media grade to eBay enums/IDs. Use a conservative fallback:
            # for unknown grades default to USED_GOOD (enum) and a numeric
            # ID of 3000. The numeric ID will not be sent for records.
            condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
            condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
            category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

            listing_data = {
                "sku": sku,
                "title": record.get("listing_title") or record.get("title", "")[:80],
                "description": record.get("description", ""),
                "price": record.get("price", 0),
                "quantity": 1,
                "categoryId": category_id,
                "condition_enum": condition_enum,
                "condition_id_numeric": condition_id_numeric,
                "media_condition": record.get("media_condition"),
                "sleeve_condition": record.get("sleeve_condition"),
                "images": record.get("images", []),
                "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
                "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
                "returnPolicyId": app.config.get("ebay_return_policy_id"),
                "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
                "currency": "GBP"
            }

            result = app.ebay_api.create_draft_listing(listing_data)
            if result.get("success"):
                offer_id = result.get('offerId')
                app.append_log(f"SKU {sku}: Successfully created eBay draft (Offer ID: {offer_id})", "green")
                # Write back ID and timestamp
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?",
                            (offer_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with eBay listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save eBay Offer ID to local DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: eBay listing failed: {result.get('error')}", "red")

        except Exception as e:
            app.append_log(f"SKU {sku}: An unexpected error occurred: {e}", "red")
            logger.error(f"Error publishing SKU {sku} to eBay", exc_info=True)
    
    app.safe_after(0, app.populate_inventory_view)
    app.safe_after(0, lambda: app.root.config(cursor=""))

app.root.config(cursor="watch")
app.root.update()
threading.Thread(target=publish_worker, daemon=True).start()

    def publish_to_discogs(self):
"""Publish selected items to Discogs"""
selected = app.inventory_tree.selection()
if not selected: return
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue
        # Latest-wins check: warn if Discogs data is newer
        try:
            local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
            remote_ts = record.get("discogs_updated_at")
            proceed = True
            if remote_ts and local_ts:
                try:
                    ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                    rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                    if rdt > ldt:
                        msg = (f"SKU {sku}: The Discogs data was updated more recently than your local copy.\n"
                               f"Local updated: {ldt.isoformat()}\n"
                               f"Discogs updated: {rdt.isoformat()}\n\n"
                               "Proceeding will overwrite Discogs with local data. Continue?")
                        proceed = messagebox.askyesno("Potential Conflict", msg)
                except Exception:
                    pass
            if not proceed:
                app.append_log(f"SKU {sku}: Skipped due to newer Discogs data.", "orange")
                continue
        except Exception:
            pass

        errors = validate_listing("discogs", record, app.config)
        if errors:
            app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
            continue
        app.append_log(f"Publishing SKU {sku} to Discogs...", "black")
        listing_data = {
            "release_id": record.get("discogs_release_id"),
            "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
            "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
            "price": record.get("price", 0), "status": "Draft", "comments": record.get("description", "")
        }
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.append_log(f"SKU {sku}: Listed as Draft (ID: {listing_id})", "green")
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                        (listing_id, now_iso, sku),
                    )
            except Exception as e:
                logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
        else:
            app.append_log(f"SKU {sku}: Failed to create listing", "red")
    except Exception as e:
        app.append_log(f"SKU {sku}: Error - {e}", "red")

    def save_to_ebay_drafts_inventory(self):
"""
Create a Sell Listings draft for each selected inventory item. This is a safe operation
that does not publish the listing live. The returned draft ID and update timestamp
are saved back to the database.
"""
if globals().get("PUBLISH_HARD_BLOCK"):
    app.append_log("[draft] BLOCKED BY FLAG", "orange")
    return
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items from the inventory to save drafts.")
    return

# Switch to inventory tab to display logs
app.notebook.select(app.inventory_tab)

def draft_worker():
    # Force the eBay API wrapper to refresh the access token on each
    # draft creation. This ensures that any newly added scopes (e.g.
    # sell.listing) are included in the token. Without this, the
    # cached access token may not contain the required scope and
    # draft creation can fail silently.
    try:
        app.ebay_api.access_token = None
    except Exception:
        pass
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue

            # Check latest-wins management: warn if remote data is newer than local
            try:
                local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
                remote_ts = record.get("ebay_updated_at")
                proceed = True
                if remote_ts and local_ts:
                    try:
                        ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                        rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                        if rdt > ldt:
                            msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                                   f"Local updated: {ldt.isoformat()}\n"
                                   f"eBay updated: {rdt.isoformat()}\n\n"
                                   "Proceeding will overwrite eBay with local data. Continue?")
                            proceed = messagebox.askyesno("Potential Conflict", msg)
                    except Exception:
                        pass
                if not proceed:
                    app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                    continue
            except Exception:
                pass

            # Build listing_data similar to publish_to_ebay
            format_val = record.get("format", "LP")
            media_cond_str = record.get("media_condition", "")
            # Map media grade to eBay enums/IDs. Use "USED_GOOD" and 3000 as
            # safe fallbacks for unknown grades. The numeric ID will not be
            # transmitted for the Records category.
            condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
            condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
            category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")
            listing_data = {
                "sku": sku,
                "title": record.get("listing_title") or record.get("title", "")[:80],
                "description": record.get("description", ""),
                "price": record.get("price", 0),
                "quantity": 1,
                "categoryId": category_id,
                "condition_enum": condition_enum,
                "condition_id_numeric": condition_id_numeric,
                "media_condition": record.get("media_condition"),
                "sleeve_condition": record.get("sleeve_condition"),
                "images": record.get("images", []),
                "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
                "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
                "returnPolicyId": app.config.get("ebay_return_policy_id"),
                "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
                "currency": "GBP"
            }
            # Attempt to collect image URLs if necessary
            try:
                # Convert local images to eBay-hosted URLs if none exist
                if not listing_data.get("images") and record.get("image_urls"):
                    listing_data["imageUrls"] = record.get("image_urls")
                else:
                    # Fallback: rely on eBay API wrapper to upload images
                    listing_data["images"] = record.get("images", [])
            except Exception:
                pass

            res = app.ebay_api.create_sell_listing_draft(listing_data)
            if res.get("success"):
                draft_id = res.get("draftId")
                # Write back ID and timestamp
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET ebay_item_draft_id = ?, ebay_updated_at = ? WHERE sku = ?",
                            (draft_id, now_iso, sku),
                        )
                    app.append_log(f"SKU {sku}: eBay draft created (Draft ID: {draft_id}).", "green")
                except Exception as e:
                    app.append_log(f"SKU {sku}: Draft created but failed to save ID to DB: {e}", "red")
            else:
                err = res.get("error") or res.get("body")
                status = res.get("status")
                if status:
                    app.append_log(f"SKU {sku}: Failed to create eBay draft (status {status}): {err}", "red")
                else:
                    app.append_log(f"SKU {sku}: Failed to create eBay draft: {err}", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Unexpected error during draft creation: {e}", "red")

    # Refresh inventory view on the main thread
    app.safe_after(0, lambda: app.populate_inventory_view(app.inventory_search_var.get()))
    app.safe_after(0, lambda: app.root.config(cursor=""))

# Show busy cursor and start background thread
app.root.config(cursor="watch")
app.root.update()
threading.Thread(target=draft_worker, daemon=True).start()

    def open_listing_in_browser(self):
"""
Open the appropriate listing page in the user's default web browser for the selected
inventory item. Priority is given to eBay drafts, then live eBay listings,
then Discogs listings.
"""
selected = app.inventory_tree.focus()
if not selected:
    return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    # Try to open eBay draft if present
    draft_id = record.get("ebay_item_draft_id")
    if draft_id:
        # eBay does not provide direct draft URLs; open drafts overview
        webbrowser.open_new_tab("https://www.ebay.co.uk/sh/lst/drafts")
        return
    live_id = record.get("ebay_listing_id")
    if live_id:
        webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{live_id}")
        return
    discogs_id = record.get("discogs_listing_id")
    if discogs_id:
        webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{discogs_id}")
        return
    messagebox.showinfo("No Listing", "This item does not have any listing IDs yet.")
except Exception as e:
    logger.error(f"Failed to open listing: {e}")
    messagebox.showerror("Error", f"Failed to open listing: {e}")
    
    def append_log(self, message, color="black"):
"""Append message to publish log"""
def do_append():
    timestamp = datetime.datetime.now().strftime("[%H:%M:%S]")
    app.publish_log.config(state="normal")
    app.publish_log.insert("end", f"{timestamp} {message}\n", (color,))
    app.publish_log.tag_configure("red", foreground="red")
    app.publish_log.tag_configure("green", foreground="green")
    app.publish_log.tag_configure("black", foreground="black")
    app.publish_log.see("end")
    app.publish_log.config(state="disabled")
app.safe_after(0, do_append)

    def show_inventory_context_menu(self, event):
"""Show inventory context menu"""
row_id = app.inventory_tree.identify_row(event.y)
if row_id:
    app.inventory_tree.selection_set(row_id)
    app.inventory_tree.focus(row_id)
    app.inventory_context_menu.post(event.x_root, event.y_root)
    
    def show_discogs_context_menu(self, event):
"""Show Discogs results context menu"""
row_id = app.discogs_tree.identify_row(event.y)
if row_id:
    app.discogs_tree.selection_set(row_id)
    app.discogs_tree.focus(row_id)
    app.discogs_context_menu.post(event.x_root, event.y_root)
    
    def open_discogs_listing(self):
"""Open Discogs listing for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("discogs_listing_id"):
        webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{record['discogs_listing_id']}")
    else:
        messagebox.showinfo("No Discogs Listing", "This item has no Discogs listing ID.")
except Exception as e:
    logger.error(f"Failed to open Discogs listing: {e}")
    
    def open_ebay_listing(self):
"""Open eBay listing for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("ebay_listing_id"):
        webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{record['ebay_listing_id']}")
    else:
        messagebox.showinfo("No eBay Listing", "This item has no eBay listing ID.")
except Exception as e:
    logger.error(f"Failed to open eBay listing: {e}")
    
    def open_discogs_release_from_inventory(self):
"""Open Discogs release page for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("discogs_release_id"):
        webbrowser.open_new_tab(f"https://www.discogs.com/release/{record['discogs_release_id']}")
    else:
        messagebox.showinfo("No Release Linked", "This item has no Discogs release ID.")
except Exception as e:
    logger.error(f"Failed to open release page: {e}")
    
    def open_discogs_release_page(self):
"""Open selected release on Discogs website"""
selected = app.discogs_tree.focus()
if not selected: return
release_id = app.discogs_tree.item(selected, "values")[0]
webbrowser.open_new_tab(f"https://www.discogs.com/release/{release_id}")
    
    def open_sold_listings_from_selection(self, platform):
"""Open sold listings search for selected Discogs result"""
selected = app.discogs_tree.focus()
if not selected: return
_, artist, title, catno, _, _, _ = app.discogs_tree.item(selected, "values")
query = f"{artist} {title} {catno}".strip()
url = f"https://www.ebay.co.uk/sch/i.html?_nkw={quote_plus(query)}&_sacat=176985&LH_Sold=1&LH_Complete=1" if platform == "eBay" else f"https://www.discogs.com/search/?q={quote_plus(query)}&type=all"
webbrowser.open_new_tab(url)
    
    def get_price_suggestion(self):
"""Get price suggestions for selected release"""
selected = app.discogs_tree.focus()
if not selected: return
release_id = int(app.discogs_tree.item(selected, "values")[0])
app.root.config(cursor="watch")
app.root.update()
def fetch_worker():
    try:
        suggestions = app.discogs_api.get_price_suggestions(release_id)
        if suggestions:
            msg = "Price Suggestions:\n\n" + "\n".join([f"{condition}: £{price_data['value']:.2f}" for condition, price_data in suggestions.items()])
            app.safe_after(0, lambda: messagebox.showinfo("Price Suggestions", msg))
        else:
            app.safe_after(0, lambda: messagebox.showinfo("No Data", "No price suggestions available"))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=fetch_worker, daemon=True).start()
    
    def refresh_discogs_view(self, event=None):
"""Refresh Discogs results with filter"""
filter_text = app.discogs_search_filter_var.get().lower()
if not app.discogs_search_results: return
for item in app.discogs_tree.get_children(): app.discogs_tree.delete(item)
for result in app.discogs_search_results:
    artist, title = (result.get("title", "").split(" - ", 1) + [""])[:2]
    if filter_text and filter_text not in f"{artist} {title} {result.get('catno', '')} {result.get('year', '')}".lower(): continue
    values = (result.get("id"), artist, title, result.get("catno", "N/A"), result.get("year", "N/A"), result.get("country", "N/A"), ", ".join(result.get("format", [])))
    app.discogs_tree.insert("", "end", values=values)
    
    def sort_discogs_results(self, col):
"""Sort Discogs results by column"""
if app.discogs_sort_column == col:
    app.discogs_sort_direction = "ASC" if app.discogs_sort_direction == "DESC" else "DESC"
else:
    app.discogs_sort_column, app.discogs_sort_direction = col, "ASC"
if app.discogs_search_results:
    def sort_key(item):
        if col == "Artist": return (item.get("title", "").split(" - ", 1) + [""])[0].lower()
        elif col == "Title": return (item.get("title", "").split(" - ", 1) + [""])[1].lower()
        elif col == "Year":
            try: return int(item.get("year", 0))
            except: return 0
        else: return str(item.get(col.lower(), "")).lower()
    app.discogs_search_results.sort(key=sort_key, reverse=(app.discogs_sort_direction == "DESC"))
    app.refresh_discogs_view()
    
    def authenticate_discogs(self):
"""Authenticate with Discogs"""
consumer_key = app.config.get("discogs_consumer_key")
consumer_secret = app.config.get("discogs_consumer_secret")
if not consumer_key or not consumer_secret:
    messagebox.showerror("Configuration Error", "Discogs Consumer Key/Secret not found in config.json.\nPlease add these to your configuration file.")
    return
try:
    client = discogs_client.Client("VinylListingTool/5.1", consumer_key=consumer_key, consumer_secret=consumer_secret)
    token, secret, url = client.get_authorize_url()
    webbrowser.open(url)
    pin = simpledialog.askstring("Discogs Authentication", "Please enter the verification code from Discogs:")
    if not pin: return
    access_token, access_secret = client.get_access_token(pin)
    app.config.save({"discogs_oauth_token": access_token, "discogs_oauth_token_secret": access_secret})
    app.discogs_api = DiscogsAPI(app.config)
    if app.discogs_api.is_connected():
        app._update_connection_status()
        messagebox.showinfo("Success", "Successfully connected to Discogs!")
    else:
        messagebox.showerror("Error", "Failed to connect to Discogs")
except Exception as e:
    logger.error(f"Discogs authentication failed: {e}")
    messagebox.showerror("Authentication Error", str(e))
    
    def test_ebay_connection(self):
"""Test eBay connection"""
if app.ebay_api.test_connection():
    app.ebay_auth_status_var.set("Connected")
    messagebox.showinfo("Success", "Successfully connected to eBay!")
else:
    app.ebay_auth_status_var.set("Not Connected")
    messagebox.showerror("Connection Failed", "Could not connect to eBay.\nPlease check your credentials in config.json")
    
    def check_discogs_sales(self):
"""Check for Discogs sales"""
if not app.discogs_api.is_connected(): return
app.root.config(cursor="watch"); app.root.update()
def sales_worker():
    try:
        orders = app.discogs_api.get_orders(['Payment Received', 'Shipped'])
        app.safe_after(0, lambda: app._display_discogs_sales(orders))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_discogs_sales(self, orders):
"""Display Discogs sales"""
for item in app.sales_tree.get_children(): app.sales_tree.delete(item)
if not orders:
    messagebox.showinfo("No Sales", "No sales with status 'Payment Received' or 'Shipped' found.")
    return
for order in orders:
    for item in order.items:
        artist = item.release.artists[0].name if item.release.artists else "Various"
        title = item.release.title.replace(f"{artist} - ", "", 1).strip()
        sale_date = datetime.datetime.strptime(order.data['created'][:10], "%Y-%m-%d").strftime("%d-%m-%Y")
        sale_price = f"{item.price.value} {item.price.currency}"
        values = (order.id, sale_date, order.buyer.username, artist, title, sale_price, item.release.id)
        app.sales_tree.insert("", "end", values=values)
    
    def sync_discogs_sale(self):
"""Sync selected Discogs sale to inventory"""
selected = app.sales_tree.focus()
if not selected: return
release_id = app.sales_tree.item(selected, "values")[6]
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku FROM inventory WHERE discogs_release_id = ? AND status = 'For Sale'", (release_id,))
        record = cursor.fetchone()
        if record:
            sku = record[0]
            if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
                app.update_inventory_status("Sold")
                messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
        else:
            messagebox.showwarning("No Match", f"Could not find an unsold item with Release ID: {release_id}.")
except Exception as e:
    logger.error(f"Failed to sync sale: {e}")
    messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def check_ebay_sales(self):
"""Check for eBay sales"""
if not app.ebay_api.test_connection(): return
try:
    start_date = datetime.datetime.strptime(app.ebay_start_date_var.get(), "%d-%m-%Y")
    end_date = datetime.datetime.strptime(app.ebay_end_date_var.get(), "%d-%m-%Y")
    if (end_date - start_date).days > 30:
        messagebox.showerror("Date Range Error", "The date range cannot exceed 30 days.")
        return
except ValueError:
    messagebox.showerror("Date Format Error", "Please enter dates in DD-MM-YYYY format.")
    return
app.root.config(cursor="watch"); app.root.update()
def sales_worker():
    try:
        orders = app.ebay_api.get_orders(start_date, end_date)
        app.safe_after(0, lambda: app._display_ebay_sales(orders))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_ebay_sales(self, orders):
"""Display eBay sales"""
for item in app.ebay_sales_tree.get_children(): app.ebay_sales_tree.delete(item)
if not orders:
    messagebox.showinfo("No eBay Sales", "No completed sales found in the specified date range.")
    return
for order in orders:
    order_id, created_date, buyer = order.get("orderId"), order.get("creationDate", "")[:10], order.get("buyer", {}).get("username", "")
    for line_item in order.get("lineItems", []):
        title, price, currency, item_id = line_item.get("title", ""), line_item.get("lineItemCost", {}).get("value", ""), line_item.get("lineItemCost", {}).get("currency", "GBP"), line_item.get("legacyItemId", "")
        artist, album_title = "", title
        if ":" in title:
            parts = title.split(":", 1)
            artist, album_title = parts[0].strip(), parts[1].strip()
        values = (order_id, created_date, buyer, artist, album_title, f"{price} {currency}", item_id)
        app.ebay_sales_tree.insert("", "end", values=values)
    
    def sync_ebay_sale(self):
"""Sync selected eBay sale to inventory"""
selected = app.ebay_sales_tree.focus()
if not selected: return
_, _, _, artist, title, _, item_id = app.ebay_sales_tree.item(selected, "values")
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku FROM inventory WHERE (ebay_listing_id = ? OR (artist LIKE ? AND title LIKE ?)) AND status = 'For Sale'", (item_id, f"%{artist}%", f"%{title}%"))
        record = cursor.fetchone()
        if record:
            sku = record[0]
            if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
                app.update_inventory_status("Sold")
                messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
        else:
            messagebox.showwarning("No Match", f"Could not find an unsold item matching:\n{artist} - {title}")
except Exception as e:
    logger.error(f"Failed to sync sale: {e}")
    messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def start_discogs_import(self):
"""Import inventory from Discogs"""
if not app.discogs_api.is_connected(): return
if not messagebox.askyesno("Confirm Import", "This will import all 'For Sale' items from Discogs.\nExisting items will be skipped.\n\nContinue?"): return
app.root.config(cursor="watch"); app.root.update()
def import_worker():
    try:
        inventory = app.discogs_api.get_inventory()
        app.safe_after(0, lambda: app._process_discogs_import(inventory))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Import Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=import_worker, daemon=True).start()
    
    def _process_discogs_import(self, inventory):
"""Process Discogs import"""
new_items, skipped_items = 0, 0
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        for listing in inventory:
            if listing.status != 'For Sale': continue
            cursor.execute("SELECT COUNT(*) FROM inventory WHERE discogs_listing_id = ?", (listing.id,))
            if cursor.fetchone()[0] > 0:
                skipped_items += 1
                continue
            new_items += 1
            artist = listing.release.artists[0].name if listing.release.artists else "Various"
            title = listing.release.title.replace(f"{artist} - ", "", 1).strip()
            sku = datetime.datetime.now().strftime(f"%Y%m%d-%H%M%S-{new_items}")
            now = datetime.datetime.now(datetime.timezone.utc).isoformat()
            sql = """INSERT INTO inventory (sku, artist, title, cat_no, media_condition, sleeve_condition, price, status, discogs_release_id, discogs_listing_id, date_added, last_modified) 
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"""
            media_cond = DISCOGS_GRADE_MAP.get(listing.condition, listing.condition)
            sleeve_cond = DISCOGS_GRADE_MAP.get(listing.sleeve_condition, listing.sleeve_condition)
            catno = getattr(listing.release, 'catno', '')
            cursor.execute(sql, (sku, artist, title, catno, media_cond, sleeve_cond, listing.price.value, "For Sale", listing.release.id, listing.id, now, now))
    messagebox.showinfo("Import Complete", f"Successfully imported {new_items} new item(s).\nSkipped {skipped_items} existing item(s).")
    app.populate_inventory_view()
except Exception as e:
    logger.error(f"Import failed: {e}")
    messagebox.showerror("Import Error", f"An error occurred during import:\n{e}")
    
    def toggle_auto_sync(self):
"""Toggle automatic sync"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
    app.auto_sync_var.set(False)
    return
app.auto_sync_enabled = app.auto_sync_var.get()
app.config.save({"auto_sync_enabled": app.auto_sync_enabled})
if app.auto_sync_enabled: app.start_auto_sync()
else: app.stop_auto_sync()
    
    def toggle_two_way_sync(self):
"""Toggle two-way sync"""
app.two_way_sync_enabled = app.two_way_sync_var.get()
app.config.save({"two_way_sync_enabled": app.two_way_sync_enabled})
app.log_sync_activity(f"Two-way sync {'enabled' if app.two_way_sync_enabled else 'disabled'}")
    
    def toggle_attempt_updates(self):
"""Toggle attempt to update Discogs"""
app.attempt_discogs_updates = app.attempt_updates_var.get()
app.config.save({"attempt_discogs_updates": app.attempt_discogs_updates})
app.log_sync_activity(f"Discogs update attempts {'enabled' if app.attempt_discogs_updates else 'disabled'}")
    
    def update_sync_interval(self):
"""Update sync interval"""
try:
    minutes = int(app.sync_interval_var.get())
    app.auto_sync_interval = minutes * 60
    app.config.save({"auto_sync_interval": app.auto_sync_interval})
    app.log_sync_activity(f"Sync interval set to {minutes} minutes")
except ValueError: app.sync_interval_var.set("5")
    
    def start_auto_sync(self):
"""Start automatic sync"""
if app.auto_sync_thread and app.auto_sync_thread.is_alive(): return
app.auto_sync_stop_event.clear()
app.auto_sync_thread = threading.Thread(target=app._auto_sync_worker, daemon=True)
app.auto_sync_thread.start()
app.sync_status_var.set("Auto-sync enabled - waiting for next sync...")
app.log_sync_activity("Automatic sync started")
    
    def stop_auto_sync(self):
"""Stop automatic sync"""
app.auto_sync_stop_event.set()
app.sync_status_var.set("Auto-sync disabled")
app.log_sync_activity("Automatic sync stopped")
    
    def _auto_sync_worker(self):
"""Auto sync worker thread"""
while not app.auto_sync_stop_event.is_set():
    try:
        if app.auto_sync_stop_event.wait(app.auto_sync_interval): break
        if app.auto_sync_enabled and app.discogs_api.is_connected():
            app.safe_after(0, lambda: app.sync_status_var.set("Syncing inventory..."))
            sync_result = app._perform_inventory_sync()
            app.safe_after(0, lambda r=sync_result: app._handle_sync_result(r))
    except Exception as e:
        app.safe_after(0, lambda msg=f"Auto-sync error: {e}": app.log_sync_activity(msg))
    
    def manual_sync_now(self):
"""Perform manual sync now"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
    return
app.sync_status_var.set("Manual sync in progress...")
app.root.config(cursor="watch"); app.root.update()
def sync_worker():
    try:
        result = app._perform_inventory_sync()
        app.safe_after(0, lambda: app._handle_sync_result(result))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Sync Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sync_worker, daemon=True).start()
    
    def _perform_inventory_sync(self):
"""Implements true "latest-wins" two-way sync logic."""
sync_start_time = datetime.datetime.now(datetime.timezone.utc)
app.log_sync_activity("=== STARTING SYNC (Latest-Wins) ===")
try:
    discogs_inventory = app.discogs_api.get_inventory()
    discogs_map = {listing.id: listing for listing in discogs_inventory}
    app.log_sync_activity(f"Retrieved {len(discogs_inventory)} active listings from Discogs.")

    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku, discogs_listing_id, price, status, notes, last_modified, last_sync_time FROM inventory WHERE discogs_listing_id IS NOT NULL")
        local_items = [dict(row) for row in cursor.fetchall()]
        local_map = {item['discogs_listing_id']: item for item in local_items}
    app.log_sync_activity(f"Found {len(local_map)} linked local items.")

    updates_to_local, updates_to_discogs, deletions_from_local, new_sales = 0, 0, 0, 0
    
    for local_item in local_items:
        listing_id, last_mod_local_str, last_sync_str = local_item['discogs_listing_id'], local_item.get('last_modified'), app.last_successful_sync_time or local_item.get('last_sync_time')
        if not last_mod_local_str or not last_sync_str: continue
        try:
            last_mod_local, last_sync = datetime.datetime.fromisoformat(last_mod_local_str), datetime.datetime.fromisoformat(last_sync_str)
        except (ValueError, TypeError): continue

        if last_mod_local > last_sync and app.attempt_discogs_updates:
            if listing_id in discogs_map:
                app.log_sync_activity(f"→ Local change detected for SKU {local_item['sku']}. Pushing to Discogs.")
                update_payload = {"price": local_item['price'], "status": app._map_local_to_discogs_status(local_item['status']), "comments": local_item.get('notes', '')}
                if app.discogs_api.update_listing(listing_id, update_payload):
                    updates_to_discogs += 1; app.log_sync_activity(f"  ✓ Pushed update for SKU {local_item['sku']} to Discogs.")
                else: app.log_sync_activity(f"  ✗ Failed to push update for SKU {local_item['sku']}.")
            else: app.log_sync_activity(f"  - SKU {local_item['sku']} changed locally but no longer on Discogs. Skipping push.")

        elif listing_id in discogs_map:
            listing = discogs_map[listing_id]
            mapped_status = app.status_mappings.get(listing.status, "Not For Sale")
            if mapped_status != local_item['status']:
                with app.db.get_connection() as conn:
                    conn.cursor().execute("UPDATE inventory SET status = ?, last_modified = ? WHERE discogs_listing_id = ?", (mapped_status, sync_start_time.isoformat(), listing_id))
                updates_to_local += 1
                if mapped_status == 'Sold' and local_item['status'] != 'Sold': new_sales += 1
                app.log_sync_activity(f"✓ Sync from Discogs: SKU {local_item['sku']} '{local_item['status']}' → '{mapped_status}'")

    ids_to_delete_locally = set(local_map.keys()) - set(discogs_map.keys())
    if ids_to_delete_locally:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            for listing_id in ids_to_delete_locally:
                if local_map[listing_id]['status'] == 'For Sale':
                    sku = local_map[listing_id]['sku']
                    cursor.execute("DELETE FROM inventory WHERE discogs_listing_id = ?", (listing_id,))
                    deletions_from_local += 1
                    app.log_sync_activity(f"✓ Deleted SKU {sku} locally as it's no longer on Discogs.")
    
    with app.db.get_connection() as conn:
        conn.cursor().execute("UPDATE inventory SET last_sync_time = ? WHERE discogs_listing_id IS NOT NULL", (sync_start_time.isoformat(),))
    app.last_successful_sync_time = sync_start_time.isoformat()
    app.config.save({"last_successful_sync_time": app.last_successful_sync_time})
    if updates_to_local > 0 or deletions_from_local > 0: app.safe_after(0, app.populate_inventory_view)
    app.log_sync_activity("=== SYNC COMPLETED ===")
    return {'success': True, 'updates_local': updates_to_local, 'updates_discogs': updates_to_discogs, 'deletions': deletions_from_local, 'new_sales': new_sales, 'total_checked': len(discogs_inventory)}
except Exception as e:
    logger.error(f"Sync failed: {e}", exc_info=True)
    app.log_sync_activity(f"✗ SYNC ERROR: {e}")
    return {'success': False, 'error': str(e)}

    def _map_local_to_discogs_status(self, local_status):
"""Map local status to valid Discogs status"""
return {'For Sale': 'For Sale', 'Sold': 'Sold'}.get(local_status, 'Draft')
    
    def _handle_sync_result(self, result):
"""Handle sync result"""
current_time = datetime.datetime.now().strftime("%H:%M:%S")
if result.get('success'):
    updates_local, updates_discogs, deletions = result.get('updates_local', 0), result.get('updates_discogs', 0), result.get('deletions', 0)
    total_changes = updates_local + updates_discogs + deletions
    if total_changes > 0:
        log_msg = f"[{current_time}] Sync completed: {total_changes} changes from {result['total_checked']} listings"
        if updates_local > 0: log_msg += f"\n  - Pulled from Discogs: {updates_local}"
        if updates_discogs > 0: log_msg += f"\n  - Pushed to Discogs: {updates_discogs}"
        if deletions > 0: log_msg += f"\n  - Items deleted locally: {deletions}"
        if result.get('new_sales', 0) > 0: log_msg += f"\n  - New sales detected: {result['new_sales']}"
        app.log_sync_activity(log_msg)
        status_msg = f"Sync complete - {total_changes} change(s)"
    else:
        status_msg = "Sync complete - no changes needed"
        app.log_sync_activity(f"[{current_time}] Sync completed. No changes needed.")
    app.sync_status_var.set(f"Last sync: {current_time}. {status_msg}")
else:
    app.sync_status_var.set(f"Last sync: {current_time}. FAILED.")
    app.log_sync_activity(f"[{current_time}] Sync FAILED: {result.get('error')}")

    # ========================================================================
    # ENHANCED PUBLISHING ACTION METHODS
    # ========================================================================
    
    def action_ebay_save_unpublished(self):
"""Save eBay listing data locally as 'ready to publish' without sending to eBay"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - save current form
    app._save_ebay_draft_from_lister()
else:
    # From Inventory tab - mark selected items as ready for eBay
    app._save_ebay_draft_from_inventory()

    def action_ebay_publish_live(self):
"""Publish directly to eBay as live listings (Inventory API)"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - publish current form directly
    app.list_on_ebay()
else:
    # From Inventory tab - publish selected items
    app.publish_to_ebay()



    def reconcile_from_ebay(self, skus):


"""Pull eBay state back into local DB so deletions/ends/relists are reflected.


Chooses ACTIVE offer. Prefers Item ID (listingId); falls back to offerId if listingId hasn't propagated yet.


Refreshes the grid when done.


"""


import datetime, logging, requests


logger = logging.getLogger(__name__)


    


token = app.ebay_api.get_access_token()


if not token:


    app.append_log("Cannot reconcile: missing eBay token", "red")


    return


    


headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}


changed = False


    


for sku in (skus or []):


    try:


        url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={sku}"


        r = requests.get(url, headers=headers, timeout=30)


        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()


    


        if r.status_code == 200 and r.json().get("offers"):


            offers = r.json()["offers"]


            # Pick ACTIVE offer if available; otherwise first one


            active = None


            for o in offers:


                if (o.get("status") or "").upper() == "ACTIVE":


                    active = o


                    break


            offer = active or offers[0]


            status = (offer.get("status") or "").upper()


    


            listing_id = offer.get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('legacyItemId') or (offer.get('listing') or {}).get('listingId')


            offer_id = offer.get("offerId") or (offer.get("offer") or {}).get("offerId")


    


            # If ACTIVE but listingId missing, try GET /offer/{offerId} to resolve


            if status in ("ACTIVE","PUBLISHED") and not listing_id and offer_id:


                try:


                    resolved = app.ebay_api.get_offer(str(offer_id))


                    if resolved.get("success"):


                        listing_id = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')


                except Exception as e:


                    logger.warning(f"[reconcile] get_offer failed for offer {offer_id}: {e}")


    


            with app.db.get_connection() as conn:


                c = conn.cursor()


                if status in ("ACTIVE","PUBLISHED"):


                    stored_id = listing_id or (offer_id if offer_id else None)


                    if stored_id:


                        c.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))


                        changed = True


                    else:


                        c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                        changed = True


                else:


                    c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                    changed = True


    


            shown = listing_id or (offer_id if (status in ("ACTIVE","PUBLISHED") and offer_id) else "—")


            label = "Item ID" if listing_id else ("Offer ID" if shown != "—" else "—")  # live


            app.append_log(f"SKU {sku}: reconciled from eBay ({status}; {label}={shown})", "blue")


        else:


            with app.db.get_connection() as conn:


                c = conn.cursor()


                c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


            changed = True


            app.append_log(f"SKU {sku}: no eBay offer found; cleared local mapping.", "orange")


    


    except Exception as e:


        logger.error(f"Reconcile error for {sku}: {e}")


        app.append_log(f"SKU {sku}: reconcile failed: {e}", "red")


    


if changed:


    try:


        app.populate_inventory_view()


    except Exception:


        pass



    def action_open_on_ebay_selected(self):



"""Open the selected item's eBay listing in the browser using stored Item ID."""



import webbrowser, requests, logging



logger = logging.getLogger(__name__)



items = app.inventory_tree.selection()



if not items:



    try:



        messagebox.showinfo("Open on eBay", "Please select a row first.")



    except Exception:



        pass



    return



iid = items[0]



vals = app.inventory_tree.item(iid, "values") or []



item_id = None



# Try visible column first



try:



    headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



    if "eBay ID" in headers:



        idx = headers.index("eBay ID")



        if idx < len(vals):



            item_id = vals[idx]



except Exception:



    item_id = None



# Fallback: DB lookup by SKU (assumes SKU in first column)



if not item_id and vals:



    sku = vals[0]



    try:



        with app.db.get_connection() as conn:



            c = conn.cursor()



            c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



            row = c.fetchone()



            if row and row[0]:



                item_id = row[0]



    except Exception:



        pass



if not item_id:



    try:



        messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



    except Exception:



        pass



    return



# If it's likely an offerId, try resolve to listingId on the fly



if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



    try:



        token = app.ebay_api.get_access_token()



        if token:



            headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



            url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



            r = requests.get(url, headers=headers, timeout=30)



            if r.status_code == 200 and r.json().get("offers"):



                offers = r.json()["offers"]



                active = None



                for o in offers:



                    if (o.get("status") or "").upper() == "ACTIVE":



                        active = o



                        break



                off = active or offers[0]



                lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



                if not lid:



                    oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                    if oid:



                        resolved = app.ebay_api.get_offer(str(oid))



                        if resolved.get("success"):



                            lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



                if lid:



                    item_id = lid



    except Exception as e:



        logger.warning(f"[open] resolution failed: {e}")



try:



    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



except Exception:



    try:



        messagebox.showerror("Open on eBay", "Failed to open browser.")



    except Exception:



        pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




try:




    offers = app._fetch_all_ebay_offers()




except Exception as e:




    messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




    return




work = []




with app.db.get_connection() as conn:




    c = conn.cursor()




    for off in offers:




        sku = (off.get("sku") or "").strip()




        if not sku:




            continue




        c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




        row = c.fetchone()




        if not row or not row[0]:




            work.append(off)




if not work:




    messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




    return




app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def _prepare_ebay_listing_data(app, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def save_to_ebay_drafts(app, listing_data: dict = None):
"""Create/Update SELL LISTINGS draft only (no publish)."""
try:
    payload = listing_data or app.get_current_lister_listing_data()
    res = app.ebay_api.create_sell_listing_draft(payload)
    if res.get("success"):
        draft_id = res.get("draftId")
        app.append_log(f"[draft] Saved eBay draft (Draft ID: {draft_id})", "green")
        return {"success": True, "draftId": draft_id}
    else:
        app.append_log(f"[draft] Failed: status={res.get('status')} rlogid={res.get('rlogid')} body={res.get('body')}", "red")
        return {"success": False, "error": res}
except Exception as e:
    import traceback; traceback.print_exc()
    app.append_log(f"[draft] Error: {e}", "red")
    return {"success": False, "error": str(e)}

    def _install_lister_draft_live_buttons(self):
import tkinter as tk
parent = getattr(self, "lister_controls_frame", None) or getattr(self, "lister_tab", None) or getattr(self, "root", None)
if not parent:
    return
# Remove the separate "Save to eBay Drafts" button.  Drafts are no longer
# supported; listings will be published live via the existing publish
# button in the inventory tab.  We simply rename any existing Publish
# button to make its purpose clear.  No new button is created here.
try:
    for child in parent.winfo_children():
        try:
            txt = child.cget("text")
            # Rename any legacy Publish button to indicate a live publish
            if isinstance(txt, str) and ("Publish" in txt and "eBay" in txt):
                child.configure(text="Publish Live to eBay")
        except Exception:
            continue
except Exception:
    pass
    # Main application class with complete functionality
    
    def __init__(self, root):
app.root = root
app.root.title("Vinyl Listing Tool v10.3 - FINAL")

# Core components
app.config = cfg
app.db = DatabaseManager()
app.discogs_api = DiscogsAPI(app.config)
app.ebay_api = EbayAPI(app.config, app.root)

# Instance variables
app.entries = {}
app.current_release_id = None
app.current_tracklist_lines = []
app.image_paths = []
app.editing_sku = None
app.temporary_sku = None # For new items before they are saved
app.sku_display_var = tk.StringVar() # For the read-only SKU display
app.image_staging_path_var = tk.StringVar() # For settings tab
app.inventory_sort_column = "id"
app.inventory_sort_direction = "DESC"
app.discogs_search_results = []
app.discogs_sort_column = "Year"
app.discogs_sort_direction = "DESC"
app.app_is_closing = False

# Auto-sync variables
app.auto_sync_enabled = app.config.get("auto_sync_enabled", False)
app.auto_sync_interval = app.config.get("auto_sync_interval", 300)
app.two_way_sync_enabled = app.config.get("two_way_sync_enabled", False)
app.attempt_discogs_updates = app.config.get("attempt_discogs_updates", True)
app.last_successful_sync_time = app.config.get("last_successful_sync_time", None)
app.auto_sync_thread = None
app.auto_sync_stop_event = threading.Event()
app.sync_log = []

# Status mapping
app.status_mappings = app._load_status_mappings()
app.status_mapping_vars = {}

# Collection state
app._collection_state = {
    "folders": [],
    "folder_id": None,
    "page": 1,
    "pages": 1,
    "per_page": 100,
    "items": [],
    "filter": ""
}

# Setup GUI
app._load_geometry()
app._setup_gui()
app.root.protocol("WM_DELETE_WINDOW", app.on_closing)

# Initialize views
app.populate_inventory_view()
app.image_staging_path_var.set(app.config.get("image_staging_path", ""))

# Initialize connections
app._update_connection_status()

# Initialize auto-sync if enabled
if app.auto_sync_enabled and app.discogs_api.is_connected():
    app.start_auto_sync()
    
    def _load_status_mappings(self):
"""Load status mappings from config or use defaults"""
mappings = app.config.get("status_mappings", DEFAULT_STATUS_MAPPINGS.copy())
for discogs_status in DEFAULT_STATUS_MAPPINGS:
    if discogs_status not in mappings:
        mappings[discogs_status] = DEFAULT_STATUS_MAPPINGS[discogs_status]
return mappings
    
    def _save_status_mappings(self):
"""Save current status mappings to config"""
for discogs_status, var in app.status_mapping_vars.items():
    app.status_mappings[discogs_status] = var.get()

app.config.save({"status_mappings": app.status_mappings})
app.log_sync_activity("Status mappings updated and saved")
messagebox.showinfo("Settings Saved", "Status mappings have been saved successfully.")
    
    def _reset_status_mappings(self):
"""Reset status mappings to defaults"""
if messagebox.askyesno("Reset Mappings", "Reset all status mappings to defaults?"):
    app.status_mappings = DEFAULT_STATUS_MAPPINGS.copy()
    for discogs_status, var in app.status_mapping_vars.items():
        if discogs_status in app.status_mappings:
            var.set(app.status_mappings[discogs_status])
    app.log_sync_activity("Status mappings reset to defaults")
    
    def _serialize_form_to_payload(self):
"""
Collect all lister fields + images into a JSON-serializable dict.
"""
price_s = app.price_entry.get().strip()
try:
    price_v = float(price_s) if price_s else 0.0
except Exception:
    price_v = 0.0

payload = {
    "artist": app.entries["artist"].get().strip(),
    "title": app.entries["title"].get().strip(),
    "cat_no": app.entries["cat_no"].get().strip(),
    "year": app.entries["year"].get().strip(),
    "format": app.entries["format"].get(),
    "genre": app.entries["genre"].get(),
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "price": price_v,
    "condition_notes": app.entries["condition_notes"].get("1.0", "end-1c").strip(),
    "matrix_runout": app.entries["matrix_runout"].get("1.0", "end-1c").strip(),
    "condition_tags": app.entries["condition_tags"].get().strip(),
    "description": app.full_desc.get("1.0", "end-1c").strip(),
    "shipping_option": app.entries["shipping_option"].get(),
    "barcode": app.entries["barcode"].get().strip(),
    "new_used": app.entries["new_used"].get(),
    "listing_title": app.entries["listing_title"].get().strip(),
    "discogs_release_id": app.current_release_id,
    "images": list(app.image_paths),
}
return payload
    
    def _apply_payload_to_form(self, payload: dict):
"""
Hydrates the form from a data dictionary.
"""
def set_entry(name, value):
    if name in app.entries:
        w = app.entries[name]
        final_value = value if value is not None else ""
        try:
            if isinstance(w, (tk.Entry, ttk.Entry)):
                w.delete(0, tk.END)
                w.insert(0, str(final_value))
            elif isinstance(w, ttk.Combobox):
                w.set(str(final_value))
            elif isinstance(w, tk.Text):
                w.delete("1.0", tk.END)
                w.insert("1.0", str(final_value))
        except Exception as e:
            logger.warning(f"Failed to set UI entry '{name}': {e}")

# Apply all fields from the payload
set_entry("artist", payload.get("artist"))
set_entry("title", payload.get("title"))
set_entry("cat_no", payload.get("cat_no"))
set_entry("year", payload.get("year"))
set_entry("format", payload.get("format"))
set_entry("genre", payload.get("genre"))
set_entry("media_condition", payload.get("media_condition"))
set_entry("sleeve_condition", payload.get("sleeve_condition"))
set_entry("shipping_option", payload.get("shipping_option"))
set_entry("barcode", payload.get("barcode"))
set_entry("new_used", payload.get("new_used"))
set_entry("condition_notes", payload.get("condition_notes"))
set_entry("matrix_runout", payload.get("matrix_runout"))
set_entry("condition_tags", payload.get("condition_tags"))
set_entry("listing_title", payload.get("listing_title"))

# Price
price_val = payload.get("price")
price_str = f"{price_val:.2f}" if isinstance(price_val, (int, float)) and price_val > 0 else ""
app.price_entry.delete(0, tk.END)
app.price_entry.insert(0, price_str)

# Description
desc_val = payload.get("description")
app.full_desc.delete("1.0", tk.END)
if desc_val:
    app.full_desc.insert("1.0", desc_val)

# Images
app.image_paths = list(payload.get("images") or [])
app._update_image_listbox()

# Release ID
app.current_release_id = payload.get("discogs_release_id")
    
    def _get_inventory_record(self, sku: str) -> dict:
"""Load DB row and merge lister_payload JSON over flat columns."""
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM inventory WHERE sku = ?", (sku,))
    rec = cursor.fetchone()
    if not rec:
        return {}
    d = dict(rec)
    try:
        if d.get("lister_payload"):
            p = json.loads(d["lister_payload"])
            if isinstance(p, dict):
                # Merge payload, giving payload precedence for non-empty values
                for k, v in p.items():
                    if v not in (None, "", []):
                        d[k] = v
    except (json.JSONDecodeError, TypeError):
        logger.warning(f"Could not parse lister_payload for SKU {sku}")
    return d
    
    def _load_geometry(self):
"""Load saved window geometry"""
try:
    geometry_path = os.path.join(os.path.dirname(__file__), "geometry.conf")
    with open(geometry_path, "r") as f:
        app.root.geometry(f.read())
except FileNotFoundError:
    app.root.geometry("1900x1000")
    
    def on_closing(self):
"""Handle application closing"""
app.app_is_closing = True
if app.auto_sync_enabled:
    app.stop_auto_sync()

# Save window geometry
try:
    geometry_path = os.path.join(os.path.dirname(__file__), "geometry.conf")
    with open(geometry_path, "w") as f:
        f.write(app.root.geometry())
except Exception as e:
    logger.warning(f"Could not save window geometry: {e}")

app.root.destroy()
    
    def _setup_gui(self):
"""Setup the complete GUI with all features INCLUDING Collection tab"""
app.root.option_add("*Font", "Helvetica 14")
style = ttk.Style()
style.theme_use("clam")

# Create notebook
app.notebook = ttk.Notebook(app.root)
app.notebook.pack(expand=True, fill="both")

# Create ALL tabs including Collection
app.lister_tab = ttk.Frame(app.notebook)
app.inventory_tab = ttk.Frame(app.notebook)
app.collection_tab = ttk.Frame(app.notebook)
app.settings_tab = ttk.Frame(app.notebook)

# Add tabs in correct order: Lister -> Inventory -> Collection -> Settings
app.notebook.add(app.lister_tab, text="Lister")
app.notebook.add(app.inventory_tab, text="Inventory")
app.notebook.add(app.collection_tab, text="Collection")
app.notebook.add(app.settings_tab, text="Settings & Sync")

# Setup each tab
app._setup_lister_tab()
app._setup_inventory_tab()
app._setup_collection_tab()
app._setup_settings_tab_complete()
    
    def _setup_collection_tab(self):
"""Setup the Collection tab synchronously"""
# Top controls frame
top = ttk.Frame(app.collection_tab)
top.pack(fill="x", padx=8, pady=6)

# Folder selection
ttk.Label(top, text="Folder:").pack(side="left")
app.collection_folder_var = tk.StringVar()
app.collection_folder_var.set("Loading...")
app.collection_folder_combo = ttk.Combobox(
    top, 
    textvariable=app.collection_folder_var, 
    state="readonly", 
    width=40
)
app.collection_folder_combo.pack(side="left", padx=(6, 12))
app.collection_folder_combo.bind("<<ComboboxSelected>>", app._on_folder_change)

# Filter entry
ttk.Label(top, text="Filter:").pack(side="left")
app.collection_filter_var = tk.StringVar()
app.collection_filter_entry = ttk.Entry(
    top, 
    textvariable=app.collection_filter_var, 
    width=28
)
app.collection_filter_entry.pack(side="left", padx=(6, 12))
app.collection_filter_entry.bind("<KeyRelease>", app._on_filter_change)

# Pagination controls
app.collection_prev_btn = ttk.Button(
    top, 
    text="< Prev", 
    command=app._collection_prev_page
)
app.collection_prev_btn.pack(side="left")

app.collection_page_label = ttk.Label(top, text="Page 1 / 1")
app.collection_page_label.pack(side="left", padx=6)

app.collection_next_btn = ttk.Button(
    top, 
    text="Next >", 
    command=app._collection_next_page
)
app.collection_next_btn.pack(side="left", padx=(0, 6))

app.collection_refresh_btn = ttk.Button(
    top, 
    text="Refresh", 
    command=app._refresh_collection
)
app.collection_refresh_btn.pack(side="left", padx=(6, 0))

# Collection tree
cols = ("added", "artist", "title", "labels", "catno", "formats", 
        "year", "folder", "rating", "instance", "release")
app.collection_tree = ttk.Treeview(
    app.collection_tab, 
    columns=cols, 
    show="headings", 
    height=18
)

# Setup columns
headings = {
    "added": "Date Added", "artist": "Artist", "title": "Title",
    "labels": "Label(s)", "catno": "Cat No", "formats": "Format(s)",
    "year": "Year", "folder": "Folder", "rating": "Rating",
    "instance": "Instance ID", "release": "Release ID"
}

for col in cols:
    app.collection_tree.heading(col, text=headings[col])
    width = 180 if col in ("title", "labels", "formats") else 110
    app.collection_tree.column(col, width=width, stretch=True)

app.collection_tree.pack(fill="both", expand=True, padx=8, pady=(0, 8))

# Click-to-sort current page
app._collection_sort = {"col": None, "reverse": False}
def _sort_by(col):
    st = app._collection_state
    items = st.get("items", [])
    keymap = {
        "added":   lambda it: (it.get("date_added") or ""),
        "artist":  lambda it: " ".join(a.get("name","") for a in it.get("basic_information",{}).get("artists",[])).lower(),
        "title":   lambda it: (it.get("basic_information",{}).get("title","") or "").lower(),
        "labels":  lambda it: " ".join(l.get("name","") for l in it.get("basic_information",{}).get("labels",[])).lower(),
        "catno":   lambda it: (it.get("basic_information",{}).get("labels",[{}])[0].get("catno","") or it.get("basic_information",{}).get("catno","") or "").lower(),
        "formats": lambda it: " ".join(f.get("name","") for f in it.get("basic_information",{}).get("formats",[])).lower(),
        "year":    lambda it: it.get("basic_information",{}).get("year") or 0,
        "rating":  lambda it: it.get("rating") or 0,
        "instance":lambda it: it.get("id") or 0,
        "release": lambda it: it.get("basic_information",{}).get("id") or 0,
        "folder":  lambda it: st.get("folder_name","").lower()
    }
    key = keymap.get(col)
    if not key: return
    prev = app._collection_sort
    reverse = prev["reverse"] if prev["col"] == col else False
    st["items"] = sorted(items, key=key, reverse=not reverse)
    app._collection_sort = {"col": col, "reverse": not reverse}
    if hasattr(self, "_render_collection_tree"):
        app._render_collection_tree()
    elif hasattr(self, "_refresh_collection_tree"):
        app._refresh_collection_tree()
for col in cols:
    app.collection_tree.heading(col, text=headings[col], command=lambda c=col: _sort_by(c))

# Bind events
app.collection_tree.bind("<Double-1>", app._collection_open_release)
app.collection_tree.bind("<Button-3>", app._collection_context_menu)


app.collection_tree.bind("<Button-2>", app._collection_context_menu)
app.collection_tree.bind("<Control-Button-1>", app._collection_context_menu)# Load folders asynchronously but don't block GUI creation
app.root.after(100, app._load_collection_folders)
    
    def _get_discogs_credentials(self):
"""Get Discogs token and username"""
token = None
username = None

try:
    if hasattr(self, "config"):
        token = (app.config.get("discogs_token") or app.config.get("discogs_oauth_token") or "").strip() or None
        username = (app.config.get("discogs_username") or "").strip() or None
except Exception:
    pass

# Fallback to environment variables
token = token or os.environ.get("DISCOGS_TOKEN")
username = username or os.environ.get("DISCOGS_USERNAME")

return token, username
    
    
    def _discogs_api_request(self, url, params=None):
"""Make Discogs API request with backoff + logging"""
if not requests:
    raise RuntimeError("'requests' not available for Discogs API")
token, username = app._get_discogs_credentials()
if not token:
    raise RuntimeError("Discogs token not configured")

headers = {
    "User-Agent": "VinylTool/1.0",
}

# Use OAuth if available, otherwise token
if app.discogs_api and app.discogs_api.is_connected():
    oauth_params = app.discogs_api._generate_oauth_params()
    signature = app.discogs_api._create_oauth_signature(
        'GET', url, oauth_params,
        app.config.get("discogs_consumer_secret"),
        app.config.get("discogs_oauth_token_secret")
    )
    oauth_params['oauth_signature'] = signature
    headers['Authorization'] = app.discogs_api._build_oauth_header(oauth_params)
else:
    headers['Authorization'] = f"Discogs token={token}"

attempt, delay = 0, 0.8
while True:
    attempt += 1
    try:
        resp = requests.get(url, headers=headers, params=(params or {}), timeout=30)
        status = resp.status_code
        if status == 429 or 500 <= status < 600:
            msg = f"[Discogs] {status} on {url} (attempt {attempt}); retrying in {delay:.1f}s"
            if hasattr(self, "log_sync_activity"): app.log_sync_activity(msg)
            else: print(msg)
            time.sleep(delay)
            delay = min(delay * 1.7, 8.0)
            if attempt < 6:
                continue
        resp.raise_for_status()
        return resp.json() or {}
    except Exception:
        if attempt < 3:
            time.sleep(delay)
            delay = min(delay * 1.7, 6.0)
            continue
        raise

    def safe_after(self, delay, callback):
try:
    if app.root and app.root.winfo_exists():
        app.root.after(delay, callback)
except RuntimeError:
    # Tk is already shutting down
    pass

    def _load_collection_folders(self):
"""Load Discogs collection folders"""
def worker():
    try:
        token, username = app._get_discogs_credentials()
        if not (token and username and app.discogs_api.is_connected()):
            app.safe_after(0, lambda: app._set_collection_error("Discogs not connected"))
            return
        
        user = app.discogs_api.client.identity()
        data = user.collection_folders
        
        folders = []
        for f in data:
            folders.append({
                "id": f.id,
                "name": f.name, 
                "count": f.count
            })
        
        def update_ui():
            app._collection_state["folders"] = folders
            labels = [f"{f['name']} ({f['count']})" for f in folders]
            app.collection_folder_combo["values"] = labels
            
            if folders:
                app.collection_folder_var.set(labels[0])
                app._collection_state["folder_id"] = folders[0]["id"]
                app._refresh_collection()
            else:
                app.collection_folder_var.set("No folders found")
        
        app.safe_after(0, update_ui)
        
    except Exception as e:
        error_msg = f"Failed to load folders: {e}"
        app.safe_after(0, lambda: app._set_collection_error(error_msg))

threading.Thread(target=worker, daemon=True).start()
    
    def _set_collection_error(self, message):
"""Set error state for collection"""
app.collection_folder_var.set(f"Error: {message}")
# Clear tree
for item in app.collection_tree.get_children():
    app.collection_tree.delete(item)
    
    def _on_folder_change(self, event=None):
"""Handle folder selection change"""
chosen = app.collection_folder_var.get()

# Find folder ID
folder_id = None
for f in app._collection_state["folders"]:
    if f"{f['name']} ({f['count']})" == chosen:
        folder_id = f["id"]
        break

if folder_id is not None:
    app._collection_state["folder_id"] = folder_id
    app._collection_state["page"] = 1
    app._refresh_collection()
    
    def _on_filter_change(self, event=None):
"""Handle filter text change"""
app._collection_state["filter"] = app.collection_filter_var.get().strip()
app._render_collection_tree()
    
    def _collection_prev_page(self):
"""Go to previous page"""
if app._collection_state["page"] > 1:
    app._collection_state["page"] -= 1
    app._refresh_collection()
    
    def _collection_next_page(self):
"""Go to next page"""
if app._collection_state["page"] < app._collection_state.get("pages", 1):
    app._collection_state["page"] += 1
    app._refresh_collection()
    
    def _refresh_collection(self):
"""Refresh collection data using direct API calls."""
def worker():
    try:
        token, username = app._get_discogs_credentials()
        if not (token and username):
            app.safe_after(0, lambda: app._set_collection_error("Discogs credentials not configured"))
            return

        folder_id = app._collection_state.get("folder_id")
        if folder_id is None:
            return

        page = app._collection_state.get("page", 1)
        per_page = app._collection_state.get("per_page", 100)
        
        url = f"https://api.discogs.com/users/{username}/collection/folders/{folder_id}/releases"
        params = {
            "page": page,
            "per_page": per_page,
            "sort": "added",
            "sort_order": "desc"
        }
        
        data = app._discogs_api_request(url, params)
        
        items = data.get("releases", [])
        pages = int(data.get("pagination", {}).get("pages", 1))
        
        # Get folder name from state
        folder_name = ""
        for f in app._collection_state["folders"]:
            if f["id"] == folder_id:
                folder_name = f["name"]
                break

        def update_ui():
            app._collection_state["items"] = items
            app._collection_state["pages"] = pages
            app._collection_state["folder_name"] = folder_name
            app._render_collection_tree()
        
        app.safe_after(0, update_ui)
        
    except Exception as e:
        error_msg = f"Failed to refresh collection: {e}"
        app.safe_after(0, lambda: app._set_collection_error(error_msg))

threading.Thread(target=worker, daemon=True).start()
    
    def _apply_collection_filter(self, items, filter_text):
"""Apply filter to collection items"""
if not filter_text:
    return items

filter_text = filter_text.lower()
filtered = []

for item in items:
    bi = item.get("basic_information", {})
    
    # Build searchable text
    artists = " ".join([a.get("name", "") for a in bi.get("artists", [])])
    labels = " ".join([l.get("name", "") for l in bi.get("labels", [])])
    formats = " ".join([f.get("name", "") for f in bi.get("formats", [])])
    
    search_text = " ".join([
        bi.get("title", ""),
        artists,
        labels, 
        formats,
        str(bi.get("year", ""))
    ]).lower()
    
    if filter_text in search_text:
        filtered.append(item)

return filtered
    
    def _render_collection_tree(self):
"""Render collection items in tree"""
# Clear existing items
for item in app.collection_tree.get_children():
    app.collection_tree.delete(item)

# Apply filter
items = app._apply_collection_filter(
    app._collection_state.get("items", []),
    app._collection_state.get("filter", "")
)

# Populate tree
folder_name = app._collection_state.get("folder_name", "")

for item in items:
    bi = item.get("basic_information", {})
    
    # Extract data
    artists = ", ".join([a.get("name", "") for a in bi.get("artists", [])])
    labels = ", ".join([l.get("name", "") for l in bi.get("labels", [])])
    formats = ", ".join([f.get("name", "") for f in bi.get("formats", [])])
    
    # Get catalog number
    catno = ""
    if bi.get("labels"):
        catnos = [l.get("catno", "") for l in bi.get("labels", []) if l.get("catno")]
        catno = ", ".join(sorted(set(catnos)))
    
    # Format date
    date_added = item.get("date_added", "")
    if date_added and len(date_added) >= 10:
        date_added = date_added[:10]  # Just the date part
    
    row = (
        date_added,
        artists,
        bi.get("title", ""),
        labels,
        catno,
        formats,
        bi.get("year", ""),
        folder_name,
        item.get("rating", "") or "",
        item.get("id", ""),
        bi.get("id", "")
    )
    
    app.collection_tree.insert("", "end", values=row)

# Update page label
page = app._collection_state.get("page", 1)
pages = app._collection_state.get("pages", 1)
app.collection_page_label.config(text=f"Page {page} / {pages}")
    
    def _collection_open_release(self, event=None):
"""Open selected release in Discogs"""
selection = app.collection_tree.selection()
if not selection:
    return

values = app.collection_tree.item(selection[0], "values")
try:
    release_id = values[-1]  # Last column is release ID
    if release_id:
        import webbrowser
        webbrowser.open(f"https://www.discogs.com/release/{release_id}")
except Exception as e:
    logger.error(f"Failed to open release: {e}")

    # ========================================================================
    # START: ENHANCED CONTEXT MENU FOR COLLECTION TAB
    # ========================================================================

    def _collection_context_menu(self, event):
"""Show context menu for collection with enhanced features."""
from tkinter import Menu

item_id = app.collection_tree.identify_row(event.y)
if not item_id:
    return

app.collection_tree.selection_set(item_id)
selection = app.collection_tree.selection()
if not selection:
    return

values = app.collection_tree.item(selection[0], "values")
has_release_id = False
try:
    if values and int(values[-1]) > 0:
        has_release_id = True
except (ValueError, IndexError):
    pass

menu = Menu(app.collection_tree, tearoff=0)
menu.add_command(label="Add to Inventory", command=app._collection_add_to_inventory)
menu.add_separator()
menu.add_command(label="Open on Discogs", command=app._collection_open_release, 
                 state="normal" if has_release_id else "disabled")
menu.add_command(label="View Price History", command=app._collection_view_price_history,
                 state="normal" if has_release_id else "disabled")
menu.add_command(label="View All Variants", command=app._collection_view_all_variants,
                 state="normal" if has_release_id else "disabled")
menu.add_separator()
menu.add_command(label="Quick List on Discogs", command=app._collection_quick_list_on_discogs,
                 state="normal" if has_release_id else "disabled")
menu.add_command(label="Search Sold Listings (eBay)", command=app._collection_search_sold_listings)
menu.add_separator()
menu.add_command(label="Update Collection Notes", command=app._collection_update_notes)

try:
    menu.tk_popup(event.x_root, event.y_root)
finally:
    menu.grab_release()

    def _collection_view_price_history(self):
"""Context menu action to view price history for a collection item."""
selection = app.collection_tree.selection()
if not selection: return
values = app.collection_tree.item(selection[0], "values")
try:
    release_id = int(values[-1])
    app._view_price_history(release_id)
except (ValueError, IndexError):
    messagebox.showerror("Error", "Could not get a valid Release ID.")

    def _collection_view_all_variants(self):
"""Context menu action to view all variants for a collection item."""
selection = app.collection_tree.selection()
if not selection: return
values = app.collection_tree.item(selection[0], "values")
try:
    release_id = int(values[-1])
    app._view_all_variants(release_id)
except (ValueError, IndexError):
    messagebox.showerror("Error", "Could not get a valid Release ID.")

    def _collection_quick_list_on_discogs(self):
"""Context menu action for quick listing a collection item."""
selection = app.collection_tree.selection()
if not selection: return
values = app.collection_tree.item(selection[0], "values")
try:
    release_id = int(values[-1])
    app._quick_list_on_discogs(release_id)
except (ValueError, IndexError):
    messagebox.showerror("Error", "Could not get a valid Release ID.")

    def _collection_search_sold_listings(self):
"""Context menu action to search sold listings for a collection item."""
selection = app.collection_tree.selection()
if not selection: return
values = app.collection_tree.item(selection[0], "values")
try:
    artist, title = values[1], values[2]
    app._search_sold_listings_inventory(artist, title)
except IndexError:
    messagebox.showerror("Error", "Could not get item details from selection.")

    def _collection_update_notes(self):
"""Context menu action to update collection notes (with API limitation notice)."""
selection = app.collection_tree.selection()
if not selection: return
values = app.collection_tree.item(selection[0], "values")
try:
    instance_id = int(values[-2])
    release_id = int(values[-1])
    # The API *does* allow editing notes for a collection item instance.
    # We need the instance_id, not the release_id.
    
    # Fetch current notes first
    if not app.discogs_api.is_connected():
        messagebox.showwarning("Not Connected", "Please connect to Discogs first.")
        return

    def fetch_and_edit_worker():
        try:
            user = app.discogs_api.client.identity()
            item = user.collection_folders[0].releases.get(instance_id) # Assumes in first folder, needs improvement
            
            # This is inefficient, we should find the right folder first.
            # For now, let's just prompt for notes.
            current_notes = "" # Can't easily get current notes without iterating all folders.
            
            new_notes = simpledialog.askstring("Edit Collection Notes", "Enter your personal notes for this item:", initialvalue=current_notes, parent=app.root)
            
            if new_notes is not None:
                # This part of the API is tricky. The `discogs-client` library doesn't expose this well.
                # We would need to make a POST request to /users/{username}/collection/folders/{folder_id}/releases/{release_id}/instances/{instance_id}
                # with a `notes` field. This is too complex to add right now.
                app.safe_after(0, app._update_collection_notes)

        except Exception as e:
            logger.error(f"Failed to get collection item for notes: {e}")
            app.safe_after(0, app._update_collection_notes)

    #threading.Thread(target=fetch_and_edit_worker).start()
    app._update_collection_notes() # Call the info dialog directly for now.

except (ValueError, IndexError):
    messagebox.showerror("Error", "Could not get a valid Instance ID.")

    def _view_price_history(self, release_id: int):
"""Opens the Discogs marketplace price history page."""
if release_id:
    url = f"https://www.discogs.com/sell/history/{release_id}"
    webbrowser.open_new_tab(url)
    logger.info(f"Opened price history for release {release_id}")

    def _view_all_variants(self, release_id: int):
"""Finds the master release and opens the page to show all variants."""
if not release_id: return

def worker():
    try:
        release_data = app.discogs_api.get_release(release_id)
        if release_data and "master_id" in release_data:
            master_id = release_data["master_id"]
            if master_id:
                url = f"https://www.discogs.com/master/{master_id}"
                app.safe_after(0, lambda: webbrowser.open_new_tab(url))
                logger.info(f"Opened master release {master_id} for release {release_id}")
            else:
                # If master_id is 0 or null, it's a unique release
                app.safe_after(0, lambda: messagebox.showinfo("No Variants", "This release is not part of a master release and has no other known variants."))
        else:
            app.safe_after(0, lambda: messagebox.showwarning("Not Found", "Could not find a master release for this item."))
    except Exception as e:
        logger.error(f"Failed to get variants for release {release_id}: {e}")
        app.safe_after(0, lambda: messagebox.showerror("API Error", f"Failed to fetch release data: {e}"))

threading.Thread(target=worker, daemon=True).start()

    def _quick_list_on_discogs(self, release_id: int):
"""Opens a streamlined dialog to quickly list an item on Discogs."""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first.")
    return

dialog = QuickListDialog(app.root, "Quick List on Discogs")
if dialog.result:
    listing_data = {
        'release_id': release_id,
        'price': dialog.result["price"],
        'status': 'For Sale', # List directly as For Sale
        'condition': DISCOGS_GRADE_MAP.get(dialog.result["media_condition"], dialog.result["media_condition"]),
        'sleeve_condition': DISCOGS_GRADE_MAP.get(dialog.result["sleeve_condition"], dialog.result["sleeve_condition"]),
        'comments': dialog.result["comments"]
    }

    def list_worker():
        try:
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                msg = f"Successfully listed item on Discogs (Listing ID: {listing_id})"
                app.safe_after(0, lambda: messagebox.showinfo("Success", msg))
            # Error is handled by the API wrapper now
        except Exception as e:
            app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
        finally:
            app.safe_after(0, lambda: app.root.config(cursor=""))

    app.root.config(cursor="watch")
    app.root.update()
    threading.Thread(target=list_worker, daemon=True).start()

    def _search_sold_listings_inventory(self, artist: str, title: str):
"""Opens eBay completed listings search for an item from inventory."""
if not artist and not title:
    messagebox.showwarning("Missing Info", "Artist and/or Title are required to search.")
    return
query = f"{artist} {title}".strip()
url = f"https://www.ebay.co.uk/sch/i.html?_from=R40&_nkw={quote_plus(query)}&_sacat=176985&LH_Complete=1&LH_Sold=1"
webbrowser.open_new_tab(url)
logger.info(f"Opened eBay sold listings search for: {query}")

    def _update_collection_notes(self):
"""Dialog for editing personal notes (with API limitation notice)."""
messagebox.showinfo(
    "Feature Not Available",
    "The official Discogs API does not currently support editing the notes of a collection item.\n\n"
    "This feature will be implemented if the API is updated to allow it."
)

    # ========================================================================
    # END: ENHANCED CONTEXT MENU FOR COLLECTION TAB
    # ========================================================================
    
    def _extract_barcode_and_cat_no(self, release_data: dict) -> Tuple[str, str]:
"""
Extracts and robustly separates barcodes from catalog numbers from Discogs release data.
"""
if not release_data:
    return "", ""

explicit_barcodes = {
    identifier.get('value', '').strip()
    for identifier in release_data.get('identifiers', [])
    if identifier.get('type', '').lower() == 'barcode' and identifier.get('value')
}

barcode_pattern = re.compile(r'^\s*[\d\s]{10,13}\s*$')

potential_cat_nos = {
    label.get('catno', '').strip()
    for label in release_data.get('labels', [])
    if label.get('catno') and label.get('catno', '').strip().lower() != 'none'
}

heuristic_barcodes = {pcn for pcn in potential_cat_nos if barcode_pattern.match(pcn)}

true_cat_nos = potential_cat_nos - explicit_barcodes - heuristic_barcodes

all_barcodes = explicit_barcodes.union(heuristic_barcodes)

main_barcode = sorted(list(explicit_barcodes))[0] if explicit_barcodes else \
               sorted(list(all_barcodes))[0] if all_barcodes else ""

if not true_cat_nos and potential_cat_nos:
     final_cat_nos = potential_cat_nos - all_barcodes
else:
     final_cat_nos = true_cat_nos

final_cat_no_str = ", ".join(sorted(list(final_cat_nos)))

return main_barcode.replace(" ", ""), final_cat_no_str

    def _extract_matrix_info(self, release_data: dict) -> str:
"""
[NEW & ROBUST] Extracts matrix/runout information from a Discogs release.
It prioritizes the structured `identifiers` field and falls back to parsing
the unstructured `notes` field if necessary.
"""
if not release_data:
    return ""

# --- Stage 1: Prioritize the structured `identifiers` field ---
structured_matrix = []
for identifier in release_data.get('identifiers', []):
    if identifier.get('type') == 'Matrix / Runout':
        desc = identifier.get('description', '').strip()
        value = identifier.get('value', '').strip()
        if value:
            # Format nicely: "Side A, variant 1: XXX-123"
            line = f"{desc}: {value}" if desc else value
            structured_matrix.append(line)

if structured_matrix:
    logger.info(f"Found {len(structured_matrix)} structured matrix entries.")
    return "\n".join(structured_matrix)

# --- Stage 2: Fallback to parsing the unstructured `notes` field ---
logger.info("No structured matrix data found, falling back to parsing 'notes' field.")
notes_text = release_data.get('notes', '')
if not notes_text:
    return ""

lines = notes_text.splitlines()
matrix_lines = []
in_matrix_block = False

# Keywords that indicate a line is likely matrix/runout info
matrix_keywords = ['matrix', 'runout', 'etched', 'stamped', 'side a', 'side b', 'side c', 'side d']

for line in lines:
    line_lower = line.lower().strip()
    if not line_lower:
        in_matrix_block = False  # Blank line ends a block
        continue

    # Check for the explicit "Matrix / Runout:" header
    if line_lower.startswith('matrix / runout'):
        in_matrix_block = True
        # Add the line itself, but strip the label
        matrix_part = line.split(':', 1)[-1].strip()
        if matrix_part:
            matrix_lines.append(matrix_part)
        continue

    if in_matrix_block:
        matrix_lines.append(line.strip())
    else:
        # Check if a line contains any of our keywords, but not as part of a larger word
        if any(re.search(r'\b' + re.escape(kw) + r'\b', line_lower) for kw in matrix_keywords):
            matrix_lines.append(line.strip())

return "\n".join(matrix_lines).strip()

    def _collection_add_to_inventory(self):
"""Enhanced: Add selected collection item directly to inventory database."""
selection = app.collection_tree.selection()
if not selection:
    return

values = app.collection_tree.item(selection[0], "values")

try:
    release_id = int(values[-1])
except (ValueError, IndexError):
    messagebox.showerror("Error", "Could not get a valid Release ID from the selected item.")
    return

# 1. Check for duplicates before proceeding
try:
    # Attempt to deduplicate by both release ID and cat_no if available
    cat_no = None
    try:
        # Collection tree columns are: added, artist, title, labels, catno, formats, year, folder, rating, instance, release
        # The catno resides at index 4
        cat_no = values[4] if len(values) > 4 else None
    except Exception:
        cat_no = None
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        if cat_no:
            cursor.execute("SELECT sku, status FROM inventory WHERE discogs_release_id = ? AND cat_no = ?", (release_id, cat_no))
        else:
            cursor.execute("SELECT sku, status FROM inventory WHERE discogs_release_id = ?", (release_id,))
        existing = cursor.fetchone()
        if existing:
            msg = (f"This release (ID: {release_id}) already exists in your inventory.\n\n"
                   f"SKU: {existing['sku']}\nStatus: {existing['status']}\n\n"
                   "Do you want to add it again?")
            if not messagebox.askyesno("Duplicate Found", msg):
                return
except Exception as e:
    logger.error(f"Database error checking for duplicates: {e}")
    messagebox.showerror("Database Error", f"Could not check for duplicates: {e}")
    return

# 2. Fetch full details from Discogs API in a background thread
app.root.config(cursor="watch")
app.root.update()

def api_worker():
    release_data = app.discogs_api.get_release(release_id)
    app.safe_after(0, lambda: app._process_inventory_addition(release_data))

threading.Thread(target=api_worker, daemon=True).start()

    def _process_inventory_addition(self, release_data):
"""
Callback to handle processing after API call, ensuring matrix/runout is saved
AND included in the lister_payload for consistent loading.
"""
app.root.config(cursor="")
if not release_data:
    messagebox.showerror("API Error", f"Failed to fetch complete data for Release ID: {release_data.get('id')}")
    return

# 3. Prompt user for condition and price
dialog = ConditionGradingDialog(app.root)
if not dialog.result:
    return  # User cancelled

# 4. Prepare data for database insertion
now = datetime.datetime.now(datetime.timezone.utc).isoformat()
sku = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")

artist_names = [re.sub(r'\s*\(\d+\)$', '', a['name']).strip() for a in release_data.get('artists', [])]
artist = ", ".join(artist_names)
title = release_data.get('title', '')

barcode, cat_no = app._extract_barcode_and_cat_no(release_data)

year = release_data.get('year', '')
formats_list = [f.get('name', '') for f in release_data.get('formats', [])]
main_format = formats_list[0] if formats_list else 'Vinyl'

# [FIXED] Use the new robust extraction method for matrix info
matrix_runout_info = app._extract_matrix_info(release_data)

# Create a complete payload for the `lister_payload` column
# that INCLUDES the matrix_runout data.
lister_payload_data = {
    "artist": artist, "title": title, "cat_no": cat_no, "year": str(year),
    "format": main_format, "media_condition": dialog.result["media_condition"],
    "sleeve_condition": dialog.result["sleeve_condition"], "price": dialog.result["price"],
    "condition_notes": dialog.result["notes"], "barcode": barcode,
    "matrix_runout": matrix_runout_info,
    "discogs_release_id": release_data['id'],
    "description": "", # Start with an empty description
    "images": [] # Start with empty images
}

# 5. Save to database
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        sql = """
            INSERT INTO inventory (
                sku, artist, title, cat_no, year, format, media_condition,
                sleeve_condition, price, status, discogs_release_id, notes,
                barcode, matrix_runout, date_added, last_modified, inv_updated_at, lister_payload
            ) VALUES (
                :sku, :artist, :title, :cat_no, :year, :format, :media_condition,
                :sleeve_condition, :price, :status, :discogs_release_id, :notes,
                :barcode, :matrix_runout, :date_added, :last_modified, :inv_updated_at, :lister_payload
            )
        """

        db_params = {
            "sku": sku, "artist": artist, "title": title, "cat_no": cat_no,
            "year": str(year), "format": main_format,
            "media_condition": dialog.result["media_condition"],
            "sleeve_condition": dialog.result["sleeve_condition"],
            "price": dialog.result["price"], "status": "For Sale",
            "discogs_release_id": release_data['id'],
            "notes": dialog.result["notes"], "barcode": barcode,
            "matrix_runout": matrix_runout_info,
            "date_added": now, "last_modified": now,
            "inv_updated_at": now,
            "lister_payload": json.dumps(lister_payload_data)
        }

        cursor.execute(sql, db_params)
    
    # 6. Show confirmation and refresh
    messagebox.showinfo("Success", f"Added to inventory!\n\nSKU: {sku}\n{artist} - {title}")
    app.populate_inventory_view()
    app.notebook.select(app.inventory_tab)

except Exception as e:
    logger.error(f"Failed to save new inventory item: {e}", exc_info=True)
    messagebox.showerror("Database Error", f"Failed to save item to inventory: {e}")

    def _setup_lister_tab(self):
"""
Setup the lister tab, now with a multi-line Text widget for Matrix/Runout.
"""
entry_frame = tk.Frame(app.lister_tab)
entry_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nw")

results_frame = tk.Frame(app.lister_tab)
results_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")

app.lister_tab.grid_columnconfigure(1, weight=1)
app.lister_tab.grid_rowconfigure(0, weight=1)

tk.Label(entry_frame, text="SKU", font=("Helvetica", 14, "bold")).grid(row=0, column=0, sticky="w", padx=5, pady=2)
sku_entry = tk.Entry(entry_frame, textvariable=app.sku_display_var, state="readonly", width=50, readonlybackground="white", fg="black")
sku_entry.grid(row=0, column=1, columnspan=3, sticky="we", padx=5, pady=2)

field_labels = [
    "Artist", "Title", "Cat No", "Barcode", "Format", "Year", "Genre",
    "Media Condition", "Sleeve Condition", "Condition Notes",
    "Matrix / Runout", "Condition Tags",
    "New/Used", "Shipping Option", "Listing Title"
]

field_options = {
    "Format": ["", "LP", "12\"", "2x12\"", "7\"", "10\"", "Box Set", "Vinyl", "Other"],
    "Media Condition": [""] + list(GRADE_ABBREVIATIONS.keys()),
    "Sleeve Condition": [""] + list(GRADE_ABBREVIATIONS.keys()),
    "New/Used": ["", "Used", "New"],
    "Shipping Option": ["", "Standard UK Paid", "Free UK"],
    "Genre": ["", "Pop", "Rock", "Electronic", "Hip Hop", "Jazz", "Classical", "Folk", "Blues", "Country", "Reggae", "Other"]
}

app.entries = {}

for i, label_text in enumerate(field_labels):
    row = i + 1
    key = label_text.lower().replace(" / ", "_").replace("/", "_").replace(" ", "_")
    
    tk.Label(entry_frame, text=label_text).grid(row=row, column=0, sticky="nw", padx=5, pady=2)
    
    widget = None
    if key in ["condition_notes", "matrix_runout"]:
        widget_frame = tk.Frame(entry_frame)
        widget_frame.grid(row=row, column=1, columnspan=3, sticky="we", padx=5, pady=2)
        height = 3 if key == "matrix_runout" else 4
        widget = tk.Text(widget_frame, width=47, height=height, wrap="word")
        scrollbar = tk.Scrollbar(widget_frame, orient="vertical", command=widget.yview)
        widget.config(yscrollcommand=scrollbar.set)
        widget.pack(side="left", fill="x", expand=True)
        scrollbar.pack(side="right", fill="y")
    elif label_text in field_options:
        widget = ttk.Combobox(entry_frame, values=field_options[label_text], width=47)
        widget.grid(row=row, column=1, columnspan=3, sticky="we", padx=5, pady=2)
    else:
        widget = tk.Entry(entry_frame, width=50)
        widget.grid(row=row, column=1, columnspan=3, sticky="we", padx=5, pady=2)
    
    app.entries[key] = widget

    if key == "condition_tags":
        tk.Label(entry_frame, text="(comma-separated)", font=("Helvetica", 10, "italic")).grid(row=row, column=4, sticky="w", padx=2)

current_row = len(field_labels) + 1
btn_row1 = tk.Frame(entry_frame)
btn_row1.grid(row=current_row, column=0, columnspan=4, sticky="w", padx=5, pady=(4, 0))
tk.Button(btn_row1, text="Search Discogs", command=app.search_discogs).pack(side="left", padx=4)
tk.Button(btn_row1, text="Search by Cat No", command=app.search_by_catno).pack(side="left", padx=4)

current_row += 1
btn_row2 = tk.Frame(entry_frame)
btn_row2.grid(row=current_row, column=0, columnspan=4, sticky="w", padx=5, pady=(2, 5))

# Core functionality buttons
tk.Button(btn_row2, text="Generate Title", command=app.generate_listing_title).pack(side="left", padx=4)
tk.Button(btn_row2, text="Build Description", command=app.build_description).pack(side="left", padx=4)
app.save_button = tk.Button(btn_row2, text="Save to Inventory", command=app.save_to_inventory)
app.save_button.pack(side="left", padx=4)
tk.Button(btn_row2, text="Clear Form", command=app.clear_form).pack(side="left", padx=4)

# Publishing buttons row
current_row += 1
publish_row = tk.Frame(entry_frame)
publish_row.grid(row=current_row, column=0, columnspan=4, sticky="w", padx=5, pady=(2, 5))

# eBay buttons
tk.Label(publish_row, text="eBay:", font=("Helvetica", 10, "bold")).pack(side="left", padx=(0, 5))
tk.Button(publish_row, text="Save Draft Locally", command=app.action_ebay_save_unpublished, bg="#e6f3ff").pack(side="left", padx=2)
app.list_on_ebay_button = tk.Button(publish_row, text="Publish Live", command=app.action_ebay_publish_live, bg="#ffe6e6", state="disabled")
app.list_on_ebay_button.pack(side="left", padx=2)

# Separator
ttk.Separator(publish_row, orient="vertical").pack(side="left", fill="y", padx=10)

# Discogs buttons  
tk.Label(publish_row, text="Discogs:", font=("Helvetica", 10, "bold")).pack(side="left", padx=(0, 5))
app.discogs_draft_button = tk.Button(publish_row, text="Save Draft", command=app.action_discogs_save_unpublished, bg="#e6f3ff", state="disabled")
app.discogs_draft_button.pack(side="left", padx=2)
app.discogs_live_button = tk.Button(publish_row, text="Publish Live", command=app.action_discogs_publish_live, bg="#ffe6e6", state="disabled")
app.discogs_live_button.pack(side="left", padx=2)

current_row += 1
app.release_status_label = tk.Label(entry_frame, text="⚠ No release selected", fg="red", font=("Helvetica", 12, "bold"), wraplength=400, justify="left")
app.release_status_label.grid(row=current_row, column=0, columnspan=4, sticky="w", padx=5, pady=(5, 5))

current_row += 1
image_management_frame = ttk.LabelFrame(entry_frame, text="Image Management", padding=(10, 5))
image_management_frame.grid(row=current_row, column=0, columnspan=4, sticky="ew", padx=5, pady=5)
image_buttons_frame = tk.Frame(image_management_frame)
image_buttons_frame.pack(fill="x", pady=(0, 5))

# [NEW] Add the "Select Images..." button
tk.Button(image_buttons_frame, text="Select Images...", command=app.select_images_manually).pack(side="left", padx=4)
tk.Button(image_buttons_frame, text="Generate QR", command=app.generate_image_qr_code).pack(side="left", padx=4)
app.import_images_button = tk.Button(image_management_frame, text="Import Staged", command=app.import_staged_images)
app.import_images_button.pack(side="left", padx=4)

image_ui_container = tk.Frame(image_management_frame)
image_ui_container.pack(fill="x", expand=True)
image_list_frame = tk.Frame(image_ui_container)
image_list_frame.pack(side="left", fill="both", expand=True, padx=(0, 5))
listbox_container = tk.Frame(image_list_frame)
listbox_container.pack(fill="x", expand=True)
app.image_listbox = tk.Listbox(listbox_container, height=6, selectmode=tk.SINGLE)
app.image_listbox.pack(side="left", fill="x", expand=True)
app.image_listbox.bind("<<ListboxSelect>>", app._update_image_preview)
image_scrollbar = tk.Scrollbar(listbox_container, orient="vertical", command=app.image_listbox.yview)
image_scrollbar.pack(side="right", fill="y")
app.image_listbox.config(yscrollcommand=image_scrollbar.set)
reorder_buttons_frame = tk.Frame(image_list_frame)
reorder_buttons_frame.pack(fill="x", pady=(5, 0))
tk.Button(reorder_buttons_frame, text="▲ Up", command=app._move_image_up).pack(side="left", fill="x", expand=True)
tk.Button(reorder_buttons_frame, text="▼ Down", command=app._move_image_down).pack(side="left", fill="x", expand=True)
tk.Button(reorder_buttons_frame, text="❌ Del", command=app._delete_selected_image).pack(side="left", fill="x", expand=True)
app.image_preview_label = ttk.Label(image_ui_container, text="Select an image to preview", relief="groove", anchor="center", justify="center")
app.image_preview_label.pack(side="left", fill="both", expand=True, padx=(5, 0))
app.image_preview_label.config(width=30)

current_row += 1
desc_frame = tk.Frame(entry_frame)
desc_frame.grid(row=current_row, column=0, columnspan=4, sticky="we", padx=5, pady=5)
tk.Label(desc_frame, text="Full Description").pack(anchor="w")
app.full_desc = tk.Text(desc_frame, width=50, height=6)
desc_scroll = tk.Scrollbar(desc_frame, command=app.full_desc.yview)
app.full_desc.config(yscrollcommand=desc_scroll.set)
desc_scroll.pack(side="right", fill="y")
app.full_desc.pack(side="left", fill="x", expand=True)

current_row += 1
tk.Label(entry_frame, text="Price (£)").grid(row=current_row, column=0, sticky="w", padx=5, pady=5)
app.price_entry = tk.Entry(entry_frame, width=50)
app.price_entry.grid(row=current_row, column=1, columnspan=3, sticky="we", padx=5, pady=5)

app._setup_discogs_results(results_frame)
    
    def _update_image_listbox(self):
"""Clears and repopulates the image listbox from app.image_paths."""
app.image_listbox.delete(0, tk.END)
for path in app.image_paths:
    app.image_listbox.insert(tk.END, os.path.basename(path))

    def _update_image_preview(self, event=None):
"""Updates the image preview label when a listbox item is selected."""
try:
    selected_indices = app.image_listbox.curselection()
    if not selected_indices:
        app._clear_image_preview()
        return
    
    idx = selected_indices[0]
    image_path = app.image_paths[idx]

    if not os.path.exists(image_path):
        app.image_preview_label.config(image='', text=f"Image not found:\n{os.path.basename(image_path)}")
        return

    with Image.open(image_path) as img:
        # Create a thumbnail for preview
        preview_size = (app.image_preview_label.winfo_width(), app.image_preview_label.winfo_height())
        # Fallback size if widget not rendered yet
        if preview_size[0] < 20 or preview_size[1] < 20: 
            preview_size = (200, 200)
        
        img.thumbnail(preview_size, Image.Resampling.LANCZOS)
        
        photo_image = ImageTk.PhotoImage(img)
        
        # Update the label
        app.image_preview_label.config(image=photo_image, text="")
        # IMPORTANT: Keep a reference to the image to prevent garbage collection
        app.image_preview_label.image = photo_image

except Exception as e:
    logger.error(f"Error updating image preview: {e}")
    app.image_preview_label.config(image='', text="Error loading preview")

    def _clear_image_preview(self):
"""Clears the image preview area."""
app.image_preview_label.config(image='', text="Select an image to preview")
app.image_preview_label.image = None

    def _move_image_up(self):
"""Moves the selected image up in the list."""
try:
    selected_indices = app.image_listbox.curselection()
    if not selected_indices: return
    
    idx = selected_indices[0]
    if idx > 0:
        app.image_paths.insert(idx - 1, app.image_paths.pop(idx))
        app._update_image_listbox()
        app.image_listbox.selection_set(idx - 1)
        app._update_image_preview() # Update preview after move
except Exception as e:
    logger.error(f"Error moving image up: {e}")

    def _move_image_down(self):
"""Moves the selected image down in the list."""
try:
    selected_indices = app.image_listbox.curselection()
    if not selected_indices: return

    idx = selected_indices[0]
    if idx < len(app.image_paths) - 1:
        app.image_paths.insert(idx + 1, app.image_paths.pop(idx))
        app._update_image_listbox()
        app.image_listbox.selection_set(idx + 1)
        app._update_image_preview() # Update preview after move
except Exception as e:
    logger.error(f"Error moving image down: {e}")

    def _delete_selected_image(self):
"""Deletes the selected image from the list."""
try:
    selected_indices = app.image_listbox.curselection()
    if not selected_indices: return

    idx = selected_indices[0]
    # Optionally, ask for confirmation before deleting the actual file
    # if messagebox.askyesno("Delete Image", f"Permanently delete {os.path.basename(app.image_paths[idx])}?"):
    #     os.remove(app.image_paths[idx])
    app.image_paths.pop(idx)
    app._update_image_listbox()
    
    if len(app.image_paths) > 0:
        new_selection = min(idx, len(app.image_paths) - 1)
        app.image_listbox.selection_set(new_selection)
    app._update_image_preview()
except Exception as e:
    logger.error(f"Error deleting image: {e}")
    
    def _setup_discogs_results(self, parent):
"""Setup Discogs search results view"""
# Filter controls
controls_frame = tk.Frame(parent)
controls_frame.pack(fill="x", pady=(0, 5))

tk.Label(controls_frame, text="Filter:").pack(side="left", padx=(0, 5))
app.discogs_search_filter_var = tk.StringVar()
filter_entry = tk.Entry(controls_frame, textvariable=app.discogs_search_filter_var, width=30)
filter_entry.pack(side="left", padx=5)
filter_entry.bind("<KeyRelease>", app.refresh_discogs_view)

# Results tree
tree_container = tk.Frame(parent)
tree_container.pack(fill="both", expand=True)

cols = ("ID", "Artist", "Title", "Cat#", "Year", "Country", "Format")
app.discogs_tree = ttk.Treeview(tree_container, columns=cols, show="headings")

for col in cols:
    app.discogs_tree.heading(col, text=col, command=lambda c=col: app.sort_discogs_results(c))

# Column widths
app.discogs_tree.column("ID", width=0, stretch=tk.NO)
app.discogs_tree.column("Artist", width=200)
app.discogs_tree.column("Title", width=280)
app.discogs_tree.column("Cat#", width=100)
app.discogs_tree.column("Year", width=60, anchor="center")
app.discogs_tree.column("Country", width=100, anchor="center")
app.discogs_tree.column("Format", width=200)

# Scrollbar
tree_scroll = tk.Scrollbar(tree_container, orient="vertical", command=app.discogs_tree.yview)
app.discogs_tree.configure(yscrollcommand=tree_scroll.set)

# Bindings
app.discogs_tree.bind("<Double-1>", app.apply_selected_discogs)
app.discogs_tree.bind("<Button-3>", app.show_discogs_context_menu)
app.discogs_tree.bind("<Button-2>", app.show_discogs_context_menu)

# Pack
app.discogs_tree.pack(side="left", fill="both", expand=True)
tree_scroll.pack(side="right", fill="y")

# Context menu
app.discogs_context_menu = tk.Menu(app.root, tearoff=0)
app.discogs_context_menu.add_command(label="Apply Selected Result", command=app.apply_selected_discogs)
app.discogs_context_menu.add_command(label="View on Discogs", command=app.open_discogs_release_page)
app.discogs_context_menu.add_separator()
app.discogs_context_menu.add_command(label="Get Price Suggestion", command=app.get_price_suggestion)
app.discogs_context_menu.add_command(label="View Discogs Sales History", command=lambda: app.open_sold_listings_from_selection("Discogs"))
app.discogs_context_menu.add_command(label="View eBay Sales History", command=lambda: app.open_sold_listings_from_selection("eBay"))
    
    def _setup_inventory_tab(self):
"""Setup inventory tab with all features"""
inv_frame = tk.Frame(app.inventory_tab)
inv_frame.pack(fill="both", expand=True, padx=10, pady=10)

# Controls
controls_frame = tk.Frame(inv_frame)
controls_frame.pack(fill="x", pady=(0, 5))

tk.Label(controls_frame, text="Search:").pack(side="left", padx=(0, 5))
app.inventory_search_var = tk.StringVar()
search_entry = tk.Entry(controls_frame, textvariable=app.inventory_search_var, width=30)
search_entry.pack(side="left", padx=5)
search_entry.bind("<KeyRelease>", lambda e: app.populate_inventory_view(app.inventory_search_var.get()))

tk.Button(controls_frame, text="Load for Editing", command=app.load_item_for_editing).pack(side="left", padx=5)
tk.Button(controls_frame, text="Edit in Lister", command=app.edit_in_lister).pack(side="left", padx=5)
tk.Button(controls_frame, text="Delete Selected", command=app.delete_inventory_item).pack(side="left", padx=5)
tk.Button(controls_frame, text="Select All", command=app.select_all_inventory).pack(side="left", padx=(10, 0))
tk.Button(controls_frame, text="Deselect All", command=app.deselect_all_inventory).pack(side="left", padx=5)

# Status buttons
controls_frame2 = tk.Frame(inv_frame)
controls_frame2.pack(fill="x", pady=(0, 5))

tk.Label(controls_frame2, text="Update Status:").pack(side="left")
for status in ["For Sale", "Sold", "Not For Sale"]:
    tk.Button(
        controls_frame2,
        text=status,
        command=lambda s=status: app.update_inventory_status(s)
    ).pack(side="left", padx=5)

# Publishing section
tk.Label(controls_frame2, text="eBay:", font=("Helvetica", 10, "bold")).pack(side="left", padx=(20, 5))




tk.Button(controls_frame2, text="Import from eBay", command=app.action_import_from_ebay).pack(side="left", padx=4)
tk.Button(controls_frame2, text="Open on eBay", command=app.action_open_on_ebay_selected).pack(side="left", padx=4)
tk.Button(controls_frame2, text="Sync from eBay", command=app.action_ebay_sync_selected).pack(side="left", padx=4)
tk.Button(controls_frame2, text="Save Draft Locally", command=app.action_ebay_save_unpublished, bg="#e6f3ff", state="disabled").pack(side="left", padx=2)
app.publish_ebay_btn = tk.Button(controls_frame2, text="Publish Live", command=app.action_ebay_publish_live, bg="#ffe6e6", state="disabled")
app.publish_ebay_btn.pack(side="left", padx=2)

tk.Label(controls_frame2, text="Discogs:", font=("Helvetica", 10, "bold")).pack(side="left", padx=(10, 5))

tk.Button(controls_frame2, text="Sync from Discogs", command=app.manual_sync_now).pack(side="left", padx=4)
app.publish_discogs_btn = tk.Button(controls_frame2, text="Save Draft", command=app.action_discogs_save_unpublished, bg="#e6f3ff", state="disabled")
app.publish_discogs_btn.pack(side="left", padx=2)
app.publish_discogs_live_btn = tk.Button(controls_frame2, text="Publish Live", command=app.action_discogs_publish_live, bg="#ffe6e6", state="disabled")
app.publish_discogs_live_btn.pack(side="left", padx=2)

# Utility buttons
app.open_in_browser_btn = tk.Button(controls_frame2, text="Open in Browser", command=app.open_listing_in_browser, state="disabled")
app.open_in_browser_btn.pack(side="left", padx=(20, 5))

app.import_button = tk.Button(controls_frame2, text="Import Discogs Inventory", state="disabled", command=app.start_discogs_import)
app.import_button.pack(side="left", padx=5)

# Inventory tree
# Include eBay draft/live and Discogs IDs for traceability
cols = ("SKU", "Artist", "Title", "Price", "Status", "eBay Draft ID", "eBay Listing ID", "Discogs ID", "Date Added")
app.inventory_tree = ttk.Treeview(inv_frame, columns=cols, show="headings", selectmode="extended")

for col in cols:
    app.inventory_tree.heading(col, text=col, command=lambda c=col: app.sort_inventory(c))

# Column widths (adjusted for additional ID columns)
app.inventory_tree.column("SKU", width=140)
app.inventory_tree.column("Artist", width=180)
app.inventory_tree.column("Title", width=260)
app.inventory_tree.column("Price", width=80, anchor="e")
app.inventory_tree.column("Status", width=110)
app.inventory_tree.column("eBay Draft ID", width=140)
app.inventory_tree.column("eBay Listing ID", width=140)
app.inventory_tree.column("Discogs ID", width=120)
app.inventory_tree.column("Date Added", width=150)

# Bindings
app.inventory_tree.bind("<Double-1>", app.load_item_for_editing)
app.inventory_tree.bind("<Button-3>", app.show_inventory_context_menu)
app.inventory_tree.bind("<Button-2>", app.show_inventory_context_menu)
app.inventory_tree.bind("<Control-Button-1>", app.show_inventory_context_menu)
app.inventory_tree.bind("<Return>", app.load_item_for_editing)
app.inventory_tree.bind("<<TreeviewSelect>>", app.on_inventory_selection)

# Scrollbar
inv_scroll = tk.Scrollbar(inv_frame, orient="vertical", command=app.inventory_tree.yview)
app.inventory_tree.configure(yscrollcommand=inv_scroll.set)

# Pack
app.inventory_tree.pack(side="left", fill="both", expand=True)
inv_scroll.pack(side="right", fill="y")

# Log area
log_frame = tk.Frame(inv_frame)
log_frame.pack(fill="both", expand=True, pady=(5, 0))

app.publish_log = scrolledtext.ScrolledText(log_frame, height=8, state="disabled", wrap="word")
app.publish_log.pack(fill="both", expand=True)

# Context menu with all options
app.inventory_context_menu = tk.Menu(app.root, tearoff=0)
app.inventory_context_menu.add_command(label="Load for Editing", command=app.load_item_for_editing)
app.inventory_context_menu.add_command(label="Edit in Lister", command=app.edit_in_lister)
app.inventory_context_menu.add_separator()
app.inventory_context_menu.add_command(label="Open Discogs Listing", command=app.open_discogs_listing)
app.inventory_context_menu.add_command(label="Open eBay Listing", command=app.open_ebay_listing)
app.inventory_context_menu.add_command(label="View Discogs Release Page", command=app.open_discogs_release_from_inventory)
app.inventory_context_menu.add_separator()
app.inventory_context_menu.add_command(label="Sync with Discogs", command=app.manual_sync_now)
app.inventory_context_menu.add_separator()
app.inventory_context_menu.add_command(label="Delete", command=app.delete_inventory_item)
    
    def _setup_settings_tab_complete(self):
"""Setup settings tab with ALL features including status mapping and sales"""
settings_frame = tk.Frame(app.settings_tab, padx=10, pady=10)
settings_frame.pack(fill="both", expand=True)

# Settings Notebook
settings_notebook = ttk.Notebook(settings_frame)
settings_notebook.pack(fill="both", expand=True, pady=(10, 0))

# --- Connections & Sync Tab ---
conn_sync_tab = ttk.Frame(settings_notebook)
settings_notebook.add(conn_sync_tab, text="Connections & Sync")

# Discogs connection
discogs_frame = ttk.LabelFrame(conn_sync_tab, text="Discogs Account Connection", padding=(10, 5))
discogs_frame.pack(fill="x", pady=(0, 10), padx=5)

app.discogs_auth_status_var = tk.StringVar(value="Not Connected")
ttk.Label(discogs_frame, textvariable=app.discogs_auth_status_var, font=("Helvetica", 14, "italic")).pack(side="left", padx=5, pady=5)

app.discogs_connect_button = tk.Button(discogs_frame, text="Connect to Discogs Account", command=app.authenticate_discogs)
app.discogs_connect_button.pack(side="left", padx=5, pady=5)

# eBay connection
ebay_frame = ttk.LabelFrame(conn_sync_tab, text="eBay Account Connection", padding=(10, 5))
ebay_frame.pack(fill="x", pady=(0, 10), padx=5)

app.ebay_auth_status_var = tk.StringVar(value="Not Connected")
ttk.Label(ebay_frame, textvariable=app.ebay_auth_status_var, font=("Helvetica", 14, "italic")).pack(side="left", padx=5, pady=5)

tk.Button(ebay_frame, text="Test Connection", command=app.test_ebay_connection).pack(side="left", padx=5, pady=5)
tk.Button(ebay_frame, text="Copy eBay Status", command=lambda: app._copy_ebay_status()).pack(side="left", padx=5, pady=5)

# Auto-sync settings
sync_frame = ttk.LabelFrame(conn_sync_tab, text="Automatic Inventory Sync", padding=(10, 5))
sync_frame.pack(fill="x", pady=(10, 0), padx=5)

sync_controls = tk.Frame(sync_frame)
sync_controls.pack(fill="x", pady=(0, 5))

app.auto_sync_var = tk.BooleanVar(value=app.auto_sync_enabled)
tk.Checkbutton(sync_controls, text="Enable automatic sync", variable=app.auto_sync_var, 
              command=app.toggle_auto_sync).pack(side="left", padx=5)

app.two_way_sync_var = tk.BooleanVar(value=app.two_way_sync_enabled)
tk.Checkbutton(sync_controls, text="Enable two-way sync", variable=app.two_way_sync_var,
              command=app.toggle_two_way_sync).pack(side="left", padx=(20, 5))

# Advanced sync options
advanced_controls = tk.Frame(sync_frame)
advanced_controls.pack(fill="x", pady=(0, 5))

tk.Label(advanced_controls, text="Advanced:", font=("Helvetica", 10, "bold")).pack(side="left", padx=(0, 5))

app.attempt_updates_var = tk.BooleanVar(value=app.attempt_discogs_updates)
tk.Checkbutton(advanced_controls, text="Attempt Discogs updates (experimental)",
              variable=app.attempt_updates_var, command=app.toggle_attempt_updates).pack(side="left", padx=5)

# Sync interval
interval_frame = tk.Frame(sync_frame)
interval_frame.pack(fill="x", pady=(0, 5))

tk.Label(interval_frame, text="Sync every:").pack(side="left", padx=(0, 5))
app.sync_interval_var = tk.StringVar(value=str(app.auto_sync_interval // 60))
tk.Spinbox(interval_frame, from_=1, to=60, width=5, textvariable=app.sync_interval_var,
           command=app.update_sync_interval).pack(side="left", padx=5)
tk.Label(interval_frame, text="minutes").pack(side="left", padx=(0, 10))

tk.Button(interval_frame, text="Sync Now", command=app.manual_sync_now).pack(side="left", padx=5)

# Sync status
status_frame = tk.Frame(sync_frame)
status_frame.pack(fill="x", pady=(5, 0))

app.sync_status_var = tk.StringVar(value="Auto-sync disabled")
ttk.Label(status_frame, textvariable=app.sync_status_var, font=("Helvetica", 10, "italic")).pack(side="left", padx=5)

# Sync log
log_frame = ttk.LabelFrame(sync_frame, text="Sync Activity Log", padding=(5, 5))
log_frame.pack(fill="both", expand=True, pady=(5, 0))

app.sync_log_text = tk.Text(log_frame, height=8, width=80)
log_scroll = tk.Scrollbar(log_frame, orient="vertical", command=app.sync_log_text.yview)
app.sync_log_text.configure(yscrollcommand=log_scroll.set)

app.sync_log_text.pack(side="left", fill="both", expand=True)
log_scroll.pack(side="right", fill="y")

# --- Mappings & Workflow Tab ---
mappings_tab = ttk.Frame(settings_notebook)
settings_notebook.add(mappings_tab, text="Mappings & Workflow")

# Image Workflow Settings
image_frame = ttk.LabelFrame(mappings_tab, text="Image Workflow Settings", padding=(10, 5))
image_frame.pack(fill="x", pady=(10, 10), padx=5)

path_frame = tk.Frame(image_frame)
path_frame.pack(fill="x")

tk.Label(path_frame, text="Image Staging Folder:").pack(side="left", anchor="w")
path_entry = tk.Entry(path_frame, textvariable=app.image_staging_path_var, state="readonly", width=60)
path_entry.pack(side="left", fill="x", expand=True, padx=5)
tk.Button(path_frame, text="Browse...", command=app._select_image_staging_path).pack(side="left")

# Status Mapping Configuration
status_mapping_frame = ttk.LabelFrame(mappings_tab, text="Status Mapping Configuration", padding=(10, 5))
status_mapping_frame.pack(fill="x", pady=(10, 0), padx=5)

tk.Label(status_mapping_frame, text="Configure how Discogs inventory statuses map to your local inventory statuses:", 
         font=("Helvetica", 11)).pack(anchor="w", pady=(0, 10))

# Mapping table
mapping_table_frame = tk.Frame(status_mapping_frame)
mapping_table_frame.pack(fill="x", pady=(0, 10))

tk.Label(mapping_table_frame, text="Discogs Status", font=("Helvetica", 12, "bold")).grid(row=0, column=0, padx=10, pady=5, sticky="w")
tk.Label(mapping_table_frame, text="→", font=("Helvetica", 12, "bold")).grid(row=0, column=1, padx=5, pady=5)
tk.Label(mapping_table_frame, text="Local Status", font=("Helvetica", 12, "bold")).grid(row=0, column=2, padx=10, pady=5, sticky="w")

for i, (discogs_status, default_local_status) in enumerate(DEFAULT_STATUS_MAPPINGS.items(), 1):
    tk.Label(mapping_table_frame, text=discogs_status, font=("Helvetica", 11)).grid(row=i, column=0, padx=10, pady=3, sticky="w")
    tk.Label(mapping_table_frame, text="→", font=("Helvetica", 11)).grid(row=i, column=1, padx=5, pady=3)
    
    var = tk.StringVar(value=app.status_mappings.get(discogs_status, default_local_status))
    app.status_mapping_vars[discogs_status] = var
    
    ttk.Combobox(mapping_table_frame, textvariable=var, values=LOCAL_STATUSES, 
                state="readonly", width=15).grid(row=i, column=2, padx=10, pady=3, sticky="w")

# Mapping buttons
mapping_buttons_frame = tk.Frame(status_mapping_frame)
mapping_buttons_frame.pack(anchor="w", pady=(5, 0))

tk.Button(mapping_buttons_frame, text="Save Mappings", command=app._save_status_mappings).pack(side="left", padx=(0, 10))
tk.Button(mapping_buttons_frame, text="Reset to Defaults", command=app._reset_status_mappings).pack(side="left")

# --- Sales Tab ---
sales_tab = ttk.Frame(settings_notebook)
settings_notebook.add(sales_tab, text="Sales History")

sales_notebook_inner = ttk.Notebook(sales_tab)
sales_notebook_inner.pack(fill="both", expand=True, pady=5)

# Discogs sales tab
discogs_sales_tab = ttk.Frame(sales_notebook_inner)
sales_notebook_inner.add(discogs_sales_tab, text="Discogs Sales")

ds_frame = ttk.LabelFrame(discogs_sales_tab, text="Discogs Sales", padding=(10, 5))
ds_frame.pack(fill="both", expand=True, padx=5, pady=5)

ds_controls = tk.Frame(ds_frame)
ds_controls.pack(fill="x", pady=(0, 5))

app.check_sales_button = tk.Button(ds_controls, text="Check for New Sales", state="disabled",
                                   command=app.check_discogs_sales)
app.check_sales_button.pack(side="left", anchor="w", padx=5, pady=5)

tk.Button(ds_controls, text="Sync Selected Sale", command=app.sync_discogs_sale).pack(side="left", anchor="w", padx=5, pady=5)

# Discogs sales tree
ds_cols = ("Order ID", "Date", "Buyer", "Artist", "Title", "Price", "Release ID")
app.sales_tree = ttk.Treeview(ds_frame, columns=ds_cols, show="headings")

for col in ds_cols:
    app.sales_tree.heading(col, text=col)

app.sales_tree.pack(side="left", fill="both", expand=True)

ds_scroll = tk.Scrollbar(ds_frame, orient="vertical", command=app.sales_tree.yview)
ds_scroll.pack(side="right", fill="y")
app.sales_tree.configure(yscrollcommand=ds_scroll.set)

# eBay sales tab
ebay_sales_tab = ttk.Frame(sales_notebook_inner)
sales_notebook_inner.add(ebay_sales_tab, text="eBay Sales")

es_frame = ttk.LabelFrame(ebay_sales_tab, text="eBay Account & Sales", padding=(10, 5))
es_frame.pack(fill="both", expand=True, padx=5, pady=5)

es_sales_controls = tk.Frame(es_frame)
es_sales_controls.pack(fill="x", pady=(0, 5))

tk.Label(es_sales_controls, text="Start Date (DD-MM-YYYY):").pack(side="left", padx=(0, 5))
app.ebay_start_date_var = tk.StringVar()
tk.Entry(es_sales_controls, textvariable=app.ebay_start_date_var, width=12).pack(side="left", padx=5)

tk.Label(es_sales_controls, text="End Date (DD-MM-YYYY):").pack(side="left", padx=(10, 5))
app.ebay_end_date_var = tk.StringVar()
tk.Entry(es_sales_controls, textvariable=app.ebay_end_date_var, width=12).pack(side="left", padx=5)

# Set default dates
end_date = datetime.date.today()
start_date = end_date - datetime.timedelta(days=30)
app.ebay_start_date_var.set(start_date.strftime("%d-%m-%Y"))
app.ebay_end_date_var.set(end_date.strftime("%d-%m-%Y"))

app.check_ebay_sales_button = tk.Button(es_sales_controls, text="Check for Sales", state="disabled",
                                        command=app.check_ebay_sales)
app.check_ebay_sales_button.pack(side="left", anchor="w", padx=15, pady=5)

tk.Button(es_sales_controls, text="Sync Selected Sale", command=app.sync_ebay_sale).pack(side="left", anchor="w", padx=5, pady=5)

# eBay sales tree
es_cols = ("Order ID", "Date", "Buyer", "Artist", "Title", "Price", "Item ID")
app.ebay_sales_tree = ttk.Treeview(es_frame, columns=es_cols, show="headings")

for col in es_cols:
    app.ebay_sales_tree.heading(col, text=col)

app.ebay_sales_tree.pack(side="left", fill="both", expand=True, pady=(5, 0))

es_scroll = tk.Scrollbar(es_frame, orient="vertical", command=app.ebay_sales_tree.yview)
es_scroll.pack(side="right", fill="y", pady=(5, 0))
app.ebay_sales_tree.configure(yscrollcommand=es_scroll.set)

    def _select_image_staging_path(self):
"""Open a dialog to select the image staging directory."""
directory = filedialog.askdirectory(
    title="Select Image Staging Folder",
    initialdir=app.config.get("image_staging_path") or os.path.expanduser("~")
)
if directory:
    app.image_staging_path_var.set(directory)
    app.config.save({"image_staging_path": directory})
    messagebox.showinfo("Path Saved", f"Image staging path set to:\n{directory}")
    
    def _update_connection_status(self):
"""Update connection status for APIs"""
# Discogs status
if app.discogs_api.is_connected():
    try:
        user = app.discogs_api.client.identity()
        app.discogs_auth_status_var.set(f"Connected as: {user.username}")
        app.discogs_connect_button.config(state="disabled")
        app.check_sales_button.config(state="normal")
        app.import_button.config(state="normal")
        
        # Enable all Discogs buttons across tabs
        try:
            app.discogs_draft_button.config(state="normal")
            app.discogs_live_button.config(state="normal") 
        except AttributeError:
            pass  # Buttons may not exist yet during initialization
        try:
            app.publish_discogs_btn.config(state="normal")
            app.publish_discogs_live_btn.config(state="normal")
        except AttributeError:
            pass
        
        # Legacy button support
        try:
            app.list_on_discogs_button.config(state="normal")
        except AttributeError:
            pass
            
    except:
        app.discogs_auth_status_var.set("Not Connected")

# eBay status
if app.ebay_api.test_connection():
    app.ebay_auth_status_var.set("Connected Successfully")
    app.check_ebay_sales_button.config(state="normal")
    app.list_on_ebay_button.config(state="normal")
    
    def _copy_ebay_status(self):
"""Copy eBay status to clipboard"""
app.root.clipboard_clear()
app.root.clipboard_append(app.ebay_auth_status_var.get())
messagebox.showinfo("Copied", "Status copied to clipboard")
    
    # ========================================================================
    # ALL CORE METHODS INCLUDING MISSING ONES
    # ========================================================================
    
    def search_discogs(self):
"""Search Discogs for releases"""
artist = app.entries["artist"].get().strip()
title = app.entries["title"].get().strip()

if not artist and not title:
    messagebox.showwarning("Input Required", "Please enter artist and/or title")
    return

app.root.config(cursor="watch")
app.root.update()

# Build search parameters
params = {"per_page": 100, "type": "release"}
if artist:
    params["artist"] = artist
if title:
    params["release_title"] = title

# Search in thread
def search_worker():
    try:
        results = app.discogs_api.search(params)
        app.safe_after(0, lambda: app.display_discogs_results(results))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Search Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=search_worker, daemon=True).start()
    
    def search_by_catno(self):
"""Search Discogs by catalog number"""
catno = app.entries["cat_no"].get().strip()

if not catno:
    messagebox.showwarning("Input Required", "Please enter a catalog number")
    return

app.root.config(cursor="watch")
app.root.update()

def search_worker():
    try:
        results = app.discogs_api.search({"catno": catno, "per_page": 100})
        app.safe_after(0, lambda: app.display_discogs_results(results))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Search Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=search_worker, daemon=True).start()
    
    def display_discogs_results(self, results):
"""Display Discogs search results"""
# Clear existing results
for item in app.discogs_tree.get_children():
    app.discogs_tree.delete(item)

if not results:
    messagebox.showinfo("No Results", "No releases found")
    return

app.discogs_search_results = results

# Populate tree
for item in results:
    artist, title = (item.get("title", "").split(" - ", 1) + [""])[:2]
    values = (
        item.get("id"),
        artist,
        title,
        item.get("catno", "N/A"),
        item.get("year", "N/A"),
        item.get("country", "N/A"),
        ", ".join(item.get("format", []))
    )
    app.discogs_tree.insert("", "end", values=values)
    
    def apply_selected_discogs(self, event=None):
"""
Apply selected Discogs result to form after fetching full details.
"""
selected = app.discogs_tree.focus()
if not selected:
    return

values = app.discogs_tree.item(selected, "values")
release_id = int(values[0])

app.root.config(cursor="watch")
app.root.update()

def fetch_and_apply_worker():
    try:
        release_data = app.discogs_api.get_release(release_id)
        if release_data:
            app.safe_after(0, lambda: app._populate_lister_with_release_data(release_data))
        else:
            app.safe_after(0, lambda: messagebox.showerror("API Error", f"Could not fetch full details for release {release_id}."))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("API Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=fetch_and_apply_worker, daemon=True).start()

    def _populate_lister_with_release_data(self, release_data: dict):
"""
Populates the lister form with cleaned, detailed data from a full Discogs release.
"""
artist_names = [re.sub(r'\s*\(\d+\)$', '', a['name']).strip() for a in release_data.get('artists', [])]
artist = ", ".join(artist_names)

barcode, cat_no = app._extract_barcode_and_cat_no(release_data)
matrix_info = app._extract_matrix_info(release_data)

# --- Populate Form Fields ---
app.entries["artist"].delete(0, tk.END)
app.entries["artist"].insert(0, artist)

app.entries["title"].delete(0, tk.END)
app.entries["title"].insert(0, release_data.get('title', ''))

app.entries["cat_no"].delete(0, tk.END)
app.entries["cat_no"].insert(0, cat_no)

app.entries["barcode"].delete(0, tk.END)
app.entries["barcode"].insert(0, barcode)

app.entries["year"].delete(0, tk.END)
app.entries["year"].insert(0, str(release_data.get('year', '')))

app.entries["matrix_runout"].delete("1.0", tk.END)
app.entries["matrix_runout"].insert("1.0", matrix_info)

formats_list = [f.get('name', '') for f in release_data.get('formats', [])]
if formats_list:
    # Set a sensible default for the format dropdown
    main_format = formats_list[0]
    if main_format.lower() == 'vinyl':
        app.entries["format"].set('LP')
    elif main_format in app.entries['format']['values']:
         app.entries["format"].set(main_format)
    else:
         app.entries["format"].set('Other')

app.current_release_id = release_data.get('id')

app.release_status_label.config(
    text=f"✓ Release selected: {release_data.get('title')} (ID: {app.current_release_id})",
    fg="green"
)

messagebox.showinfo("Success", f"Applied info for '{release_data.get('title')}'")

    def generate_listing_title(self):
"""
Correctly and definitively generate the listing title to the required format:
ARTIST: Title (Year) Vinyl LP CatNo Grade
"""
parts = []
new_used_status = app.entries["new_used"].get()

# --- Gather all data from the form ---
artist = app.entries["artist"].get().strip()
title = app.entries["title"].get().strip()
year = app.entries["year"].get().strip()
cat_no = app.entries["cat_no"].get().strip()
specific_format = app.entries["format"].get().strip()

# --- Build the Format String (DEFINITIVE LOGIC) ---
format_str = ""
# These formats should always result in "Vinyl LP"
lp_formats = ["", "LP", "12\"", "2x12\"", "Vinyl"]

if specific_format in lp_formats:
    format_str = "Vinyl LP"
# Handle specific, non-LP formats like "7\"" or "Box Set"
elif specific_format:
    # Avoid duplication if user manually types "7\" Vinyl"
    if "vinyl" in specific_format.lower():
        format_str = specific_format
    else:
        format_str = f"{specific_format} Vinyl"
# Absolute fallback in case of weird data
else:
    format_str = "Vinyl LP"

# --- Build the Grade String ---
grade_str = ""
if new_used_status == "New":
    grade_str = "NEW/SEALED"
else:  # This covers "Used" and the case where it's not specified
    media = app.entries["media_condition"].get()
    sleeve = app.entries["sleeve_condition"].get()
    if media or sleeve:
        media_abbr = GRADE_ABBREVIATIONS.get(media, "")
        sleeve_abbr = GRADE_ABBREVIATIONS.get(sleeve, "")
        grade = f"{media_abbr}/{sleeve_abbr}".strip("/")
        if grade:
            grade_str = grade

# --- Assemble the title in the correct, specified order ---
if artist:
    parts.append(f"{artist.upper()}:")
if title:
    parts.append(title)
if year:
    parts.append(f"({year})")

# Add the newly built format string
parts.append(format_str)

if cat_no:
    parts.append(cat_no)
if grade_str:
    parts.append(grade_str)

# --- Finalize and set the title ---
final_title = " ".join(filter(None, parts))[:80]
app.entries["listing_title"].delete(0, tk.END)
app.entries["listing_title"].insert(0, final_title)
    
    def build_description(self):
"""Build full description with tracklist using the Analog Theory template."""
if not app.current_release_id:
    messagebox.showwarning("No Release", "Please select a Discogs release first to get tracklist data.")
    app._render_analog_theory_description(None)
    return

app.root.config(cursor="watch")
app.root.update()

def fetch_worker():
    try:
        release = app.discogs_api.get_release(app.current_release_id)
        app.safe_after(0, lambda: app._render_analog_theory_description(release))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=fetch_worker, daemon=True).start()

    def _render_analog_theory_description(self, release_data):
"""Renders the Analog Theory HTML and places it in the description box."""

# --- Gather data from UI form and API response ---
payload = {
    "artist": app.entries["artist"].get().strip(),
    "title": app.entries["title"].get().strip(),
    "cat_no": app.entries["cat_no"].get().strip(),
    "year": app.entries["year"].get().strip(),
    "format": app.entries["format"].get(),
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "condition_notes": app.entries["condition_notes"].get("1.0", "end-1c").strip(),
    "matrix_runout": app.entries["matrix_runout"].get("1.0", "end-1c").strip(),
    "condition_tags": app.entries["condition_tags"].get().strip(),
    "barcode": app.entries["barcode"].get().strip(),
    "genre": app.entries["genre"].get().strip(),
}

# --- Helper functions for template ---
def get(key, default=''):
    return payload.get(key) or default

def get_release_attr(data, key, default=''):
    return data.get(key, default) if data else default

def get_label_info(data):
    if not data or not data.get('labels'): return ''
    return data['labels'][0].get('name', '')

def get_main_format(data):
    if not data or not data.get('formats'): return get('format')
    main_format = data['formats'][0].get('name', '')
    descriptions = ", ".join(data['formats'][0].get('descriptions', []))
    return f"{main_format}, {descriptions}" if descriptions else main_format

# --- Prepare data for the 2x3 grid ---
grid_data = {
    "FORMAT": get_main_format(release_data),
    "CAT NO": get('cat_no'),
    "BARCODE": get('barcode'),
    "YEAR": get('year'),
    "PUBLISHER": get_label_info(release_data),
    "COUNTRY": get_release_attr(release_data, 'country', '')
}

info_grid_html = ""
for label, value in grid_data.items():
    if value:
        info_grid_html += f'<div class="info-box"><span class="info-label">{label}</span><span class="info-value">{value}</span></div>'

# --- Prepare other template sections ---
tags_raw = get('condition_tags', '').strip()
tags_list = [tag.strip() for tag in tags_raw.split(',') if tag.strip()]
tags_html = "".join([f'<div class="condition-tag">{tag}</div>' for tag in tags_list])

tracklist_html = ""
if release_data and release_data.get('tracklist'):
    tracklist_items = []
    for track in release_data['tracklist']:
        title = track.get('title', 'Unknown Track')
        position = (track.get('position', '') or '').strip()
        display = f"{position}  {title}".strip()
        tracklist_items.append(f'<li class="track"><span class="track-line">{display}</span></li>')
    tracklist_html = f'<ul class="track-listing" style="list-style:none; margin:0; padding-left:0;">{"".join(tracklist_items)}</ul>'


matrix_html = ""
if get('matrix_runout'):
    matrix_html = f'<div class="details-content matrix-content">{get("matrix_runout").replace(chr(10), "<br>")}</div>'

seller_footer = app.config.get('seller_footer', '').replace('\n', '<br>')

# --- Build the final HTML ---
        # --- Build the final HTML (inline styles only) ---
_pill = "display:inline-block; font-weight:bold; padding:6px 10px; border-radius:8px; border:1px solid #3a7d2c; background:#f1f9f1; color:#3a7d2c; margin:2px;"

tags_raw = (get('condition_tags') or '').strip()
tags_list = [t.strip() for t in tags_raw.split(',') if t.strip()]
tags_pills_html = "".join([f'<span style="{_pill}">{t}</span>' for t in tags_list])

condition_notes_html = (
    '<div style="border-top:1px dashed #d6d2c9; padding:14px 0;"><strong>Condition Notes:</strong>'
    '<div style="font-size:14px; color:#5c5c5c; margin-top:8px;">' + get('condition_notes').replace(chr(10), '<br>') + '</div></div>'
) if get('condition_notes') else ''

matrix_text = get('matrix_runout') or ''
matrix_details_html = (
    '<div style="border:1px solid #d6d2c9; border-radius:8px; padding:12px; background:#ffffff; margin-top:14px;">'
    '<h3 style="margin:0 0 12px 0; font-size:16px; font-weight:bold;">Matrix / Runout Details</h3>'
    '<div style="font-size:14px; white-space:pre-wrap;">' + matrix_text.replace(chr(10), '<br>') + '</div></div>'
) if (matrix_text and len(matrix_text) > 50) else ''

tracklist_section_html = (
    '<div style="border:1px solid #d6d2c9; border-radius:8px; padding:12px; background:#ffffff; margin-top:10px;">'
    '<h3 style="margin:0 0 12px 0; font-size:16px; font-weight:bold;">Tracklist</h3>' + (tracklist_html or '') + '</div>'
) if (tracklist_html or '') else ''

if seller_footer:
    store_promise_html = (
        '<div style="border:1px solid #d6d2c9; border-radius:8px; padding:12px; background:#ffffff; margin:10px 0 14px 0;">'
        f'<p style="font-size:14px; color:#5c5c5c; margin:0;">{seller_footer}</p>'
        '</div>'
    )
else:
    store_promise_html = (
        '<div style="border:1px solid #d6d2c9; border-radius:8px; padding:12px; background:#ffffff; margin:10px 0 14px 0;">'
        '<ul style="margin:0; padding:0 0 0 24px; font-size:14px; list-style:disc;">'
        '<li style="margin:6px 0;">Professional, Secure Packaging</li>'
        '<li style="margin:6px 0;">Fast Dispatch Royal Mail</li>'
        '<li style="margin:6px 0;">All Stock Graded Honestly</li>'
        '</ul>'
        '</div>'
    )

        # --- Build the final HTML (inline styles only) ---
_pill = "display:inline-block; font-weight:bold; padding:6px 10px; border-radius:8px; border:1px solid #3a7d2c; background:#f1f9f1; color:#3a7d2c; margin:2px;"

tags_raw = (get('condition_tags') or '').strip()
tags_list = [t.strip() for t in tags_raw.split(',') if t.strip()]
tags_pills_html = "".join([f'<span style="{_pill}">{t}</span>' for t in tags_list])

condition_notes_html = (
    '<div style="border-top:1px dashed #d6d2c9; padding:14px 0;"><strong>Condition Notes:</strong>'
    '<div style="font-size:14px; color:#5c5c5c; margin-top:8px;">' + get('condition_notes').replace(chr(10), '<br>') + '</div></div>'
) if get('condition_notes') else ''

matrix_text = get('matrix_runout') or ''
matrix_details_html = (
    '<div style="border:1px solid #d6d2c9; border-radius:8px; padding:12px; background:#ffffff; margin-top:14px;">'
    '<h3 style="margin:0 0 12px 0; font-size:16px; font-weight:bold;">Matrix / Runout Details</h3>'
    '<div style="font-size:14px; white-space:pre-wrap;">' + matrix_text.replace(chr(10), '<br>') + '</div></div>'
) if (matrix_text and len(matrix_text) > 50) else ''

# Always show static footer bullets, bold and 2x font size, no “why buy…” text
store_promise_html = (
    '<div style="border:1px solid #d6d2c9; border-radius:8px; padding:12px; background:#ffffff; margin:10px 0 14px 0;">'
    '<ul style="margin:0; padding:0 0 0 24px; font-size:28px; font-weight:bold; list-style:disc;">'
    '<li style="margin:10px 0;">Professional, Secure Packaging</li>'
    '<li style="margin:10px 0;">Fast Dispatch Royal Mail</li>'
    '<li style="margin:10px 0;">All Stock Graded Honestly</li>'
    '</ul>'
    '</div>'
)

        # --- Build the final HTML (inline styles only) ---
_pill = "display:inline-block; font-weight:bold; padding:6px 10px; border-radius:8px; border:1px solid #3a7d2c; background:#f1f9f1; color:#3a7d2c; margin:2px;"

tags_raw = (get('condition_tags') or '').strip()
tags_list = [t.strip() for t in tags_raw.split(',') if t.strip()]
tags_pills_html = "".join([f'<span style="{_pill}">{t}</span>' for t in tags_list])

condition_notes_html = (
    '<div style="border-top:1px dashed #d6d2c9; padding:14px 0;"><strong>Condition Notes:</strong>'
    '<div style="font-size:14px; color:#5c5c5c; margin-top:8px;">' + get('condition_notes').replace(chr(10), '<br>') + '</div></div>'
) if get('condition_notes') else ''

matrix_text = get('matrix_runout') or ''
matrix_details_html = (
    '<div style="border:1px solid #d6d2c9; border-radius:8px; padding:12px; background:#ffffff; margin-top:14px;">'
    '<h3 style="margin:0 0 12px 0; font-size:16px; font-weight:bold;">Matrix / Runout Details</h3>'
    '<div style="font-size:14px; white-space:pre-wrap;">' + matrix_text.replace(chr(10), '<br>') + '</div></div>'
) if (matrix_text and len(matrix_text) > 50) else ''

# Footer: professional 3-column feature grid with green ticks
store_promise_html = (
    '<div style="border:1px solid #e3e0d8; border-radius:12px; padding:16px; background:#fffefb; margin:12px 0 16px 0;">'
      '<table role="presentation" style="width:100%; border-collapse:separate; border-spacing:8px;">'
        '<tr>'
          '<td style="width:33.33%; vertical-align:top; padding:10px; border:1px solid #e3e0d8; border-radius:10px; background:#ffffff;">'
            '<div style="display:flex; align-items:flex-start; gap:10px;">'
              '<span aria-hidden="true" style="font-size:22px; line-height:1; margin-top:2px;">✅</span>'
              '<span style="font-size:18px; font-weight:600; color:#1a1a1a; line-height:1.4;">Professional, Secure Packaging</span>'
            '</div>'
          '</td>'
          '<td style="width:33.33%; vertical-align:top; padding:10px; border:1px solid #e3e0d8; border-radius:10px; background:#ffffff;">'
            '<div style="display:flex; align-items:flex-start; gap:10px;">'
              '<span aria-hidden="true" style="font-size:22px; line-height:1; margin-top:2px;">✅</span>'
              '<span style="font-size:18px; font-weight:600; color:#1a1a1a; line-height:1.4;">Fast Dispatch Royal Mail</span>'
            '</div>'
          '</td>'
          '<td style="width:33.33%; vertical-align:top; padding:10px; border:1px solid #e3e0d8; border-radius:10px; background:#ffffff;">'
            '<div style="display:flex; align-items:flex-start; gap:10px;">'
              '<span aria-hidden="true" style="font-size:22px; line-height:1; margin-top:2px;">✅</span>'
              '<span style="font-size:18px; font-weight:600; color:#1a1a1a; line-height:1.4;">All Stock Graded Honestly</span>'
            '</div>'
          '</td>'
        '</tr>'
      '</table>'
    '</div>'
)

html = f"""
<div style="max-width: 860px; width: 100%; margin: 0 auto; background: #fffdf9; border: 1px solid #d6d2c9; border-radius: 12px; overflow: hidden; font-family: Arial, 'Helvetica Neue', sans-serif; color: #1a1a1a; font-size: 16px; line-height: 1.55;">
  <div style="padding: 20px 22px; border-bottom: 1px solid #d6d2c9; background: #ffffff;">
    <table style="width: 100%; border-collapse: collapse;">
      <tr>
        <td style="width: 44px; vertical-align: middle; padding-right: 16px;">
          <div style="width: 44px; height: 44px; border-radius: 8px; border: 1px solid #d6d2c9; background: linear-gradient(135deg, #b8e6ff, #e8f7ff);"></div>
        </td>
        <td style="vertical-align: middle;">
          <h1 style="margin: 0; font-size: 20px; font-weight: bold; color: #1a1a1a;">{get('artist')} – {get('title')}</h1>
        </td>
        <td style="text-align: right; vertical-align: middle;">
          <span style="display: inline-block; border: 1px solid #d6d2c9; color: #5c5c5c; padding: 6px 12px; border-radius: 20px; font-size: 14px;">In Stock</span>
        </td>
      </tr>
    </table>
  </div>

  <div style="padding: 20px 22px;">
    <table style="width: 100%; border-collapse: separate; border-spacing: 10px; margin: 16px 0;">
      <tr>
        <td style="border: 1px solid #d6d2c9; border-radius: 8px; padding: 10px 12px; background: #ffffff; width: 33%; vertical-align: top;">
          <span style="display:block; font-size:12px; color:#5c5c5c; text-transform:uppercase; letter-spacing:0.5px;">Format</span>
          <span style="display:block; font-weight:bold; margin-top:4px;">{get_main_format(release_data)}</span>
        </td>
        <td style="border: 1px solid #d6d2c9; border-radius: 8px; padding: 10px 12px; background: #ffffff; width: 33%; vertical-align: top;">
          <span style="display:block; font-size:12px; color:#5c5c5c; text-transform:uppercase; letter-spacing:0.5px;">Cat No</span>
          <span style="display:block; font-weight:bold; margin-top:4px;">{get('cat_no')}</span>
        </td>
        <td style="border: 1px solid #d6d2c9; border-radius: 8px; padding: 10px 12px; background: #ffffff; width: 33%; vertical-align: top;">
          <span style="display:block; font-size:12px; color:#5c5c5c; text-transform:uppercase; letter-spacing:0.5px;">Year</span>
          <span style="display:block; font-weight:bold; margin-top:4px;">{get('year')}</span>
        </td>
      </tr>
      <tr>
        <td style="border: 1px solid #d6d2c9; border-radius: 8px; padding: 10px 12px; background: #ffffff; width: 33%; vertical-align: top;">
          <span style="display:block; font-size:12px; color:#5c5c5c; text-transform:uppercase; letter-spacing:0.5px;">Label</span>
          <span style="display:block; font-weight:bold; margin-top:4px;">{get_label_info(release_data)}</span>
        </td>
        <td style="border: 1px solid #d6d2c9; border-radius: 8px; padding: 10px 12px; background: #ffffff; width: 33%; vertical-align: top;">
          <span style="display:block; font-size:12px; color:#5c5c5c; text-transform:uppercase; letter-spacing:0.5px;">Country</span>
          <span style="display:block; font-weight:bold; margin-top:4px;">{get_release_attr(release_data, 'country', '')}</span>
        </td>
        <td style="border: 1px solid #d6d2c9; border-radius: 8px; padding: 10px 12px; background: #ffffff; width: 33%; vertical-align: top;">
          <span style="display:block; font-size:12px; color:#5c5c5c; text-transform:uppercase; letter-spacing:0.5px;">Barcode</span>
          <span style="display:block; font-weight:bold; margin-top:4px;">{get('barcode')}</span>
        </td>
      </tr>
    </table>

    <!-- Condition block -->
    <div style="border-top:1px dashed #d6d2c9; padding:14px 0;">
      <div style="display:block;">
        <strong style="font-size:16px; display:block;">Condition</strong>
        <div style="font-size:14px; color:#5c5c5c; margin:6px 0 8px 0;">Graded under strong light.</div>
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <span style="{_pill}">Vinyl: {GRADE_ABBREVIATIONS.get(get('media_condition'), '')}</span>
          <span style="{_pill}">Sleeve: {GRADE_ABBREVIATIONS.get(get('sleeve_condition'), '')}</span>
          {tags_pills_html}
        </div>
      </div>
    </div>
  </div>

  {condition_notes_html}
  {matrix_details_html}
  {tracklist_section_html}

  {store_promise_html}
</div>
"""
final_html = '\n'.join([line.strip() for line in html.split('\n')])
app.full_desc.delete("1.0", tk.END)
app.full_desc.insert("1.0", final_html)
    
    def list_on_discogs(self):
"""List item on Discogs"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def list_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_listing_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=list_worker, daemon=True).start()
    
    def _handle_listing_success(self, listing_id):
"""Handle successful Discogs listing"""
messagebox.showinfo("Success", f"Successfully listed item on Discogs as a Draft (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")
    
    def list_on_ebay(self):
"""Create eBay draft listing, now with image uploading and correct condition mapping."""
if not app.ebay_api.test_connection():
    messagebox.showwarning("Not Connected", "Please check your eBay credentials in config.json and re-authenticate if necessary.")
    return

# --- Validation ---
required_fields = ['artist', 'title', 'media_condition']
for field in required_fields:
    if not app.entries[field.replace(' ', '_')].get().strip():
        messagebox.showwarning("Validation Error", f"Please enter {field}")
        return
try:
    price = float(app.price_entry.get())
    if price <= 0:
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

# --- Data Gathering & Condition Fix ---
sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
if not app.editing_sku and not app.temporary_sku:
    app.sku_display_var.set(sku)

format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

# Default to USED_GOOD for unknown grades; do not use USED_EXCELLENT which eBay no longer accepts for vinyl
condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")

category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")
ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

listing_data = {
    "sku": sku, "title": ebay_title[:80], "description": description_html,
    "categoryId": str(category_id), "price": price, "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(), # Pass for summary
    "sleeve_condition": app.entries["sleeve_condition"].get(), # Pass for summary
    "currency": "GBP", "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths, # Pass local paths for the API to handle
}

# --- Start Background Worker ---
app.root.config(cursor="watch")
app.root.update()
app.notebook.select(app.inventory_tab)

def list_worker():
    try:
        app.append_log(f"SKU {sku}: Creating/updating eBay inventory item and offer...", "black")
        result = app.ebay_api.create_draft_listing(listing_data)
        
        if result.get("success"):
            app.safe_after(0, lambda: app._handle_ebay_listing_success(sku, result.get("offerId")))
        else:
            error_message = result.get('error', 'Unknown error')
            app.append_log(f"SKU {sku}: eBay listing failed. {error_message}", "red")
            app.safe_after(0, lambda: messagebox.showerror("Listing Failed", f"eBay listing failed for SKU {sku}:\n\n{error_message}"))

    except Exception as e:
        app.append_log(f"SKU {sku}: An unexpected error occurred: {e}", "red")
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=list_worker, daemon=True).start()


    
    def _handle_ebay_listing_success(self, sku, offer_id):

    
"""Handle successful eBay listing: resolve Item ID (listingId) and store it."""

    
import datetime, logging

    
logger = logging.getLogger(__name__)

    
    

    
listing_id = None

    
try:

    
    offer = app.ebay_api.get_offer(str(offer_id))

    
    if offer.get("success"):

    
        listing_id = offer.get('legacyItemId') or (offer.get('listing') or {}).get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('listingId')

    
except Exception as e:

    
    logger.warning(f"[offer] Could not resolve listingId for offer {offer_id}: {e}")

    
    

    
stored_id = listing_id or str(offer_id)

    
label = "Item ID" if listing_id else "Offer ID"

    
app.append_log(f"SKU {sku}: eBay listing updated ({label}: {stored_id}).", "green")

    
    

    
now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()

    
try:

    
    with app.db.get_connection() as conn:

    
        cursor = conn.cursor()

    
        cursor.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))

    
    app.populate_inventory_view()

    
except Exception as e:

    
    logger.error(f"Failed to update inventory with eBay ID: {e}")

    
    app.append_log(f"SKU {sku}: Failed to save eBay {label} to local DB: {e}", "red")

    
    

    
try:

    
    messagebox.showinfo("Success", f"eBay listing updated.\n{label}: {stored_id}\n\nCheck Seller Hub → Active.")

    
except Exception:

    
    pass


    
    def save_to_inventory(self):
"""Save current form to inventory, ensuring full payload is saved on update."""
payload_json = json.dumps(app._serialize_form_to_payload())
data = {
    "artist": app.entries["artist"].get().strip(),
    "title": app.entries["title"].get().strip(),
    "cat_no": app.entries["cat_no"].get().strip(),
    "year": app.entries["year"].get().strip(),
    "format": app.entries["format"].get(),
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "price": app.price_entry.get().strip(),
    "status": "For Sale",
    "discogs_release_id": app.current_release_id,
    "notes": app.entries["condition_notes"].get("1.0", "end-1c").strip(),
    "matrix_runout": app.entries["matrix_runout"].get("1.0", "end-1c").strip(),
    "condition_tags": app.entries["condition_tags"].get().strip(),
    "description": app.full_desc.get("1.0", tk.END).strip(),
    "shipping_option": app.entries["shipping_option"].get(),
    "barcode": app.entries["barcode"].get().strip(),
    "genre": app.entries["genre"].get(),
    "new_used": app.entries["new_used"].get(),
    "listing_title": app.entries["listing_title"].get().strip()
}

if not data["title"]:
    messagebox.showwarning("Validation Error", "Title is required")
    return
try:
    price = float(data["price"]) if data["price"] else 0
    data["price"] = price
except ValueError:
    messagebox.showwarning("Validation Error", "Invalid price")
    return

is_update = bool(app.editing_sku)

if is_update:
    sku = app.editing_sku
elif app.temporary_sku:
    sku = app.temporary_sku.replace("-TEMP", "")
    app.temporary_sku = None
else:
    sku = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        if is_update:
            # --- CRITICAL FIX: Ensure payload is saved on update ---
            sql = """UPDATE inventory SET artist = :artist, title = :title, cat_no = :cat_no, year = :year, format = :format,
                    media_condition = :media_condition, sleeve_condition = :sleeve_condition, price = :price, 
                    discogs_release_id = :discogs_release_id, notes = :notes, description = :description,
                    shipping_option = :shipping_option, barcode = :barcode, genre = :genre, new_used = :new_used, 
                    listing_title = :listing_title, matrix_runout = :matrix_runout, condition_tags = :condition_tags,
                    last_modified = :last_modified, inv_updated_at = :inv_updated_at, lister_payload = :lister_payload WHERE sku = :sku"""
            params = data
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            params["last_modified"] = now_iso
            # update local inventory timestamp
            params["inv_updated_at"] = now_iso
            params["lister_payload"] = payload_json
            params["sku"] = sku
            cursor.execute(sql, params)
            messagebox.showinfo("Success", f"Updated SKU: {sku}")
        else:
            sql = """INSERT INTO inventory (sku, artist, title, cat_no, year, format, media_condition,
                    sleeve_condition, price, status, discogs_release_id, notes, description, shipping_option, barcode, genre, new_used,
                    listing_title, matrix_runout, condition_tags, date_added, last_modified, inv_updated_at, lister_payload
                    ) VALUES (:sku, :artist, :title, :cat_no, :year, :format, :media_condition,
                    :sleeve_condition, :price, :status, :discogs_release_id, :notes, :description, :shipping_option, :barcode, :genre, :new_used,
                    :listing_title, :matrix_runout, :condition_tags, :date_added, :last_modified, :inv_updated_at, :lister_payload)"""
            now = datetime.datetime.now(datetime.timezone.utc).isoformat()
            params = data
            params["sku"] = sku
            params["date_added"] = now
            params["last_modified"] = now
            params["inv_updated_at"] = now
            params["lister_payload"] = payload_json
            cursor.execute(sql, params)
            messagebox.showinfo("Success", f"Saved with SKU: {sku}")
    
    app.populate_inventory_view()
    app.clear_form()
    
except Exception as e:
    logger.error(f"Failed to save to inventory: {e}", exc_info=True)
    messagebox.showerror("Database Error", f"Failed to save: {e}")

    def clear_form(self):
"""Clear all form fields"""
for key, widget in app.entries.items():
    if isinstance(widget, (tk.Entry, ttk.Entry)):
        widget.delete(0, tk.END)
    elif isinstance(widget, tk.Text):
        widget.delete("1.0", tk.END)
    elif isinstance(widget, ttk.Combobox):
        widget.set("")

app.price_entry.delete(0, tk.END)
app.full_desc.delete("1.0", tk.END)

app.current_release_id = None
app.editing_sku = None
app.temporary_sku = None
app.image_paths = []
app._update_image_listbox()
app._clear_image_preview()
app.sku_display_var.set("")

app.save_button.config(text="Save to Inventory")
app.release_status_label.config(text="⚠ No release selected", fg="red")

for item in app.discogs_tree.get_children():
    app.discogs_tree.delete(item)
    
    def generate_image_qr_code(self):
"""Generate QR code for image association."""
if not QR_LIBRARIES_AVAILABLE:
    messagebox.showerror("Missing Libraries", "PIL (Pillow) and qrcode libraries are required for this feature.")
    return

if app.editing_sku:
    sku = app.editing_sku
elif not app.temporary_sku:
    # Create a temporary SKU for the new item if it doesn't have one
    app.temporary_sku = f"{datetime.datetime.now().strftime('%Y%m%d-%H%M%S')}-TEMP"
    sku = app.temporary_sku
else:
    sku = app.temporary_sku
    
app.sku_display_var.set(sku)

qr_data = f"vinyltool_sku:{sku}"

qr = qrcode.QRCode(version=1, box_size=10, border=4)
qr.add_data(qr_data)
qr.make(fit=True)
img = qr.make_image(fill='black', back_color='white')

# Display in a new window
qr_window = tk.Toplevel(app.root)
qr_window.title(f"QR Code for SKU: {sku}")

photo = ImageTk.PhotoImage(img)
label = tk.Label(qr_window, image=photo)
label.image = photo # Keep a reference
label.pack(padx=20, pady=20)

tk.Label(qr_window, text=f"Scan this code with your phone to associate images with\nSKU: {sku}", justify='center').pack(pady=(0,10))

    def select_images_manually(self):
"""[NEW & FIXED] Open a file dialog to select images and copy them to a managed folder."""
# 1. Ensure we have a SKU to work with
if app.editing_sku:
    sku = app.editing_sku
elif not app.temporary_sku:
    # Create a temporary SKU if one doesn't exist for this new item
    app.temporary_sku = f"{datetime.datetime.now().strftime('%Y%m%d-%H%M%S')}-TEMP"
    sku = app.temporary_sku
else:
    sku = app.temporary_sku

app.sku_display_var.set(sku)

# 2. Open file dialog to select images
selected_files = filedialog.askopenfilenames(
    title="Select images for this item",
    filetypes=[("Image Files", "*.jpg *.jpeg *.png *.heic"), ("All files", "*.*")]
)
if not selected_files:
    return # User cancelled

# 3. Create a dedicated, permanent folder for this SKU's images
# [FIX] Changed 'item_images' to 'managed_images' to match expected path
permanent_storage_path = os.path.join(os.path.dirname(__file__), "managed_images", sku.replace('-TEMP', ''))
os.makedirs(permanent_storage_path, exist_ok=True)

new_image_paths = []
for source_path in selected_files:
    filename = os.path.basename(source_path)
    destination_path = os.path.join(permanent_storage_path, filename)
    try:
        # Copy the file to the managed folder. Use copy2 to preserve metadata.
        shutil.copy2(source_path, destination_path)
        new_image_paths.append(destination_path)
        logger.info(f"Copied '{filename}' to '{permanent_storage_path}'")
    except Exception as e:
        logger.error(f"Failed to copy image '{filename}': {e}")
        messagebox.showerror("Image Copy Error", f"Could not copy file: {filename}\n\nError: {e}")

# 4. Update the internal image list and the UI
# Add new paths and remove duplicates, preserving order
for path in new_image_paths:
    if path not in app.image_paths:
        app.image_paths.append(path)

app._update_image_listbox()
messagebox.showinfo("Images Linked", f"Successfully linked {len(new_image_paths)} images to SKU {sku}.")

    def import_staged_images(self):
"""Import images from the staging folder that have a matching SKU via QR or filename."""
staging_path = app.image_staging_path_var.get()
if not staging_path or not os.path.isdir(staging_path):
    messagebox.showerror("Path Error", "Image staging path is not set or is not a valid directory.\nPlease set it in the Settings tab.")
    return

if not app.editing_sku and not app.temporary_sku:
    messagebox.showwarning("No SKU", "Please save the item or generate a QR code first to create an SKU for image association.")
    return
    
sku_to_find = app.editing_sku or app.temporary_sku
logger.info(f"Scanning for images for SKU: {sku_to_find}")

found_images = []

# Scan staging path for subfolders matching the SKU
sku_folder_path = os.path.join(staging_path, sku_to_find)
if os.path.isdir(sku_folder_path):
    logger.info(f"Found SKU subfolder: {sku_folder_path}")
    for filename in sorted(os.listdir(sku_folder_path)):
        if filename.lower().endswith(('.png', '.jpg', '.jpeg')):
            found_images.append(os.path.join(sku_folder_path, filename))
else:
    logger.warning(f"SKU subfolder not found. Scanning staging root for QR codes or prefixed files.")
    # Fallback: scan root of staging path for images containing the QR code or SKU prefix
    for filename in os.listdir(staging_path):
         if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.heic')):
            filepath = os.path.join(staging_path, filename)
            # Check for SKU prefix
            if filename.startswith(sku_to_find):
                found_images.append(filepath)
                logger.info(f"Found matching SKU prefix in {filename}")
                continue # Move to next file

            # Check for QR code if pyzbar is available
            if QR_DECODER_AVAILABLE:
                try:
                    with Image.open(filepath) as img:
                        decoded_objects = qr_decode(img, symbols=[ZBarSymbol.QRCODE])
                        for obj in decoded_objects:
                            decoded_data = obj.data.decode('utf-8')
                            if decoded_data == f"vinyltool_sku:{sku_to_find}":
                                found_images.append(filepath)
                                logger.info(f"Found matching QR code in {filename}")
                                break # Stop checking this image's QR codes
                except Exception as e:
                    logger.error(f"Error decoding {filename}: {e}")

if not found_images:
    messagebox.showinfo("No Images Found", f"No images for SKU '{sku_to_find}' were found in the staging folder.")
    return

# Move images to a permanent, organized location
permanent_storage_path = os.path.join(os.path.dirname(__file__), "managed_images", sku_to_find.replace('-TEMP',''))
os.makedirs(permanent_storage_path, exist_ok=True)

new_image_paths = []
for old_path in found_images:
    filename = os.path.basename(old_path)
    new_path = os.path.join(permanent_storage_path, filename)
    try:
        shutil.move(old_path, new_path)
        new_image_paths.append(new_path)
        logger.info(f"Moved {filename} to {permanent_storage_path}")
    except Exception as e:
        logger.error(f"Failed to move {filename}: {e}")
        # If move fails, try to copy as a fallback
        try:
            shutil.copy2(old_path, new_path)
            new_image_paths.append(new_path)
            logger.info(f"Copied {filename} to {permanent_storage_path} as a fallback.")
        except Exception as copy_e:
            logger.error(f"Fallback copy also failed for {filename}: {copy_e}")

# Update the UI
app.image_paths.extend(new_image_paths)
app.image_paths = sorted(list(set(app.image_paths))) # Remove duplicates and sort
app._update_image_listbox()
messagebox.showinfo("Import Complete", f"Successfully imported {len(new_image_paths)} images.")

    def populate_inventory_view(self, search_term=""):
"""Populate inventory tree view"""
for item in app.inventory_tree.get_children():
    app.inventory_tree.delete(item)

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        # Select additional ID columns and timestamps for display and logic
        query = "SELECT sku, artist, title, price, status, ebay_item_draft_id, ebay_listing_id, discogs_listing_id, date_added, inv_updated_at, ebay_updated_at, discogs_updated_at FROM inventory"
        params = []
        if search_term:
            query += " WHERE artist LIKE ? OR title LIKE ? OR sku LIKE ?"
            search_pattern = f"%{search_term}%"
            params = [search_pattern, search_pattern, search_pattern]
        
        sort_map = {
            "SKU": "sku",
            "Artist": "artist",
            "Title": "title",
            "Price": "price",
            "Status": "status",
            "eBay Draft ID": "ebay_item_draft_id",
            "eBay Listing ID": "ebay_listing_id",
            "Discogs ID": "discogs_listing_id",
            "Date Added": "date_added"
        }
        sort_col = sort_map.get(app.inventory_sort_column, "id")
        query += f" ORDER BY {sort_col} {app.inventory_sort_direction}"
        
        cursor.execute(query, params)
        
        for row in cursor.fetchall():
            # row indices: 0=sku,1=artist,2=title,3=price,4=status,5=ebay_item_draft_id,6=ebay_listing_id,7=discogs_listing_id,8=date_added,9=inv_updated_at,10=ebay_updated_at,11=discogs_updated_at
            price_str = f"£{row[3]:.2f}" if row[3] else ""
            date_added_str = ""
            if row[8]:
                try:
                    dt = datetime.datetime.fromisoformat(str(row[8]).replace('Z', '+00:00'))
                    date_added_str = dt.strftime("%Y-%m-%d %H:%M")
                except Exception:
                    date_added_str = row[8]
            draft_id = row[5] or ""
            live_id = row[6] or ""
            discogs_id = row[7] or ""
            values = (row[0], row[1] or "", row[2] or "", price_str, row[4] or "", draft_id, live_id, discogs_id, date_added_str)
            app.inventory_tree.insert("", "end", values=values)
            
except Exception as e:
    logger.error(f"Failed to populate inventory: {e}")
    messagebox.showerror("Database Error", f"Failed to load inventory: {e}")
    
    def sort_inventory(self, col):
"""Sort inventory by column"""
if app.inventory_sort_column == col:
    app.inventory_sort_direction = "ASC" if app.inventory_sort_direction == "DESC" else "DESC"
else:
    app.inventory_sort_column = col
    app.inventory_sort_direction = "ASC"
app.populate_inventory_view(app.inventory_search_var.get())
    
    def load_item_for_editing(self, event=None):
"""
Load item by reading from the database and prioritizing the lister_payload.
"""
selected = app.inventory_tree.focus()
if not selected: return

sku = app.inventory_tree.item(selected, "values")[0]

try:
    # Use the getter that intelligently merges the payload
    record_data = app._get_inventory_record(sku)

    if not record_data:
        messagebox.showerror("Error", f"Could not find record for SKU: {sku}")
        return

    app.clear_form()
    
    # The payload is already merged, so we can just apply it
    app._apply_payload_to_form(record_data)

    # Special handling for DB fields not in the typical payload
    if 'notes' in record_data and not record_data.get('condition_notes'):
         app.entries['condition_notes'].delete('1.0', tk.END)
         app.entries['condition_notes'].insert('1.0', record_data['notes'])

    app.editing_sku = sku
    app.sku_display_var.set(sku)
    app.save_button.config(text="Update Inventory")
    
    release_id = record_data.get("discogs_release_id")
    if release_id:
        app.release_status_label.config(text=f"✓ Editing SKU: {sku} (Release ID: {release_id})", fg="blue")
    else:
        app.release_status_label.config(text=f"✓ Editing SKU: {sku} (No release linked)", fg="orange")
    
    app.notebook.select(app.lister_tab)
    
except Exception as e:
    logger.error(f"Failed to load item for editing: {e}", exc_info=True)
    messagebox.showerror("Error", f"Failed to load item: {e}")

    def edit_in_lister(self):
"""Load selected item in lister tab"""
app.load_item_for_editing()
    
    def delete_inventory_item(self):
"""Delete selected inventory items with two-way sync."""
selected_items = app.inventory_tree.selection()
if not selected_items:
    messagebox.showwarning("No Selection", "Please select one or more items to delete.")
    return

item_details = []
for item_id in selected_items:
    values = app.inventory_tree.item(item_id, "values")
    sku = values[0]
    record = app._get_inventory_record(sku)
    item_details.append({"sku": sku, "discogs_listing_id": record.get("discogs_listing_id")})

msg = f"Are you sure you want to delete {len(item_details)} item(s)?\n\nThis will also attempt to delete their corresponding Discogs listings."
if not messagebox.askyesno("Confirm Delete", msg):
    return

app.root.config(cursor="watch")
app.root.update()

def delete_worker():
    success_count, fail_count = 0, 0
    for item in item_details:
        sku, discogs_listing_id = item["sku"], item["discogs_listing_id"]
        if discogs_listing_id and app.discogs_api.is_connected():
            app.append_log(f"Deleting Discogs listing {discogs_listing_id} for SKU {sku}...", "black")
            if not app.discogs_api.delete_listing(discogs_listing_id):
                app.append_log(f"✗ Failed to delete Discogs listing {discogs_listing_id}.", "red")
                if not messagebox.askyesno("Discogs Deletion Failed", f"Failed to delete Discogs listing for SKU {sku}.\n\nDo you still want to delete the item from your local inventory?"):
                    fail_count += 1
                    continue
        try:
            with app.db.get_connection() as conn:
                conn.cursor().execute("DELETE FROM inventory WHERE sku = ?", (sku,))
            app.append_log(f"✓ Deleted SKU {sku} from local inventory.", "green")
            success_count += 1
        except Exception as e:
            app.append_log(f"✗ Failed to delete SKU {sku} from local DB: {e}", "red")
            fail_count += 1
    app.safe_after(0, lambda: (app.root.config(cursor=""), app.populate_inventory_view(), messagebox.showinfo("Deletion Complete", f"Successfully deleted: {success_count}\nFailed or skipped: {fail_count}")))
threading.Thread(target=delete_worker, daemon=True).start()

    def select_all_inventory(self):
"""Select all items in inventory"""
for item in app.inventory_tree.get_children():
    app.inventory_tree.selection_add(item)
    
    def deselect_all_inventory(self):
"""Deselect all items in inventory"""
app.inventory_tree.selection_remove(app.inventory_tree.selection())
    
    def update_inventory_status(self, new_status):
"""Update status of selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to update")
    return
skus = [app.inventory_tree.item(item, "values")[0] for item in selected]
try:
    with app.db.get_connection() as conn:
        placeholders = ",".join("?" * len(skus))
        sql = f"UPDATE inventory SET status = ?, last_modified = ? WHERE sku IN ({placeholders})"
        params = [new_status, datetime.datetime.now(datetime.timezone.utc).isoformat()] + skus
        conn.cursor().execute(sql, params)
    app.populate_inventory_view()
    app.append_log(f"Updated {len(skus)} item(s) to '{new_status}'", "green")
except Exception as e:
    logger.error(f"Failed to update status: {e}")
    messagebox.showerror("Error", f"Failed to update status: {e}")
    
    def on_inventory_selection(self, event=None):
"""Handle inventory selection change"""
selected = app.inventory_tree.selection()
state = "normal" if selected else "disabled"

# Update all publishing buttons based on selection and connection status
app.publish_ebay_btn.config(state=state)

# Discogs buttons - only enable if connected
discogs_state = state if (state == "normal" and app.discogs_api.is_connected()) else "disabled"
app.publish_discogs_btn.config(state=discogs_state)
try:
    app.publish_discogs_live_btn.config(state=discogs_state)
except AttributeError:
    pass

# Enable/disable the utility buttons based on selection
try:
    app.open_in_browser_btn.config(state=state)
except Exception:
    pass

    def create_or_update_offer(self, listing_data: dict):
"""
Step 2: Common offer creation/update logic extracted.
Returns: dict with at least { 'success': bool, 'offerId': optional, 'error': optional }.
For now, delegates to the existing publish_to_ebay logic so behavior is unchanged.
"""
if globals().get("PUBLISH_HARD_BLOCK"):
    app.append_log("[publish] BLOCKED BY FLAG", "orange")
    return {"success": False, "error": "Blocked"}
# Draft creation/update is no longer supported in this version.  To
# publish a listing on eBay, first save the item to your Inventory and
# then use the "Publish Live to eBay" button on the Inventory tab.  We
# return an informative error here to avoid unexpected calls.
return {
    "success": False,
    "error": "Draft listing functionality has been removed. Please add the item to your Inventory and publish from there."
}
    
    def publish_to_ebay(self):
"""Publish selected items from inventory to eBay, including images."""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items from the inventory to publish.")
    return

app.notebook.select(app.inventory_tab) # Switch to see logs

def publish_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        app.append_log(f"SKU {sku}: Starting publish process for eBay...", "black")

        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            # Latest-wins check: warn if remote eBay data is newer than local
            try:
                local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
                remote_ts = record.get("ebay_updated_at")
                proceed = True
                if remote_ts and local_ts:
                    try:
                        ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                        rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                        if rdt > ldt:
                            msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                                   f"Local updated: {ldt.isoformat()}\n"
                                   f"eBay updated: {rdt.isoformat()}\n\n"
                                   "Proceeding will overwrite eBay with local data. Continue?")
                            proceed = messagebox.askyesno("Potential Conflict", msg)
                    except Exception:
                        pass
                if not proceed:
                    app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                    continue
            except Exception:
                pass

            # Ensure categoryId is set before validation; use default if missing
            try:
                if not record.get("categoryId") and not record.get("category_id"):
                    fmt = record.get("format", "LP") or "LP"
                    record = dict(record)
                    record["categoryId"] = EBAY_VINYL_CATEGORIES.get(fmt, "176985")
            except Exception:
                pass
            errors = validate_listing("ebay", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: Validation failed: {', '.join(errors)}", "red")
                continue

            # --- Listing Creation with Correct Condition ---
            format_val = record.get("format", "LP")
            media_cond_str = record.get("media_condition", "")

            # Map media grade to eBay enums/IDs. Use a conservative fallback:
            # for unknown grades default to USED_GOOD (enum) and a numeric
            # ID of 3000. The numeric ID will not be sent for records.
            condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
            condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
            category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

            listing_data = {
                "sku": sku,
                "title": record.get("listing_title") or record.get("title", "")[:80],
                "description": record.get("description", ""),
                "price": record.get("price", 0),
                "quantity": 1,
                "categoryId": category_id,
                "condition_enum": condition_enum,
                "condition_id_numeric": condition_id_numeric,
                "media_condition": record.get("media_condition"),
                "sleeve_condition": record.get("sleeve_condition"),
                "images": record.get("images", []),
                "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
                "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
                "returnPolicyId": app.config.get("ebay_return_policy_id"),
                "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
                "currency": "GBP"
            }

            result = app.ebay_api.create_draft_listing(listing_data)
            if result.get("success"):
                offer_id = result.get('offerId')
                app.append_log(f"SKU {sku}: Successfully created eBay draft (Offer ID: {offer_id})", "green")
                # Write back ID and timestamp
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?",
                            (offer_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with eBay listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save eBay Offer ID to local DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: eBay listing failed: {result.get('error')}", "red")

        except Exception as e:
            app.append_log(f"SKU {sku}: An unexpected error occurred: {e}", "red")
            logger.error(f"Error publishing SKU {sku} to eBay", exc_info=True)
    
    app.safe_after(0, app.populate_inventory_view)
    app.safe_after(0, lambda: app.root.config(cursor=""))

app.root.config(cursor="watch")
app.root.update()
threading.Thread(target=publish_worker, daemon=True).start()

    def publish_to_discogs(self):
"""Publish selected items to Discogs"""
selected = app.inventory_tree.selection()
if not selected: return
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue
        # Latest-wins check: warn if Discogs data is newer
        try:
            local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
            remote_ts = record.get("discogs_updated_at")
            proceed = True
            if remote_ts and local_ts:
                try:
                    ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                    rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                    if rdt > ldt:
                        msg = (f"SKU {sku}: The Discogs data was updated more recently than your local copy.\n"
                               f"Local updated: {ldt.isoformat()}\n"
                               f"Discogs updated: {rdt.isoformat()}\n\n"
                               "Proceeding will overwrite Discogs with local data. Continue?")
                        proceed = messagebox.askyesno("Potential Conflict", msg)
                except Exception:
                    pass
            if not proceed:
                app.append_log(f"SKU {sku}: Skipped due to newer Discogs data.", "orange")
                continue
        except Exception:
            pass

        errors = validate_listing("discogs", record, app.config)
        if errors:
            app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
            continue
        app.append_log(f"Publishing SKU {sku} to Discogs...", "black")
        listing_data = {
            "release_id": record.get("discogs_release_id"),
            "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
            "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
            "price": record.get("price", 0), "status": "Draft", "comments": record.get("description", "")
        }
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.append_log(f"SKU {sku}: Listed as Draft (ID: {listing_id})", "green")
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                        (listing_id, now_iso, sku),
                    )
            except Exception as e:
                logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
        else:
            app.append_log(f"SKU {sku}: Failed to create listing", "red")
    except Exception as e:
        app.append_log(f"SKU {sku}: Error - {e}", "red")

    def save_to_ebay_drafts_inventory(self):
"""
Create a Sell Listings draft for each selected inventory item. This is a safe operation
that does not publish the listing live. The returned draft ID and update timestamp
are saved back to the database.
"""
if globals().get("PUBLISH_HARD_BLOCK"):
    app.append_log("[draft] BLOCKED BY FLAG", "orange")
    return
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items from the inventory to save drafts.")
    return

# Switch to inventory tab to display logs
app.notebook.select(app.inventory_tab)

def draft_worker():
    # Force the eBay API wrapper to refresh the access token on each
    # draft creation. This ensures that any newly added scopes (e.g.
    # sell.listing) are included in the token. Without this, the
    # cached access token may not contain the required scope and
    # draft creation can fail silently.
    try:
        app.ebay_api.access_token = None
    except Exception:
        pass
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue

            # Check latest-wins management: warn if remote data is newer than local
            try:
                local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
                remote_ts = record.get("ebay_updated_at")
                proceed = True
                if remote_ts and local_ts:
                    try:
                        ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                        rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                        if rdt > ldt:
                            msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                                   f"Local updated: {ldt.isoformat()}\n"
                                   f"eBay updated: {rdt.isoformat()}\n\n"
                                   "Proceeding will overwrite eBay with local data. Continue?")
                            proceed = messagebox.askyesno("Potential Conflict", msg)
                    except Exception:
                        pass
                if not proceed:
                    app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                    continue
            except Exception:
                pass

            # Build listing_data similar to publish_to_ebay
            format_val = record.get("format", "LP")
            media_cond_str = record.get("media_condition", "")
            # Map media grade to eBay enums/IDs. Use "USED_GOOD" and 3000 as
            # safe fallbacks for unknown grades. The numeric ID will not be
            # transmitted for the Records category.
            condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
            condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
            category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")
            listing_data = {
                "sku": sku,
                "title": record.get("listing_title") or record.get("title", "")[:80],
                "description": record.get("description", ""),
                "price": record.get("price", 0),
                "quantity": 1,
                "categoryId": category_id,
                "condition_enum": condition_enum,
                "condition_id_numeric": condition_id_numeric,
                "media_condition": record.get("media_condition"),
                "sleeve_condition": record.get("sleeve_condition"),
                "images": record.get("images", []),
                "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
                "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
                "returnPolicyId": app.config.get("ebay_return_policy_id"),
                "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
                "currency": "GBP"
            }
            # Attempt to collect image URLs if necessary
            try:
                # Convert local images to eBay-hosted URLs if none exist
                if not listing_data.get("images") and record.get("image_urls"):
                    listing_data["imageUrls"] = record.get("image_urls")
                else:
                    # Fallback: rely on eBay API wrapper to upload images
                    listing_data["images"] = record.get("images", [])
            except Exception:
                pass

            res = app.ebay_api.create_sell_listing_draft(listing_data)
            if res.get("success"):
                draft_id = res.get("draftId")
                # Write back ID and timestamp
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET ebay_item_draft_id = ?, ebay_updated_at = ? WHERE sku = ?",
                            (draft_id, now_iso, sku),
                        )
                    app.append_log(f"SKU {sku}: eBay draft created (Draft ID: {draft_id}).", "green")
                except Exception as e:
                    app.append_log(f"SKU {sku}: Draft created but failed to save ID to DB: {e}", "red")
            else:
                err = res.get("error") or res.get("body")
                status = res.get("status")
                if status:
                    app.append_log(f"SKU {sku}: Failed to create eBay draft (status {status}): {err}", "red")
                else:
                    app.append_log(f"SKU {sku}: Failed to create eBay draft: {err}", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Unexpected error during draft creation: {e}", "red")

    # Refresh inventory view on the main thread
    app.safe_after(0, lambda: app.populate_inventory_view(app.inventory_search_var.get()))
    app.safe_after(0, lambda: app.root.config(cursor=""))

# Show busy cursor and start background thread
app.root.config(cursor="watch")
app.root.update()
threading.Thread(target=draft_worker, daemon=True).start()

    def open_listing_in_browser(self):
"""
Open the appropriate listing page in the user's default web browser for the selected
inventory item. Priority is given to eBay drafts, then live eBay listings,
then Discogs listings.
"""
selected = app.inventory_tree.focus()
if not selected:
    return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    # Try to open eBay draft if present
    draft_id = record.get("ebay_item_draft_id")
    if draft_id:
        # eBay does not provide direct draft URLs; open drafts overview
        webbrowser.open_new_tab("https://www.ebay.co.uk/sh/lst/drafts")
        return
    live_id = record.get("ebay_listing_id")
    if live_id:
        webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{live_id}")
        return
    discogs_id = record.get("discogs_listing_id")
    if discogs_id:
        webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{discogs_id}")
        return
    messagebox.showinfo("No Listing", "This item does not have any listing IDs yet.")
except Exception as e:
    logger.error(f"Failed to open listing: {e}")
    messagebox.showerror("Error", f"Failed to open listing: {e}")
    
    def append_log(self, message, color="black"):
"""Append message to publish log"""
def do_append():
    timestamp = datetime.datetime.now().strftime("[%H:%M:%S]")
    app.publish_log.config(state="normal")
    app.publish_log.insert("end", f"{timestamp} {message}\n", (color,))
    app.publish_log.tag_configure("red", foreground="red")
    app.publish_log.tag_configure("green", foreground="green")
    app.publish_log.tag_configure("black", foreground="black")
    app.publish_log.see("end")
    app.publish_log.config(state="disabled")
app.safe_after(0, do_append)

    def show_inventory_context_menu(self, event):
"""Show inventory context menu"""
row_id = app.inventory_tree.identify_row(event.y)
if row_id:
    app.inventory_tree.selection_set(row_id)
    app.inventory_tree.focus(row_id)
    app.inventory_context_menu.post(event.x_root, event.y_root)
    
    def show_discogs_context_menu(self, event):
"""Show Discogs results context menu"""
row_id = app.discogs_tree.identify_row(event.y)
if row_id:
    app.discogs_tree.selection_set(row_id)
    app.discogs_tree.focus(row_id)
    app.discogs_context_menu.post(event.x_root, event.y_root)
    
    def open_discogs_listing(self):
"""Open Discogs listing for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("discogs_listing_id"):
        webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{record['discogs_listing_id']}")
    else:
        messagebox.showinfo("No Discogs Listing", "This item has no Discogs listing ID.")
except Exception as e:
    logger.error(f"Failed to open Discogs listing: {e}")
    
    def open_ebay_listing(self):
"""Open eBay listing for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("ebay_listing_id"):
        webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{record['ebay_listing_id']}")
    else:
        messagebox.showinfo("No eBay Listing", "This item has no eBay listing ID.")
except Exception as e:
    logger.error(f"Failed to open eBay listing: {e}")
    
    def open_discogs_release_from_inventory(self):
"""Open Discogs release page for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("discogs_release_id"):
        webbrowser.open_new_tab(f"https://www.discogs.com/release/{record['discogs_release_id']}")
    else:
        messagebox.showinfo("No Release Linked", "This item has no Discogs release ID.")
except Exception as e:
    logger.error(f"Failed to open release page: {e}")
    
    def open_discogs_release_page(self):
"""Open selected release on Discogs website"""
selected = app.discogs_tree.focus()
if not selected: return
release_id = app.discogs_tree.item(selected, "values")[0]
webbrowser.open_new_tab(f"https://www.discogs.com/release/{release_id}")
    
    def open_sold_listings_from_selection(self, platform):
"""Open sold listings search for selected Discogs result"""
selected = app.discogs_tree.focus()
if not selected: return
_, artist, title, catno, _, _, _ = app.discogs_tree.item(selected, "values")
query = f"{artist} {title} {catno}".strip()
url = f"https://www.ebay.co.uk/sch/i.html?_nkw={quote_plus(query)}&_sacat=176985&LH_Sold=1&LH_Complete=1" if platform == "eBay" else f"https://www.discogs.com/search/?q={quote_plus(query)}&type=all"
webbrowser.open_new_tab(url)
    
    def get_price_suggestion(self):
"""Get price suggestions for selected release"""
selected = app.discogs_tree.focus()
if not selected: return
release_id = int(app.discogs_tree.item(selected, "values")[0])
app.root.config(cursor="watch")
app.root.update()
def fetch_worker():
    try:
        suggestions = app.discogs_api.get_price_suggestions(release_id)
        if suggestions:
            msg = "Price Suggestions:\n\n" + "\n".join([f"{condition}: £{price_data['value']:.2f}" for condition, price_data in suggestions.items()])
            app.safe_after(0, lambda: messagebox.showinfo("Price Suggestions", msg))
        else:
            app.safe_after(0, lambda: messagebox.showinfo("No Data", "No price suggestions available"))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=fetch_worker, daemon=True).start()
    
    def refresh_discogs_view(self, event=None):
"""Refresh Discogs results with filter"""
filter_text = app.discogs_search_filter_var.get().lower()
if not app.discogs_search_results: return
for item in app.discogs_tree.get_children(): app.discogs_tree.delete(item)
for result in app.discogs_search_results:
    artist, title = (result.get("title", "").split(" - ", 1) + [""])[:2]
    if filter_text and filter_text not in f"{artist} {title} {result.get('catno', '')} {result.get('year', '')}".lower(): continue
    values = (result.get("id"), artist, title, result.get("catno", "N/A"), result.get("year", "N/A"), result.get("country", "N/A"), ", ".join(result.get("format", [])))
    app.discogs_tree.insert("", "end", values=values)
    
    def sort_discogs_results(self, col):
"""Sort Discogs results by column"""
if app.discogs_sort_column == col:
    app.discogs_sort_direction = "ASC" if app.discogs_sort_direction == "DESC" else "DESC"
else:
    app.discogs_sort_column, app.discogs_sort_direction = col, "ASC"
if app.discogs_search_results:
    def sort_key(item):
        if col == "Artist": return (item.get("title", "").split(" - ", 1) + [""])[0].lower()
        elif col == "Title": return (item.get("title", "").split(" - ", 1) + [""])[1].lower()
        elif col == "Year":
            try: return int(item.get("year", 0))
            except: return 0
        else: return str(item.get(col.lower(), "")).lower()
    app.discogs_search_results.sort(key=sort_key, reverse=(app.discogs_sort_direction == "DESC"))
    app.refresh_discogs_view()
    
    def authenticate_discogs(self):
"""Authenticate with Discogs"""
consumer_key = app.config.get("discogs_consumer_key")
consumer_secret = app.config.get("discogs_consumer_secret")
if not consumer_key or not consumer_secret:
    messagebox.showerror("Configuration Error", "Discogs Consumer Key/Secret not found in config.json.\nPlease add these to your configuration file.")
    return
try:
    client = discogs_client.Client("VinylListingTool/5.1", consumer_key=consumer_key, consumer_secret=consumer_secret)
    token, secret, url = client.get_authorize_url()
    webbrowser.open(url)
    pin = simpledialog.askstring("Discogs Authentication", "Please enter the verification code from Discogs:")
    if not pin: return
    access_token, access_secret = client.get_access_token(pin)
    app.config.save({"discogs_oauth_token": access_token, "discogs_oauth_token_secret": access_secret})
    app.discogs_api = DiscogsAPI(app.config)
    if app.discogs_api.is_connected():
        app._update_connection_status()
        messagebox.showinfo("Success", "Successfully connected to Discogs!")
    else:
        messagebox.showerror("Error", "Failed to connect to Discogs")
except Exception as e:
    logger.error(f"Discogs authentication failed: {e}")
    messagebox.showerror("Authentication Error", str(e))
    
    def test_ebay_connection(self):
"""Test eBay connection"""
if app.ebay_api.test_connection():
    app.ebay_auth_status_var.set("Connected")
    messagebox.showinfo("Success", "Successfully connected to eBay!")
else:
    app.ebay_auth_status_var.set("Not Connected")
    messagebox.showerror("Connection Failed", "Could not connect to eBay.\nPlease check your credentials in config.json")
    
    def check_discogs_sales(self):
"""Check for Discogs sales"""
if not app.discogs_api.is_connected(): return
app.root.config(cursor="watch"); app.root.update()
def sales_worker():
    try:
        orders = app.discogs_api.get_orders(['Payment Received', 'Shipped'])
        app.safe_after(0, lambda: app._display_discogs_sales(orders))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_discogs_sales(self, orders):
"""Display Discogs sales"""
for item in app.sales_tree.get_children(): app.sales_tree.delete(item)
if not orders:
    messagebox.showinfo("No Sales", "No sales with status 'Payment Received' or 'Shipped' found.")
    return
for order in orders:
    for item in order.items:
        artist = item.release.artists[0].name if item.release.artists else "Various"
        title = item.release.title.replace(f"{artist} - ", "", 1).strip()
        sale_date = datetime.datetime.strptime(order.data['created'][:10], "%Y-%m-%d").strftime("%d-%m-%Y")
        sale_price = f"{item.price.value} {item.price.currency}"
        values = (order.id, sale_date, order.buyer.username, artist, title, sale_price, item.release.id)
        app.sales_tree.insert("", "end", values=values)
    
    def sync_discogs_sale(self):
"""Sync selected Discogs sale to inventory"""
selected = app.sales_tree.focus()
if not selected: return
release_id = app.sales_tree.item(selected, "values")[6]
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku FROM inventory WHERE discogs_release_id = ? AND status = 'For Sale'", (release_id,))
        record = cursor.fetchone()
        if record:
            sku = record[0]
            if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
                app.update_inventory_status("Sold")
                messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
        else:
            messagebox.showwarning("No Match", f"Could not find an unsold item with Release ID: {release_id}.")
except Exception as e:
    logger.error(f"Failed to sync sale: {e}")
    messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def check_ebay_sales(self):
"""Check for eBay sales"""
if not app.ebay_api.test_connection(): return
try:
    start_date = datetime.datetime.strptime(app.ebay_start_date_var.get(), "%d-%m-%Y")
    end_date = datetime.datetime.strptime(app.ebay_end_date_var.get(), "%d-%m-%Y")
    if (end_date - start_date).days > 30:
        messagebox.showerror("Date Range Error", "The date range cannot exceed 30 days.")
        return
except ValueError:
    messagebox.showerror("Date Format Error", "Please enter dates in DD-MM-YYYY format.")
    return
app.root.config(cursor="watch"); app.root.update()
def sales_worker():
    try:
        orders = app.ebay_api.get_orders(start_date, end_date)
        app.safe_after(0, lambda: app._display_ebay_sales(orders))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_ebay_sales(self, orders):
"""Display eBay sales"""
for item in app.ebay_sales_tree.get_children(): app.ebay_sales_tree.delete(item)
if not orders:
    messagebox.showinfo("No eBay Sales", "No completed sales found in the specified date range.")
    return
for order in orders:
    order_id, created_date, buyer = order.get("orderId"), order.get("creationDate", "")[:10], order.get("buyer", {}).get("username", "")
    for line_item in order.get("lineItems", []):
        title, price, currency, item_id = line_item.get("title", ""), line_item.get("lineItemCost", {}).get("value", ""), line_item.get("lineItemCost", {}).get("currency", "GBP"), line_item.get("legacyItemId", "")
        artist, album_title = "", title
        if ":" in title:
            parts = title.split(":", 1)
            artist, album_title = parts[0].strip(), parts[1].strip()
        values = (order_id, created_date, buyer, artist, album_title, f"{price} {currency}", item_id)
        app.ebay_sales_tree.insert("", "end", values=values)
    
    def sync_ebay_sale(self):
"""Sync selected eBay sale to inventory"""
selected = app.ebay_sales_tree.focus()
if not selected: return
_, _, _, artist, title, _, item_id = app.ebay_sales_tree.item(selected, "values")
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku FROM inventory WHERE (ebay_listing_id = ? OR (artist LIKE ? AND title LIKE ?)) AND status = 'For Sale'", (item_id, f"%{artist}%", f"%{title}%"))
        record = cursor.fetchone()
        if record:
            sku = record[0]
            if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
                app.update_inventory_status("Sold")
                messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
        else:
            messagebox.showwarning("No Match", f"Could not find an unsold item matching:\n{artist} - {title}")
except Exception as e:
    logger.error(f"Failed to sync sale: {e}")
    messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def start_discogs_import(self):
"""Import inventory from Discogs"""
if not app.discogs_api.is_connected(): return
if not messagebox.askyesno("Confirm Import", "This will import all 'For Sale' items from Discogs.\nExisting items will be skipped.\n\nContinue?"): return
app.root.config(cursor="watch"); app.root.update()
def import_worker():
    try:
        inventory = app.discogs_api.get_inventory()
        app.safe_after(0, lambda: app._process_discogs_import(inventory))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Import Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=import_worker, daemon=True).start()
    
    def _process_discogs_import(self, inventory):
"""Process Discogs import"""
new_items, skipped_items = 0, 0
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        for listing in inventory:
            if listing.status != 'For Sale': continue
            cursor.execute("SELECT COUNT(*) FROM inventory WHERE discogs_listing_id = ?", (listing.id,))
            if cursor.fetchone()[0] > 0:
                skipped_items += 1
                continue
            new_items += 1
            artist = listing.release.artists[0].name if listing.release.artists else "Various"
            title = listing.release.title.replace(f"{artist} - ", "", 1).strip()
            sku = datetime.datetime.now().strftime(f"%Y%m%d-%H%M%S-{new_items}")
            now = datetime.datetime.now(datetime.timezone.utc).isoformat()
            sql = """INSERT INTO inventory (sku, artist, title, cat_no, media_condition, sleeve_condition, price, status, discogs_release_id, discogs_listing_id, date_added, last_modified) 
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"""
            media_cond = DISCOGS_GRADE_MAP.get(listing.condition, listing.condition)
            sleeve_cond = DISCOGS_GRADE_MAP.get(listing.sleeve_condition, listing.sleeve_condition)
            catno = getattr(listing.release, 'catno', '')
            cursor.execute(sql, (sku, artist, title, catno, media_cond, sleeve_cond, listing.price.value, "For Sale", listing.release.id, listing.id, now, now))
    messagebox.showinfo("Import Complete", f"Successfully imported {new_items} new item(s).\nSkipped {skipped_items} existing item(s).")
    app.populate_inventory_view()
except Exception as e:
    logger.error(f"Import failed: {e}")
    messagebox.showerror("Import Error", f"An error occurred during import:\n{e}")
    
    def toggle_auto_sync(self):
"""Toggle automatic sync"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
    app.auto_sync_var.set(False)
    return
app.auto_sync_enabled = app.auto_sync_var.get()
app.config.save({"auto_sync_enabled": app.auto_sync_enabled})
if app.auto_sync_enabled: app.start_auto_sync()
else: app.stop_auto_sync()
    
    def toggle_two_way_sync(self):
"""Toggle two-way sync"""
app.two_way_sync_enabled = app.two_way_sync_var.get()
app.config.save({"two_way_sync_enabled": app.two_way_sync_enabled})
app.log_sync_activity(f"Two-way sync {'enabled' if app.two_way_sync_enabled else 'disabled'}")
    
    def toggle_attempt_updates(self):
"""Toggle attempt to update Discogs"""
app.attempt_discogs_updates = app.attempt_updates_var.get()
app.config.save({"attempt_discogs_updates": app.attempt_discogs_updates})
app.log_sync_activity(f"Discogs update attempts {'enabled' if app.attempt_discogs_updates else 'disabled'}")
    
    def update_sync_interval(self):
"""Update sync interval"""
try:
    minutes = int(app.sync_interval_var.get())
    app.auto_sync_interval = minutes * 60
    app.config.save({"auto_sync_interval": app.auto_sync_interval})
    app.log_sync_activity(f"Sync interval set to {minutes} minutes")
except ValueError: app.sync_interval_var.set("5")
    
    def start_auto_sync(self):
"""Start automatic sync"""
if app.auto_sync_thread and app.auto_sync_thread.is_alive(): return
app.auto_sync_stop_event.clear()
app.auto_sync_thread = threading.Thread(target=app._auto_sync_worker, daemon=True)
app.auto_sync_thread.start()
app.sync_status_var.set("Auto-sync enabled - waiting for next sync...")
app.log_sync_activity("Automatic sync started")
    
    def stop_auto_sync(self):
"""Stop automatic sync"""
app.auto_sync_stop_event.set()
app.sync_status_var.set("Auto-sync disabled")
app.log_sync_activity("Automatic sync stopped")
    
    def _auto_sync_worker(self):
"""Auto sync worker thread"""
while not app.auto_sync_stop_event.is_set():
    try:
        if app.auto_sync_stop_event.wait(app.auto_sync_interval): break
        if app.auto_sync_enabled and app.discogs_api.is_connected():
            app.safe_after(0, lambda: app.sync_status_var.set("Syncing inventory..."))
            sync_result = app._perform_inventory_sync()
            app.safe_after(0, lambda r=sync_result: app._handle_sync_result(r))
    except Exception as e:
        app.safe_after(0, lambda msg=f"Auto-sync error: {e}": app.log_sync_activity(msg))
    
    def manual_sync_now(self):
"""Perform manual sync now"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
    return
app.sync_status_var.set("Manual sync in progress...")
app.root.config(cursor="watch"); app.root.update()
def sync_worker():
    try:
        result = app._perform_inventory_sync()
        app.safe_after(0, lambda: app._handle_sync_result(result))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Sync Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sync_worker, daemon=True).start()
    
    def _perform_inventory_sync(self):
"""Implements true "latest-wins" two-way sync logic."""
sync_start_time = datetime.datetime.now(datetime.timezone.utc)
app.log_sync_activity("=== STARTING SYNC (Latest-Wins) ===")
try:
    discogs_inventory = app.discogs_api.get_inventory()
    discogs_map = {listing.id: listing for listing in discogs_inventory}
    app.log_sync_activity(f"Retrieved {len(discogs_inventory)} active listings from Discogs.")

    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku, discogs_listing_id, price, status, notes, last_modified, last_sync_time FROM inventory WHERE discogs_listing_id IS NOT NULL")
        local_items = [dict(row) for row in cursor.fetchall()]
        local_map = {item['discogs_listing_id']: item for item in local_items}
    app.log_sync_activity(f"Found {len(local_map)} linked local items.")

    updates_to_local, updates_to_discogs, deletions_from_local, new_sales = 0, 0, 0, 0
    
    for local_item in local_items:
        listing_id, last_mod_local_str, last_sync_str = local_item['discogs_listing_id'], local_item.get('last_modified'), app.last_successful_sync_time or local_item.get('last_sync_time')
        if not last_mod_local_str or not last_sync_str: continue
        try:
            last_mod_local, last_sync = datetime.datetime.fromisoformat(last_mod_local_str), datetime.datetime.fromisoformat(last_sync_str)
        except (ValueError, TypeError): continue

        if last_mod_local > last_sync and app.attempt_discogs_updates:
            if listing_id in discogs_map:
                app.log_sync_activity(f"→ Local change detected for SKU {local_item['sku']}. Pushing to Discogs.")
                update_payload = {"price": local_item['price'], "status": app._map_local_to_discogs_status(local_item['status']), "comments": local_item.get('notes', '')}
                if app.discogs_api.update_listing(listing_id, update_payload):
                    updates_to_discogs += 1; app.log_sync_activity(f"  ✓ Pushed update for SKU {local_item['sku']} to Discogs.")
                else: app.log_sync_activity(f"  ✗ Failed to push update for SKU {local_item['sku']}.")
            else: app.log_sync_activity(f"  - SKU {local_item['sku']} changed locally but no longer on Discogs. Skipping push.")

        elif listing_id in discogs_map:
            listing = discogs_map[listing_id]
            mapped_status = app.status_mappings.get(listing.status, "Not For Sale")
            if mapped_status != local_item['status']:
                with app.db.get_connection() as conn:
                    conn.cursor().execute("UPDATE inventory SET status = ?, last_modified = ? WHERE discogs_listing_id = ?", (mapped_status, sync_start_time.isoformat(), listing_id))
                updates_to_local += 1
                if mapped_status == 'Sold' and local_item['status'] != 'Sold': new_sales += 1
                app.log_sync_activity(f"✓ Sync from Discogs: SKU {local_item['sku']} '{local_item['status']}' → '{mapped_status}'")

    ids_to_delete_locally = set(local_map.keys()) - set(discogs_map.keys())
    if ids_to_delete_locally:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            for listing_id in ids_to_delete_locally:
                if local_map[listing_id]['status'] == 'For Sale':
                    sku = local_map[listing_id]['sku']
                    cursor.execute("DELETE FROM inventory WHERE discogs_listing_id = ?", (listing_id,))
                    deletions_from_local += 1
                    app.log_sync_activity(f"✓ Deleted SKU {sku} locally as it's no longer on Discogs.")
    
    with app.db.get_connection() as conn:
        conn.cursor().execute("UPDATE inventory SET last_sync_time = ? WHERE discogs_listing_id IS NOT NULL", (sync_start_time.isoformat(),))
    app.last_successful_sync_time = sync_start_time.isoformat()
    app.config.save({"last_successful_sync_time": app.last_successful_sync_time})
    if updates_to_local > 0 or deletions_from_local > 0: app.safe_after(0, app.populate_inventory_view)
    app.log_sync_activity("=== SYNC COMPLETED ===")
    return {'success': True, 'updates_local': updates_to_local, 'updates_discogs': updates_to_discogs, 'deletions': deletions_from_local, 'new_sales': new_sales, 'total_checked': len(discogs_inventory)}
except Exception as e:
    logger.error(f"Sync failed: {e}", exc_info=True)
    app.log_sync_activity(f"✗ SYNC ERROR: {e}")
    return {'success': False, 'error': str(e)}

    def _map_local_to_discogs_status(self, local_status):
"""Map local status to valid Discogs status"""
return {'For Sale': 'For Sale', 'Sold': 'Sold'}.get(local_status, 'Draft')
    
    def _handle_sync_result(self, result):
"""Handle sync result"""
current_time = datetime.datetime.now().strftime("%H:%M:%S")
if result.get('success'):
    updates_local, updates_discogs, deletions = result.get('updates_local', 0), result.get('updates_discogs', 0), result.get('deletions', 0)
    total_changes = updates_local + updates_discogs + deletions
    if total_changes > 0:
        log_msg = f"[{current_time}] Sync completed: {total_changes} changes from {result['total_checked']} listings"
        if updates_local > 0: log_msg += f"\n  - Pulled from Discogs: {updates_local}"
        if updates_discogs > 0: log_msg += f"\n  - Pushed to Discogs: {updates_discogs}"
        if deletions > 0: log_msg += f"\n  - Items deleted locally: {deletions}"
        if result.get('new_sales', 0) > 0: log_msg += f"\n  - New sales detected: {result['new_sales']}"
        app.log_sync_activity(log_msg)
        status_msg = f"Sync complete - {total_changes} change(s)"
    else:
        status_msg = "Sync complete - no changes needed"
        app.log_sync_activity(f"[{current_time}] Sync completed. No changes needed.")
    app.sync_status_var.set(f"Last sync: {current_time}. {status_msg}")
else:
    app.sync_status_var.set(f"Last sync: {current_time}. FAILED.")
    app.log_sync_activity(f"[{current_time}] Sync FAILED: {result.get('error')}")

    # ========================================================================
    # ENHANCED PUBLISHING ACTION METHODS
    # ========================================================================
    
    def action_ebay_save_unpublished(self):
"""Save eBay listing data locally as 'ready to publish' without sending to eBay"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - save current form
    app._save_ebay_draft_from_lister()
else:
    # From Inventory tab - mark selected items as ready for eBay
    app._save_ebay_draft_from_inventory()

    def action_ebay_publish_live(self):
"""Publish directly to eBay as live listings (Inventory API)"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - publish current form directly
    app.list_on_ebay()
else:
    # From Inventory tab - publish selected items
    app.publish_to_ebay()



    def reconcile_from_ebay(self, skus):


"""Pull eBay state back into local DB so deletions/ends/relists are reflected.


Chooses ACTIVE offer. Prefers Item ID (listingId); falls back to offerId if listingId hasn't propagated yet.


Refreshes the grid when done.


"""


import datetime, logging, requests


logger = logging.getLogger(__name__)


    


token = app.ebay_api.get_access_token()


if not token:


    app.append_log("Cannot reconcile: missing eBay token", "red")


    return


    


headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}


changed = False


    


for sku in (skus or []):


    try:


        url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={sku}"


        r = requests.get(url, headers=headers, timeout=30)


        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()


    


        if r.status_code == 200 and r.json().get("offers"):


            offers = r.json()["offers"]


            # Pick ACTIVE offer if available; otherwise first one


            active = None


            for o in offers:


                if (o.get("status") or "").upper() == "ACTIVE":


                    active = o


                    break


            offer = active or offers[0]


            status = (offer.get("status") or "").upper()


    


            listing_id = offer.get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('legacyItemId') or (offer.get('listing') or {}).get('listingId')


            offer_id = offer.get("offerId") or (offer.get("offer") or {}).get("offerId")


    


            # If ACTIVE but listingId missing, try GET /offer/{offerId} to resolve


            if status in ("ACTIVE","PUBLISHED") and not listing_id and offer_id:


                try:


                    resolved = app.ebay_api.get_offer(str(offer_id))


                    if resolved.get("success"):


                        listing_id = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')


                except Exception as e:


                    logger.warning(f"[reconcile] get_offer failed for offer {offer_id}: {e}")


    


            with app.db.get_connection() as conn:


                c = conn.cursor()


                if status in ("ACTIVE","PUBLISHED"):


                    stored_id = listing_id or (offer_id if offer_id else None)


                    if stored_id:


                        c.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))


                        changed = True


                    else:


                        c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                        changed = True


                else:


                    c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                    changed = True


    


            shown = listing_id or (offer_id if (status in ("ACTIVE","PUBLISHED") and offer_id) else "—")


            label = "Item ID" if listing_id else ("Offer ID" if shown != "—" else "—")  # live


            app.append_log(f"SKU {sku}: reconciled from eBay ({status}; {label}={shown})", "blue")


        else:


            with app.db.get_connection() as conn:


                c = conn.cursor()


                c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


            changed = True


            app.append_log(f"SKU {sku}: no eBay offer found; cleared local mapping.", "orange")


    


    except Exception as e:


        logger.error(f"Reconcile error for {sku}: {e}")


        app.append_log(f"SKU {sku}: reconcile failed: {e}", "red")


    


if changed:


    try:


        app.populate_inventory_view()


    except Exception:


        pass



    def action_open_on_ebay_selected(self):



"""Open the selected item's eBay listing in the browser using stored Item ID."""



import webbrowser, requests, logging



logger = logging.getLogger(__name__)



items = app.inventory_tree.selection()



if not items:



    try:



        messagebox.showinfo("Open on eBay", "Please select a row first.")



    except Exception:



        pass



    return



iid = items[0]



vals = app.inventory_tree.item(iid, "values") or []



item_id = None



# Try visible column first



try:



    headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



    if "eBay ID" in headers:



        idx = headers.index("eBay ID")



        if idx < len(vals):



            item_id = vals[idx]



except Exception:



    item_id = None



# Fallback: DB lookup by SKU (assumes SKU in first column)



if not item_id and vals:



    sku = vals[0]



    try:



        with app.db.get_connection() as conn:



            c = conn.cursor()



            c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



            row = c.fetchone()



            if row and row[0]:



                item_id = row[0]



    except Exception:



        pass



if not item_id:



    try:



        messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



    except Exception:



        pass



    return



# If it's likely an offerId, try resolve to listingId on the fly



if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



    try:



        token = app.ebay_api.get_access_token()



        if token:



            headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



            url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



            r = requests.get(url, headers=headers, timeout=30)



            if r.status_code == 200 and r.json().get("offers"):



                offers = r.json()["offers"]



                active = None



                for o in offers:



                    if (o.get("status") or "").upper() == "ACTIVE":



                        active = o



                        break



                off = active or offers[0]



                lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



                if not lid:



                    oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                    if oid:



                        resolved = app.ebay_api.get_offer(str(oid))



                        if resolved.get("success"):



                            lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



                if lid:



                    item_id = lid



    except Exception as e:



        logger.warning(f"[open] resolution failed: {e}")



try:



    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



except Exception:



    try:



        messagebox.showerror("Open on eBay", "Failed to open browser.")



    except Exception:



        pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




try:




    offers = app._fetch_all_ebay_offers()




except Exception as e:




    messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




    return




work = []




with app.db.get_connection() as conn:




    c = conn.cursor()




    for off in offers:




        sku = (off.get("sku") or "").strip()




        if not sku:




            continue




        c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




        row = c.fetchone()




        if not row or not row[0]:




            work.append(off)




if not work:




    messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




    return




app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def save_to_ebay_drafts_inventory(app):
"""
Create a Sell Listings draft for each selected inventory item. This is a safe operation
that does not publish the listing live. The returned draft ID and update timestamp
are saved back to the database.
"""
if globals().get("PUBLISH_HARD_BLOCK"):
    app.append_log("[draft] BLOCKED BY FLAG", "orange")
    return
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items from the inventory to save drafts.")
    return

# Switch to inventory tab to display logs
app.notebook.select(app.inventory_tab)

def draft_worker():
    # Force the eBay API wrapper to refresh the access token on each
    # draft creation. This ensures that any newly added scopes (e.g.
    # sell.listing) are included in the token. Without this, the
    # cached access token may not contain the required scope and
    # draft creation can fail silently.
    try:
        app.ebay_api.access_token = None
    except Exception:
        pass
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue

            # Check latest-wins management: warn if remote data is newer than local
            try:
                local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
                remote_ts = record.get("ebay_updated_at")
                proceed = True
                if remote_ts and local_ts:
                    try:
                        ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                        rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                        if rdt > ldt:
                            msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                                   f"Local updated: {ldt.isoformat()}\n"
                                   f"eBay updated: {rdt.isoformat()}\n\n"
                                   "Proceeding will overwrite eBay with local data. Continue?")
                            proceed = messagebox.askyesno("Potential Conflict", msg)
                    except Exception:
                        pass
                if not proceed:
                    app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                    continue
            except Exception:
                pass

            # Build listing_data similar to publish_to_ebay
            format_val = record.get("format", "LP")
            media_cond_str = record.get("media_condition", "")
            # Map media grade to eBay enums/IDs. Use "USED_GOOD" and 3000 as
            # safe fallbacks for unknown grades. The numeric ID will not be
            # transmitted for the Records category.
            condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
            condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
            category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")
            listing_data = {
                "sku": sku,
                "title": record.get("listing_title") or record.get("title", "")[:80],
                "description": record.get("description", ""),
                "price": record.get("price", 0),
                "quantity": 1,
                "categoryId": category_id,
                "condition_enum": condition_enum,
                "condition_id_numeric": condition_id_numeric,
                "media_condition": record.get("media_condition"),
                "sleeve_condition": record.get("sleeve_condition"),
                "images": record.get("images", []),
                "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
                "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
                "returnPolicyId": app.config.get("ebay_return_policy_id"),
                "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
                "currency": "GBP"
            }
            # Attempt to collect image URLs if necessary
            try:
                # Convert local images to eBay-hosted URLs if none exist
                if not listing_data.get("images") and record.get("image_urls"):
                    listing_data["imageUrls"] = record.get("image_urls")
                else:
                    # Fallback: rely on eBay API wrapper to upload images
                    listing_data["images"] = record.get("images", [])
            except Exception:
                pass

            res = app.ebay_api.create_sell_listing_draft(listing_data)
            if res.get("success"):
                draft_id = res.get("draftId")
                # Write back ID and timestamp
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET ebay_item_draft_id = ?, ebay_updated_at = ? WHERE sku = ?",
                            (draft_id, now_iso, sku),
                        )
                    app.append_log(f"SKU {sku}: eBay draft created (Draft ID: {draft_id}).", "green")
                except Exception as e:
                    app.append_log(f"SKU {sku}: Draft created but failed to save ID to DB: {e}", "red")
            else:
                err = res.get("error") or res.get("body")
                status = res.get("status")
                if status:
                    app.append_log(f"SKU {sku}: Failed to create eBay draft (status {status}): {err}", "red")
                else:
                    app.append_log(f"SKU {sku}: Failed to create eBay draft: {err}", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Unexpected error during draft creation: {e}", "red")

    # Refresh inventory view on the main thread
    app.safe_after(0, lambda: app.populate_inventory_view(app.inventory_search_var.get()))
    app.safe_after(0, lambda: app.root.config(cursor=""))

# Show busy cursor and start background thread
app.root.config(cursor="watch")
app.root.update()
threading.Thread(target=draft_worker, daemon=True).start()

    def open_listing_in_browser(self):
"""
Open the appropriate listing page in the user's default web browser for the selected
inventory item. Priority is given to eBay drafts, then live eBay listings,
then Discogs listings.
"""
selected = app.inventory_tree.focus()
if not selected:
    return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    # Try to open eBay draft if present
    draft_id = record.get("ebay_item_draft_id")
    if draft_id:
        # eBay does not provide direct draft URLs; open drafts overview
        webbrowser.open_new_tab("https://www.ebay.co.uk/sh/lst/drafts")
        return
    live_id = record.get("ebay_listing_id")
    if live_id:
        webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{live_id}")
        return
    discogs_id = record.get("discogs_listing_id")
    if discogs_id:
        webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{discogs_id}")
        return
    messagebox.showinfo("No Listing", "This item does not have any listing IDs yet.")
except Exception as e:
    logger.error(f"Failed to open listing: {e}")
    messagebox.showerror("Error", f"Failed to open listing: {e}")
    
    def append_log(self, message, color="black"):
"""Append message to publish log"""
def do_append():
    timestamp = datetime.datetime.now().strftime("[%H:%M:%S]")
    app.publish_log.config(state="normal")
    app.publish_log.insert("end", f"{timestamp} {message}\n", (color,))
    app.publish_log.tag_configure("red", foreground="red")
    app.publish_log.tag_configure("green", foreground="green")
    app.publish_log.tag_configure("black", foreground="black")
    app.publish_log.see("end")
    app.publish_log.config(state="disabled")
app.safe_after(0, do_append)

    def show_inventory_context_menu(self, event):
"""Show inventory context menu"""
row_id = app.inventory_tree.identify_row(event.y)
if row_id:
    app.inventory_tree.selection_set(row_id)
    app.inventory_tree.focus(row_id)
    app.inventory_context_menu.post(event.x_root, event.y_root)
    
    def show_discogs_context_menu(self, event):
"""Show Discogs results context menu"""
row_id = app.discogs_tree.identify_row(event.y)
if row_id:
    app.discogs_tree.selection_set(row_id)
    app.discogs_tree.focus(row_id)
    app.discogs_context_menu.post(event.x_root, event.y_root)
    
    def open_discogs_listing(self):
"""Open Discogs listing for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("discogs_listing_id"):
        webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{record['discogs_listing_id']}")
    else:
        messagebox.showinfo("No Discogs Listing", "This item has no Discogs listing ID.")
except Exception as e:
    logger.error(f"Failed to open Discogs listing: {e}")
    
    def open_ebay_listing(self):
"""Open eBay listing for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("ebay_listing_id"):
        webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{record['ebay_listing_id']}")
    else:
        messagebox.showinfo("No eBay Listing", "This item has no eBay listing ID.")
except Exception as e:
    logger.error(f"Failed to open eBay listing: {e}")
    
    def open_discogs_release_from_inventory(self):
"""Open Discogs release page for selected inventory item"""
selected = app.inventory_tree.focus()
if not selected: return
sku = app.inventory_tree.item(selected, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if record.get("discogs_release_id"):
        webbrowser.open_new_tab(f"https://www.discogs.com/release/{record['discogs_release_id']}")
    else:
        messagebox.showinfo("No Release Linked", "This item has no Discogs release ID.")
except Exception as e:
    logger.error(f"Failed to open release page: {e}")
    
    def open_discogs_release_page(self):
"""Open selected release on Discogs website"""
selected = app.discogs_tree.focus()
if not selected: return
release_id = app.discogs_tree.item(selected, "values")[0]
webbrowser.open_new_tab(f"https://www.discogs.com/release/{release_id}")
    
    def open_sold_listings_from_selection(self, platform):
"""Open sold listings search for selected Discogs result"""
selected = app.discogs_tree.focus()
if not selected: return
_, artist, title, catno, _, _, _ = app.discogs_tree.item(selected, "values")
query = f"{artist} {title} {catno}".strip()
url = f"https://www.ebay.co.uk/sch/i.html?_nkw={quote_plus(query)}&_sacat=176985&LH_Sold=1&LH_Complete=1" if platform == "eBay" else f"https://www.discogs.com/search/?q={quote_plus(query)}&type=all"
webbrowser.open_new_tab(url)
    
    def get_price_suggestion(self):
"""Get price suggestions for selected release"""
selected = app.discogs_tree.focus()
if not selected: return
release_id = int(app.discogs_tree.item(selected, "values")[0])
app.root.config(cursor="watch")
app.root.update()
def fetch_worker():
    try:
        suggestions = app.discogs_api.get_price_suggestions(release_id)
        if suggestions:
            msg = "Price Suggestions:\n\n" + "\n".join([f"{condition}: £{price_data['value']:.2f}" for condition, price_data in suggestions.items()])
            app.safe_after(0, lambda: messagebox.showinfo("Price Suggestions", msg))
        else:
            app.safe_after(0, lambda: messagebox.showinfo("No Data", "No price suggestions available"))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=fetch_worker, daemon=True).start()
    
    def refresh_discogs_view(self, event=None):
"""Refresh Discogs results with filter"""
filter_text = app.discogs_search_filter_var.get().lower()
if not app.discogs_search_results: return
for item in app.discogs_tree.get_children(): app.discogs_tree.delete(item)
for result in app.discogs_search_results:
    artist, title = (result.get("title", "").split(" - ", 1) + [""])[:2]
    if filter_text and filter_text not in f"{artist} {title} {result.get('catno', '')} {result.get('year', '')}".lower(): continue
    values = (result.get("id"), artist, title, result.get("catno", "N/A"), result.get("year", "N/A"), result.get("country", "N/A"), ", ".join(result.get("format", [])))
    app.discogs_tree.insert("", "end", values=values)
    
    def sort_discogs_results(self, col):
"""Sort Discogs results by column"""
if app.discogs_sort_column == col:
    app.discogs_sort_direction = "ASC" if app.discogs_sort_direction == "DESC" else "DESC"
else:
    app.discogs_sort_column, app.discogs_sort_direction = col, "ASC"
if app.discogs_search_results:
    def sort_key(item):
        if col == "Artist": return (item.get("title", "").split(" - ", 1) + [""])[0].lower()
        elif col == "Title": return (item.get("title", "").split(" - ", 1) + [""])[1].lower()
        elif col == "Year":
            try: return int(item.get("year", 0))
            except: return 0
        else: return str(item.get(col.lower(), "")).lower()
    app.discogs_search_results.sort(key=sort_key, reverse=(app.discogs_sort_direction == "DESC"))
    app.refresh_discogs_view()
    
    def authenticate_discogs(self):
"""Authenticate with Discogs"""
consumer_key = app.config.get("discogs_consumer_key")
consumer_secret = app.config.get("discogs_consumer_secret")
if not consumer_key or not consumer_secret:
    messagebox.showerror("Configuration Error", "Discogs Consumer Key/Secret not found in config.json.\nPlease add these to your configuration file.")
    return
try:
    client = discogs_client.Client("VinylListingTool/5.1", consumer_key=consumer_key, consumer_secret=consumer_secret)
    token, secret, url = client.get_authorize_url()
    webbrowser.open(url)
    pin = simpledialog.askstring("Discogs Authentication", "Please enter the verification code from Discogs:")
    if not pin: return
    access_token, access_secret = client.get_access_token(pin)
    app.config.save({"discogs_oauth_token": access_token, "discogs_oauth_token_secret": access_secret})
    app.discogs_api = DiscogsAPI(app.config)
    if app.discogs_api.is_connected():
        app._update_connection_status()
        messagebox.showinfo("Success", "Successfully connected to Discogs!")
    else:
        messagebox.showerror("Error", "Failed to connect to Discogs")
except Exception as e:
    logger.error(f"Discogs authentication failed: {e}")
    messagebox.showerror("Authentication Error", str(e))
    
    def test_ebay_connection(self):
"""Test eBay connection"""
if app.ebay_api.test_connection():
    app.ebay_auth_status_var.set("Connected")
    messagebox.showinfo("Success", "Successfully connected to eBay!")
else:
    app.ebay_auth_status_var.set("Not Connected")
    messagebox.showerror("Connection Failed", "Could not connect to eBay.\nPlease check your credentials in config.json")
    
    def check_discogs_sales(self):
"""Check for Discogs sales"""
if not app.discogs_api.is_connected(): return
app.root.config(cursor="watch"); app.root.update()
def sales_worker():
    try:
        orders = app.discogs_api.get_orders(['Payment Received', 'Shipped'])
        app.safe_after(0, lambda: app._display_discogs_sales(orders))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_discogs_sales(self, orders):
"""Display Discogs sales"""
for item in app.sales_tree.get_children(): app.sales_tree.delete(item)
if not orders:
    messagebox.showinfo("No Sales", "No sales with status 'Payment Received' or 'Shipped' found.")
    return
for order in orders:
    for item in order.items:
        artist = item.release.artists[0].name if item.release.artists else "Various"
        title = item.release.title.replace(f"{artist} - ", "", 1).strip()
        sale_date = datetime.datetime.strptime(order.data['created'][:10], "%Y-%m-%d").strftime("%d-%m-%Y")
        sale_price = f"{item.price.value} {item.price.currency}"
        values = (order.id, sale_date, order.buyer.username, artist, title, sale_price, item.release.id)
        app.sales_tree.insert("", "end", values=values)
    
    def sync_discogs_sale(self):
"""Sync selected Discogs sale to inventory"""
selected = app.sales_tree.focus()
if not selected: return
release_id = app.sales_tree.item(selected, "values")[6]
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku FROM inventory WHERE discogs_release_id = ? AND status = 'For Sale'", (release_id,))
        record = cursor.fetchone()
        if record:
            sku = record[0]
            if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
                app.update_inventory_status("Sold")
                messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
        else:
            messagebox.showwarning("No Match", f"Could not find an unsold item with Release ID: {release_id}.")
except Exception as e:
    logger.error(f"Failed to sync sale: {e}")
    messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def check_ebay_sales(self):
"""Check for eBay sales"""
if not app.ebay_api.test_connection(): return
try:
    start_date = datetime.datetime.strptime(app.ebay_start_date_var.get(), "%d-%m-%Y")
    end_date = datetime.datetime.strptime(app.ebay_end_date_var.get(), "%d-%m-%Y")
    if (end_date - start_date).days > 30:
        messagebox.showerror("Date Range Error", "The date range cannot exceed 30 days.")
        return
except ValueError:
    messagebox.showerror("Date Format Error", "Please enter dates in DD-MM-YYYY format.")
    return
app.root.config(cursor="watch"); app.root.update()
def sales_worker():
    try:
        orders = app.ebay_api.get_orders(start_date, end_date)
        app.safe_after(0, lambda: app._display_ebay_sales(orders))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_ebay_sales(self, orders):
"""Display eBay sales"""
for item in app.ebay_sales_tree.get_children(): app.ebay_sales_tree.delete(item)
if not orders:
    messagebox.showinfo("No eBay Sales", "No completed sales found in the specified date range.")
    return
for order in orders:
    order_id, created_date, buyer = order.get("orderId"), order.get("creationDate", "")[:10], order.get("buyer", {}).get("username", "")
    for line_item in order.get("lineItems", []):
        title, price, currency, item_id = line_item.get("title", ""), line_item.get("lineItemCost", {}).get("value", ""), line_item.get("lineItemCost", {}).get("currency", "GBP"), line_item.get("legacyItemId", "")
        artist, album_title = "", title
        if ":" in title:
            parts = title.split(":", 1)
            artist, album_title = parts[0].strip(), parts[1].strip()
        values = (order_id, created_date, buyer, artist, album_title, f"{price} {currency}", item_id)
        app.ebay_sales_tree.insert("", "end", values=values)
    
    def sync_ebay_sale(self):
"""Sync selected eBay sale to inventory"""
selected = app.ebay_sales_tree.focus()
if not selected: return
_, _, _, artist, title, _, item_id = app.ebay_sales_tree.item(selected, "values")
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku FROM inventory WHERE (ebay_listing_id = ? OR (artist LIKE ? AND title LIKE ?)) AND status = 'For Sale'", (item_id, f"%{artist}%", f"%{title}%"))
        record = cursor.fetchone()
        if record:
            sku = record[0]
            if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
                app.update_inventory_status("Sold")
                messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
        else:
            messagebox.showwarning("No Match", f"Could not find an unsold item matching:\n{artist} - {title}")
except Exception as e:
    logger.error(f"Failed to sync sale: {e}")
    messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def start_discogs_import(self):
"""Import inventory from Discogs"""
if not app.discogs_api.is_connected(): return
if not messagebox.askyesno("Confirm Import", "This will import all 'For Sale' items from Discogs.\nExisting items will be skipped.\n\nContinue?"): return
app.root.config(cursor="watch"); app.root.update()
def import_worker():
    try:
        inventory = app.discogs_api.get_inventory()
        app.safe_after(0, lambda: app._process_discogs_import(inventory))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Import Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=import_worker, daemon=True).start()
    
    def _process_discogs_import(self, inventory):
"""Process Discogs import"""
new_items, skipped_items = 0, 0
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        for listing in inventory:
            if listing.status != 'For Sale': continue
            cursor.execute("SELECT COUNT(*) FROM inventory WHERE discogs_listing_id = ?", (listing.id,))
            if cursor.fetchone()[0] > 0:
                skipped_items += 1
                continue
            new_items += 1
            artist = listing.release.artists[0].name if listing.release.artists else "Various"
            title = listing.release.title.replace(f"{artist} - ", "", 1).strip()
            sku = datetime.datetime.now().strftime(f"%Y%m%d-%H%M%S-{new_items}")
            now = datetime.datetime.now(datetime.timezone.utc).isoformat()
            sql = """INSERT INTO inventory (sku, artist, title, cat_no, media_condition, sleeve_condition, price, status, discogs_release_id, discogs_listing_id, date_added, last_modified) 
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"""
            media_cond = DISCOGS_GRADE_MAP.get(listing.condition, listing.condition)
            sleeve_cond = DISCOGS_GRADE_MAP.get(listing.sleeve_condition, listing.sleeve_condition)
            catno = getattr(listing.release, 'catno', '')
            cursor.execute(sql, (sku, artist, title, catno, media_cond, sleeve_cond, listing.price.value, "For Sale", listing.release.id, listing.id, now, now))
    messagebox.showinfo("Import Complete", f"Successfully imported {new_items} new item(s).\nSkipped {skipped_items} existing item(s).")
    app.populate_inventory_view()
except Exception as e:
    logger.error(f"Import failed: {e}")
    messagebox.showerror("Import Error", f"An error occurred during import:\n{e}")
    
    def toggle_auto_sync(self):
"""Toggle automatic sync"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
    app.auto_sync_var.set(False)
    return
app.auto_sync_enabled = app.auto_sync_var.get()
app.config.save({"auto_sync_enabled": app.auto_sync_enabled})
if app.auto_sync_enabled: app.start_auto_sync()
else: app.stop_auto_sync()
    
    def toggle_two_way_sync(self):
"""Toggle two-way sync"""
app.two_way_sync_enabled = app.two_way_sync_var.get()
app.config.save({"two_way_sync_enabled": app.two_way_sync_enabled})
app.log_sync_activity(f"Two-way sync {'enabled' if app.two_way_sync_enabled else 'disabled'}")
    
    def toggle_attempt_updates(self):
"""Toggle attempt to update Discogs"""
app.attempt_discogs_updates = app.attempt_updates_var.get()
app.config.save({"attempt_discogs_updates": app.attempt_discogs_updates})
app.log_sync_activity(f"Discogs update attempts {'enabled' if app.attempt_discogs_updates else 'disabled'}")
    
    def update_sync_interval(self):
"""Update sync interval"""
try:
    minutes = int(app.sync_interval_var.get())
    app.auto_sync_interval = minutes * 60
    app.config.save({"auto_sync_interval": app.auto_sync_interval})
    app.log_sync_activity(f"Sync interval set to {minutes} minutes")
except ValueError: app.sync_interval_var.set("5")
    
    def start_auto_sync(self):
"""Start automatic sync"""
if app.auto_sync_thread and app.auto_sync_thread.is_alive(): return
app.auto_sync_stop_event.clear()
app.auto_sync_thread = threading.Thread(target=app._auto_sync_worker, daemon=True)
app.auto_sync_thread.start()
app.sync_status_var.set("Auto-sync enabled - waiting for next sync...")
app.log_sync_activity("Automatic sync started")
    
    def stop_auto_sync(self):
"""Stop automatic sync"""
app.auto_sync_stop_event.set()
app.sync_status_var.set("Auto-sync disabled")
app.log_sync_activity("Automatic sync stopped")
    
    def _auto_sync_worker(self):
"""Auto sync worker thread"""
while not app.auto_sync_stop_event.is_set():
    try:
        if app.auto_sync_stop_event.wait(app.auto_sync_interval): break
        if app.auto_sync_enabled and app.discogs_api.is_connected():
            app.safe_after(0, lambda: app.sync_status_var.set("Syncing inventory..."))
            sync_result = app._perform_inventory_sync()
            app.safe_after(0, lambda r=sync_result: app._handle_sync_result(r))
    except Exception as e:
        app.safe_after(0, lambda msg=f"Auto-sync error: {e}": app.log_sync_activity(msg))
    
    def manual_sync_now(self):
"""Perform manual sync now"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
    return
app.sync_status_var.set("Manual sync in progress...")
app.root.config(cursor="watch"); app.root.update()
def sync_worker():
    try:
        result = app._perform_inventory_sync()
        app.safe_after(0, lambda: app._handle_sync_result(result))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Sync Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))
threading.Thread(target=sync_worker, daemon=True).start()
    
    def _perform_inventory_sync(self):
"""Implements true "latest-wins" two-way sync logic."""
sync_start_time = datetime.datetime.now(datetime.timezone.utc)
app.log_sync_activity("=== STARTING SYNC (Latest-Wins) ===")
try:
    discogs_inventory = app.discogs_api.get_inventory()
    discogs_map = {listing.id: listing for listing in discogs_inventory}
    app.log_sync_activity(f"Retrieved {len(discogs_inventory)} active listings from Discogs.")

    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT sku, discogs_listing_id, price, status, notes, last_modified, last_sync_time FROM inventory WHERE discogs_listing_id IS NOT NULL")
        local_items = [dict(row) for row in cursor.fetchall()]
        local_map = {item['discogs_listing_id']: item for item in local_items}
    app.log_sync_activity(f"Found {len(local_map)} linked local items.")

    updates_to_local, updates_to_discogs, deletions_from_local, new_sales = 0, 0, 0, 0
    
    for local_item in local_items:
        listing_id, last_mod_local_str, last_sync_str = local_item['discogs_listing_id'], local_item.get('last_modified'), app.last_successful_sync_time or local_item.get('last_sync_time')
        if not last_mod_local_str or not last_sync_str: continue
        try:
            last_mod_local, last_sync = datetime.datetime.fromisoformat(last_mod_local_str), datetime.datetime.fromisoformat(last_sync_str)
        except (ValueError, TypeError): continue

        if last_mod_local > last_sync and app.attempt_discogs_updates:
            if listing_id in discogs_map:
                app.log_sync_activity(f"→ Local change detected for SKU {local_item['sku']}. Pushing to Discogs.")
                update_payload = {"price": local_item['price'], "status": app._map_local_to_discogs_status(local_item['status']), "comments": local_item.get('notes', '')}
                if app.discogs_api.update_listing(listing_id, update_payload):
                    updates_to_discogs += 1; app.log_sync_activity(f"  ✓ Pushed update for SKU {local_item['sku']} to Discogs.")
                else: app.log_sync_activity(f"  ✗ Failed to push update for SKU {local_item['sku']}.")
            else: app.log_sync_activity(f"  - SKU {local_item['sku']} changed locally but no longer on Discogs. Skipping push.")

        elif listing_id in discogs_map:
            listing = discogs_map[listing_id]
            mapped_status = app.status_mappings.get(listing.status, "Not For Sale")
            if mapped_status != local_item['status']:
                with app.db.get_connection() as conn:
                    conn.cursor().execute("UPDATE inventory SET status = ?, last_modified = ? WHERE discogs_listing_id = ?", (mapped_status, sync_start_time.isoformat(), listing_id))
                updates_to_local += 1
                if mapped_status == 'Sold' and local_item['status'] != 'Sold': new_sales += 1
                app.log_sync_activity(f"✓ Sync from Discogs: SKU {local_item['sku']} '{local_item['status']}' → '{mapped_status}'")

    ids_to_delete_locally = set(local_map.keys()) - set(discogs_map.keys())
    if ids_to_delete_locally:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            for listing_id in ids_to_delete_locally:
                if local_map[listing_id]['status'] == 'For Sale':
                    sku = local_map[listing_id]['sku']
                    cursor.execute("DELETE FROM inventory WHERE discogs_listing_id = ?", (listing_id,))
                    deletions_from_local += 1
                    app.log_sync_activity(f"✓ Deleted SKU {sku} locally as it's no longer on Discogs.")
    
    with app.db.get_connection() as conn:
        conn.cursor().execute("UPDATE inventory SET last_sync_time = ? WHERE discogs_listing_id IS NOT NULL", (sync_start_time.isoformat(),))
    app.last_successful_sync_time = sync_start_time.isoformat()
    app.config.save({"last_successful_sync_time": app.last_successful_sync_time})
    if updates_to_local > 0 or deletions_from_local > 0: app.safe_after(0, app.populate_inventory_view)
    app.log_sync_activity("=== SYNC COMPLETED ===")
    return {'success': True, 'updates_local': updates_to_local, 'updates_discogs': updates_to_discogs, 'deletions': deletions_from_local, 'new_sales': new_sales, 'total_checked': len(discogs_inventory)}
except Exception as e:
    logger.error(f"Sync failed: {e}", exc_info=True)
    app.log_sync_activity(f"✗ SYNC ERROR: {e}")
    return {'success': False, 'error': str(e)}

    def _map_local_to_discogs_status(self, local_status):
"""Map local status to valid Discogs status"""
return {'For Sale': 'For Sale', 'Sold': 'Sold'}.get(local_status, 'Draft')
    
    def _handle_sync_result(self, result):
"""Handle sync result"""
current_time = datetime.datetime.now().strftime("%H:%M:%S")
if result.get('success'):
    updates_local, updates_discogs, deletions = result.get('updates_local', 0), result.get('updates_discogs', 0), result.get('deletions', 0)
    total_changes = updates_local + updates_discogs + deletions
    if total_changes > 0:
        log_msg = f"[{current_time}] Sync completed: {total_changes} changes from {result['total_checked']} listings"
        if updates_local > 0: log_msg += f"\n  - Pulled from Discogs: {updates_local}"
        if updates_discogs > 0: log_msg += f"\n  - Pushed to Discogs: {updates_discogs}"
        if deletions > 0: log_msg += f"\n  - Items deleted locally: {deletions}"
        if result.get('new_sales', 0) > 0: log_msg += f"\n  - New sales detected: {result['new_sales']}"
        app.log_sync_activity(log_msg)
        status_msg = f"Sync complete - {total_changes} change(s)"
    else:
        status_msg = "Sync complete - no changes needed"
        app.log_sync_activity(f"[{current_time}] Sync completed. No changes needed.")
    app.sync_status_var.set(f"Last sync: {current_time}. {status_msg}")
else:
    app.sync_status_var.set(f"Last sync: {current_time}. FAILED.")
    app.log_sync_activity(f"[{current_time}] Sync FAILED: {result.get('error')}")

    # ========================================================================
    # ENHANCED PUBLISHING ACTION METHODS
    # ========================================================================
    
    def action_ebay_save_unpublished(self):
"""Save eBay listing data locally as 'ready to publish' without sending to eBay"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - save current form
    app._save_ebay_draft_from_lister()
else:
    # From Inventory tab - mark selected items as ready for eBay
    app._save_ebay_draft_from_inventory()

    def action_ebay_publish_live(self):
"""Publish directly to eBay as live listings (Inventory API)"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - publish current form directly
    app.list_on_ebay()
else:
    # From Inventory tab - publish selected items
    app.publish_to_ebay()



    def reconcile_from_ebay(self, skus):


"""Pull eBay state back into local DB so deletions/ends/relists are reflected.


Chooses ACTIVE offer. Prefers Item ID (listingId); falls back to offerId if listingId hasn't propagated yet.


Refreshes the grid when done.


"""


import datetime, logging, requests


logger = logging.getLogger(__name__)


    


token = app.ebay_api.get_access_token()


if not token:


    app.append_log("Cannot reconcile: missing eBay token", "red")


    return


    


headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}


changed = False


    


for sku in (skus or []):


    try:


        url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={sku}"


        r = requests.get(url, headers=headers, timeout=30)


        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()


    


        if r.status_code == 200 and r.json().get("offers"):


            offers = r.json()["offers"]


            # Pick ACTIVE offer if available; otherwise first one


            active = None


            for o in offers:


                if (o.get("status") or "").upper() == "ACTIVE":


                    active = o


                    break


            offer = active or offers[0]


            status = (offer.get("status") or "").upper()


    


            listing_id = offer.get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('legacyItemId') or (offer.get('listing') or {}).get('listingId')


            offer_id = offer.get("offerId") or (offer.get("offer") or {}).get("offerId")


    


            # If ACTIVE but listingId missing, try GET /offer/{offerId} to resolve


            if status in ("ACTIVE","PUBLISHED") and not listing_id and offer_id:


                try:


                    resolved = app.ebay_api.get_offer(str(offer_id))


                    if resolved.get("success"):


                        listing_id = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')


                except Exception as e:


                    logger.warning(f"[reconcile] get_offer failed for offer {offer_id}: {e}")


    


            with app.db.get_connection() as conn:


                c = conn.cursor()


                if status in ("ACTIVE","PUBLISHED"):


                    stored_id = listing_id or (offer_id if offer_id else None)


                    if stored_id:


                        c.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))


                        changed = True


                    else:


                        c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                        changed = True


                else:


                    c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                    changed = True


    


            shown = listing_id or (offer_id if (status in ("ACTIVE","PUBLISHED") and offer_id) else "—")


            label = "Item ID" if listing_id else ("Offer ID" if shown != "—" else "—")  # live


            app.append_log(f"SKU {sku}: reconciled from eBay ({status}; {label}={shown})", "blue")


        else:


            with app.db.get_connection() as conn:


                c = conn.cursor()


                c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


            changed = True


            app.append_log(f"SKU {sku}: no eBay offer found; cleared local mapping.", "orange")


    


    except Exception as e:


        logger.error(f"Reconcile error for {sku}: {e}")


        app.append_log(f"SKU {sku}: reconcile failed: {e}", "red")


    


if changed:


    try:


        app.populate_inventory_view()


    except Exception:


        pass



    def action_open_on_ebay_selected(self):



"""Open the selected item's eBay listing in the browser using stored Item ID."""



import webbrowser, requests, logging



logger = logging.getLogger(__name__)



items = app.inventory_tree.selection()



if not items:



    try:



        messagebox.showinfo("Open on eBay", "Please select a row first.")



    except Exception:



        pass



    return



iid = items[0]



vals = app.inventory_tree.item(iid, "values") or []



item_id = None



# Try visible column first



try:



    headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



    if "eBay ID" in headers:



        idx = headers.index("eBay ID")



        if idx < len(vals):



            item_id = vals[idx]



except Exception:



    item_id = None



# Fallback: DB lookup by SKU (assumes SKU in first column)



if not item_id and vals:



    sku = vals[0]



    try:



        with app.db.get_connection() as conn:



            c = conn.cursor()



            c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



            row = c.fetchone()



            if row and row[0]:



                item_id = row[0]



    except Exception:



        pass



if not item_id:



    try:



        messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



    except Exception:



        pass



    return



# If it's likely an offerId, try resolve to listingId on the fly



if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



    try:



        token = app.ebay_api.get_access_token()



        if token:



            headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



            url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



            r = requests.get(url, headers=headers, timeout=30)



            if r.status_code == 200 and r.json().get("offers"):



                offers = r.json()["offers"]



                active = None



                for o in offers:



                    if (o.get("status") or "").upper() == "ACTIVE":



                        active = o



                        break



                off = active or offers[0]



                lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



                if not lid:



                    oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                    if oid:



                        resolved = app.ebay_api.get_offer(str(oid))



                        if resolved.get("success"):



                            lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



                if lid:



                    item_id = lid



    except Exception as e:



        logger.warning(f"[open] resolution failed: {e}")



try:



    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



except Exception:



    try:



        messagebox.showerror("Open on eBay", "Failed to open browser.")



    except Exception:



        pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




try:




    offers = app._fetch_all_ebay_offers()




except Exception as e:




    messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




    return




work = []




with app.db.get_connection() as conn:




    c = conn.cursor()




    for off in offers:




        sku = (off.get("sku") or "").strip()




        if not sku:




            continue




        c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




        row = c.fetchone()




        if not row or not row[0]:




            work.append(off)




if not work:




    messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




    return




app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def publish_worker(app):
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    app.append_log(f"SKU {sku}: Starting publish process for eBay...", "black")

    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue
        # Latest-wins check: warn if remote eBay data is newer than local
        try:
            local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
            remote_ts = record.get("ebay_updated_at")
            proceed = True
            if remote_ts and local_ts:
                try:
                    ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                    rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                    if rdt > ldt:
                        msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                               f"Local updated: {ldt.isoformat()}\n"
                               f"eBay updated: {rdt.isoformat()}\n\n"
                               "Proceeding will overwrite eBay with local data. Continue?")
                        proceed = messagebox.askyesno("Potential Conflict", msg)
                except Exception:
                    pass
            if not proceed:
                app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                continue
        except Exception:
            pass

        # Ensure categoryId is set before validation; use default if missing
        try:
            if not record.get("categoryId") and not record.get("category_id"):
                fmt = record.get("format", "LP") or "LP"
                record = dict(record)
                record["categoryId"] = EBAY_VINYL_CATEGORIES.get(fmt, "176985")
        except Exception:
            pass
        errors = validate_listing("ebay", record, app.config)
        if errors:
            app.append_log(f"SKU {sku}: Validation failed: {', '.join(errors)}", "red")
            continue

        # --- Listing Creation with Correct Condition ---
        format_val = record.get("format", "LP")
        media_cond_str = record.get("media_condition", "")

        # Map media grade to eBay enums/IDs. Use a conservative fallback:
        # for unknown grades default to USED_GOOD (enum) and a numeric
        # ID of 3000. The numeric ID will not be sent for records.
        condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
        condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
        category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

        listing_data = {
            "sku": sku,
            "title": record.get("listing_title") or record.get("title", "")[:80],
            "description": record.get("description", ""),
            "price": record.get("price", 0),
            "quantity": 1,
            "categoryId": category_id,
            "condition_enum": condition_enum,
            "condition_id_numeric": condition_id_numeric,
            "media_condition": record.get("media_condition"),
            "sleeve_condition": record.get("sleeve_condition"),
            "images": record.get("images", []),
            "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
            "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
            "returnPolicyId": app.config.get("ebay_return_policy_id"),
            "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
            "currency": "GBP"
        }

        result = app.ebay_api.create_draft_listing(listing_data)
        if result.get("success"):
            offer_id = result.get('offerId')
            app.append_log(f"SKU {sku}: Successfully created eBay draft (Offer ID: {offer_id})", "green")
            # Write back ID and timestamp
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?",
                        (offer_id, now_iso, sku),
                    )
            except Exception as e:
                logger.error(f"Failed to update inventory with eBay listing ID: {e}")
                app.append_log(f"SKU {sku}: Failed to save eBay Offer ID to local DB: {e}", "red")
        else:
            app.append_log(f"SKU {sku}: eBay listing failed: {result.get('error')}", "red")

    except Exception as e:
        app.append_log(f"SKU {sku}: An unexpected error occurred: {e}", "red")
        logger.error(f"Error publishing SKU {sku} to eBay", exc_info=True)

app.safe_after(0, app.populate_inventory_view)
app.safe_after(0, lambda: app.root.config(cursor=""))

        app.root.config(cursor="watch")
        app.root.update()
        threading.Thread(target=publish_worker, daemon=True).start()

    def publish_to_discogs(self):
        """Publish selected items to Discogs"""
        selected = app.inventory_tree.selection()
        if not selected: return
        for item in selected:
sku = app.inventory_tree.item(item, "values")[0]
try:
    record = app._get_inventory_record(sku)
    if not record:
        app.append_log(f"SKU {sku}: Could not find record.", "red")
        continue
    # Latest-wins check: warn if Discogs data is newer
    try:
        local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
        remote_ts = record.get("discogs_updated_at")
        proceed = True
        if remote_ts and local_ts:
            try:
                ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                if rdt > ldt:
                    msg = (f"SKU {sku}: The Discogs data was updated more recently than your local copy.\n"
                           f"Local updated: {ldt.isoformat()}\n"
                           f"Discogs updated: {rdt.isoformat()}\n\n"
                           "Proceeding will overwrite Discogs with local data. Continue?")
                    proceed = messagebox.askyesno("Potential Conflict", msg)
            except Exception:
                pass
        if not proceed:
            app.append_log(f"SKU {sku}: Skipped due to newer Discogs data.", "orange")
            continue
    except Exception:
        pass

    errors = validate_listing("discogs", record, app.config)
    if errors:
        app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
        continue
    app.append_log(f"Publishing SKU {sku} to Discogs...", "black")
    listing_data = {
        "release_id": record.get("discogs_release_id"),
        "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
        "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
        "price": record.get("price", 0), "status": "Draft", "comments": record.get("description", "")
    }
    listing_id = app.discogs_api.create_listing(listing_data)
    if listing_id:
        app.append_log(f"SKU {sku}: Listed as Draft (ID: {listing_id})", "green")
        try:
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            with app.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(
                    "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                    (listing_id, now_iso, sku),
                )
        except Exception as e:
            logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
            app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
    else:
        app.append_log(f"SKU {sku}: Failed to create listing", "red")
except Exception as e:
    app.append_log(f"SKU {sku}: Error - {e}", "red")

    def save_to_ebay_drafts_inventory(self):
        """
        Create a Sell Listings draft for each selected inventory item. This is a safe operation
        that does not publish the listing live. The returned draft ID and update timestamp
        are saved back to the database.
        """
        if globals().get("PUBLISH_HARD_BLOCK"):
app.append_log("[draft] BLOCKED BY FLAG", "orange")
return
        selected = app.inventory_tree.selection()
        if not selected:
messagebox.showwarning("No Selection", "Please select items from the inventory to save drafts.")
return

        # Switch to inventory tab to display logs
        app.notebook.select(app.inventory_tab)

        def draft_worker():
# Force the eBay API wrapper to refresh the access token on each
# draft creation. This ensures that any newly added scopes (e.g.
# sell.listing) are included in the token. Without this, the
# cached access token may not contain the required scope and
# draft creation can fail silently.
try:
    app.ebay_api.access_token = None
except Exception:
    pass
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue

        # Check latest-wins management: warn if remote data is newer than local
        try:
            local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
            remote_ts = record.get("ebay_updated_at")
            proceed = True
            if remote_ts and local_ts:
                try:
                    ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                    rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                    if rdt > ldt:
                        msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                               f"Local updated: {ldt.isoformat()}\n"
                               f"eBay updated: {rdt.isoformat()}\n\n"
                               "Proceeding will overwrite eBay with local data. Continue?")
                        proceed = messagebox.askyesno("Potential Conflict", msg)
                except Exception:
                    pass
            if not proceed:
                app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                continue
        except Exception:
            pass

        # Build listing_data similar to publish_to_ebay
        format_val = record.get("format", "LP")
        media_cond_str = record.get("media_condition", "")
        # Map media grade to eBay enums/IDs. Use "USED_GOOD" and 3000 as
        # safe fallbacks for unknown grades. The numeric ID will not be
        # transmitted for the Records category.
        condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
        condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
        category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")
        listing_data = {
            "sku": sku,
            "title": record.get("listing_title") or record.get("title", "")[:80],
            "description": record.get("description", ""),
            "price": record.get("price", 0),
            "quantity": 1,
            "categoryId": category_id,
            "condition_enum": condition_enum,
            "condition_id_numeric": condition_id_numeric,
            "media_condition": record.get("media_condition"),
            "sleeve_condition": record.get("sleeve_condition"),
            "images": record.get("images", []),
            "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
            "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
            "returnPolicyId": app.config.get("ebay_return_policy_id"),
            "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
            "currency": "GBP"
        }
        # Attempt to collect image URLs if necessary
        try:
            # Convert local images to eBay-hosted URLs if none exist
            if not listing_data.get("images") and record.get("image_urls"):
                listing_data["imageUrls"] = record.get("image_urls")
            else:
                # Fallback: rely on eBay API wrapper to upload images
                listing_data["images"] = record.get("images", [])
        except Exception:
            pass

        res = app.ebay_api.create_sell_listing_draft(listing_data)
        if res.get("success"):
            draft_id = res.get("draftId")
            # Write back ID and timestamp
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET ebay_item_draft_id = ?, ebay_updated_at = ? WHERE sku = ?",
                        (draft_id, now_iso, sku),
                    )
                app.append_log(f"SKU {sku}: eBay draft created (Draft ID: {draft_id}).", "green")
            except Exception as e:
                app.append_log(f"SKU {sku}: Draft created but failed to save ID to DB: {e}", "red")
        else:
            err = res.get("error") or res.get("body")
            status = res.get("status")
            if status:
                app.append_log(f"SKU {sku}: Failed to create eBay draft (status {status}): {err}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create eBay draft: {err}", "red")
    except Exception as e:
        app.append_log(f"SKU {sku}: Unexpected error during draft creation: {e}", "red")

# Refresh inventory view on the main thread
app.safe_after(0, lambda: app.populate_inventory_view(app.inventory_search_var.get()))
app.safe_after(0, lambda: app.root.config(cursor=""))

        # Show busy cursor and start background thread
        app.root.config(cursor="watch")
        app.root.update()
        threading.Thread(target=draft_worker, daemon=True).start()

    def open_listing_in_browser(self):
        """
        Open the appropriate listing page in the user's default web browser for the selected
        inventory item. Priority is given to eBay drafts, then live eBay listings,
        then Discogs listings.
        """
        selected = app.inventory_tree.focus()
        if not selected:
return
        sku = app.inventory_tree.item(selected, "values")[0]
        try:
record = app._get_inventory_record(sku)
# Try to open eBay draft if present
draft_id = record.get("ebay_item_draft_id")
if draft_id:
    # eBay does not provide direct draft URLs; open drafts overview
    webbrowser.open_new_tab("https://www.ebay.co.uk/sh/lst/drafts")
    return
live_id = record.get("ebay_listing_id")
if live_id:
    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{live_id}")
    return
discogs_id = record.get("discogs_listing_id")
if discogs_id:
    webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{discogs_id}")
    return
messagebox.showinfo("No Listing", "This item does not have any listing IDs yet.")
        except Exception as e:
logger.error(f"Failed to open listing: {e}")
messagebox.showerror("Error", f"Failed to open listing: {e}")
    
    def append_log(self, message, color="black"):
        """Append message to publish log"""
        def do_append():
timestamp = datetime.datetime.now().strftime("[%H:%M:%S]")
app.publish_log.config(state="normal")
app.publish_log.insert("end", f"{timestamp} {message}\n", (color,))
app.publish_log.tag_configure("red", foreground="red")
app.publish_log.tag_configure("green", foreground="green")
app.publish_log.tag_configure("black", foreground="black")
app.publish_log.see("end")
app.publish_log.config(state="disabled")
        app.safe_after(0, do_append)

    def show_inventory_context_menu(self, event):
        """Show inventory context menu"""
        row_id = app.inventory_tree.identify_row(event.y)
        if row_id:
app.inventory_tree.selection_set(row_id)
app.inventory_tree.focus(row_id)
app.inventory_context_menu.post(event.x_root, event.y_root)
    
    def show_discogs_context_menu(self, event):
        """Show Discogs results context menu"""
        row_id = app.discogs_tree.identify_row(event.y)
        if row_id:
app.discogs_tree.selection_set(row_id)
app.discogs_tree.focus(row_id)
app.discogs_context_menu.post(event.x_root, event.y_root)
    
    def open_discogs_listing(self):
        """Open Discogs listing for selected inventory item"""
        selected = app.inventory_tree.focus()
        if not selected: return
        sku = app.inventory_tree.item(selected, "values")[0]
        try:
record = app._get_inventory_record(sku)
if record.get("discogs_listing_id"):
    webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{record['discogs_listing_id']}")
else:
    messagebox.showinfo("No Discogs Listing", "This item has no Discogs listing ID.")
        except Exception as e:
logger.error(f"Failed to open Discogs listing: {e}")
    
    def open_ebay_listing(self):
        """Open eBay listing for selected inventory item"""
        selected = app.inventory_tree.focus()
        if not selected: return
        sku = app.inventory_tree.item(selected, "values")[0]
        try:
record = app._get_inventory_record(sku)
if record.get("ebay_listing_id"):
    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{record['ebay_listing_id']}")
else:
    messagebox.showinfo("No eBay Listing", "This item has no eBay listing ID.")
        except Exception as e:
logger.error(f"Failed to open eBay listing: {e}")
    
    def open_discogs_release_from_inventory(self):
        """Open Discogs release page for selected inventory item"""
        selected = app.inventory_tree.focus()
        if not selected: return
        sku = app.inventory_tree.item(selected, "values")[0]
        try:
record = app._get_inventory_record(sku)
if record.get("discogs_release_id"):
    webbrowser.open_new_tab(f"https://www.discogs.com/release/{record['discogs_release_id']}")
else:
    messagebox.showinfo("No Release Linked", "This item has no Discogs release ID.")
        except Exception as e:
logger.error(f"Failed to open release page: {e}")
    
    def open_discogs_release_page(self):
        """Open selected release on Discogs website"""
        selected = app.discogs_tree.focus()
        if not selected: return
        release_id = app.discogs_tree.item(selected, "values")[0]
        webbrowser.open_new_tab(f"https://www.discogs.com/release/{release_id}")
    
    def open_sold_listings_from_selection(self, platform):
        """Open sold listings search for selected Discogs result"""
        selected = app.discogs_tree.focus()
        if not selected: return
        _, artist, title, catno, _, _, _ = app.discogs_tree.item(selected, "values")
        query = f"{artist} {title} {catno}".strip()
        url = f"https://www.ebay.co.uk/sch/i.html?_nkw={quote_plus(query)}&_sacat=176985&LH_Sold=1&LH_Complete=1" if platform == "eBay" else f"https://www.discogs.com/search/?q={quote_plus(query)}&type=all"
        webbrowser.open_new_tab(url)
    
    def get_price_suggestion(self):
        """Get price suggestions for selected release"""
        selected = app.discogs_tree.focus()
        if not selected: return
        release_id = int(app.discogs_tree.item(selected, "values")[0])
        app.root.config(cursor="watch")
        app.root.update()
        def fetch_worker():
try:
    suggestions = app.discogs_api.get_price_suggestions(release_id)
    if suggestions:
        msg = "Price Suggestions:\n\n" + "\n".join([f"{condition}: £{price_data['value']:.2f}" for condition, price_data in suggestions.items()])
        app.safe_after(0, lambda: messagebox.showinfo("Price Suggestions", msg))
    else:
        app.safe_after(0, lambda: messagebox.showinfo("No Data", "No price suggestions available"))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=fetch_worker, daemon=True).start()
    
    def refresh_discogs_view(self, event=None):
        """Refresh Discogs results with filter"""
        filter_text = app.discogs_search_filter_var.get().lower()
        if not app.discogs_search_results: return
        for item in app.discogs_tree.get_children(): app.discogs_tree.delete(item)
        for result in app.discogs_search_results:
artist, title = (result.get("title", "").split(" - ", 1) + [""])[:2]
if filter_text and filter_text not in f"{artist} {title} {result.get('catno', '')} {result.get('year', '')}".lower(): continue
values = (result.get("id"), artist, title, result.get("catno", "N/A"), result.get("year", "N/A"), result.get("country", "N/A"), ", ".join(result.get("format", [])))
app.discogs_tree.insert("", "end", values=values)
    
    def sort_discogs_results(self, col):
        """Sort Discogs results by column"""
        if app.discogs_sort_column == col:
app.discogs_sort_direction = "ASC" if app.discogs_sort_direction == "DESC" else "DESC"
        else:
app.discogs_sort_column, app.discogs_sort_direction = col, "ASC"
        if app.discogs_search_results:
def sort_key(item):
    if col == "Artist": return (item.get("title", "").split(" - ", 1) + [""])[0].lower()
    elif col == "Title": return (item.get("title", "").split(" - ", 1) + [""])[1].lower()
    elif col == "Year":
        try: return int(item.get("year", 0))
        except: return 0
    else: return str(item.get(col.lower(), "")).lower()
app.discogs_search_results.sort(key=sort_key, reverse=(app.discogs_sort_direction == "DESC"))
app.refresh_discogs_view()
    
    def authenticate_discogs(self):
        """Authenticate with Discogs"""
        consumer_key = app.config.get("discogs_consumer_key")
        consumer_secret = app.config.get("discogs_consumer_secret")
        if not consumer_key or not consumer_secret:
messagebox.showerror("Configuration Error", "Discogs Consumer Key/Secret not found in config.json.\nPlease add these to your configuration file.")
return
        try:
client = discogs_client.Client("VinylListingTool/5.1", consumer_key=consumer_key, consumer_secret=consumer_secret)
token, secret, url = client.get_authorize_url()
webbrowser.open(url)
pin = simpledialog.askstring("Discogs Authentication", "Please enter the verification code from Discogs:")
if not pin: return
access_token, access_secret = client.get_access_token(pin)
app.config.save({"discogs_oauth_token": access_token, "discogs_oauth_token_secret": access_secret})
app.discogs_api = DiscogsAPI(app.config)
if app.discogs_api.is_connected():
    app._update_connection_status()
    messagebox.showinfo("Success", "Successfully connected to Discogs!")
else:
    messagebox.showerror("Error", "Failed to connect to Discogs")
        except Exception as e:
logger.error(f"Discogs authentication failed: {e}")
messagebox.showerror("Authentication Error", str(e))
    
    def test_ebay_connection(self):
        """Test eBay connection"""
        if app.ebay_api.test_connection():
app.ebay_auth_status_var.set("Connected")
messagebox.showinfo("Success", "Successfully connected to eBay!")
        else:
app.ebay_auth_status_var.set("Not Connected")
messagebox.showerror("Connection Failed", "Could not connect to eBay.\nPlease check your credentials in config.json")
    
    def check_discogs_sales(self):
        """Check for Discogs sales"""
        if not app.discogs_api.is_connected(): return
        app.root.config(cursor="watch"); app.root.update()
        def sales_worker():
try:
    orders = app.discogs_api.get_orders(['Payment Received', 'Shipped'])
    app.safe_after(0, lambda: app._display_discogs_sales(orders))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_discogs_sales(self, orders):
        """Display Discogs sales"""
        for item in app.sales_tree.get_children(): app.sales_tree.delete(item)
        if not orders:
messagebox.showinfo("No Sales", "No sales with status 'Payment Received' or 'Shipped' found.")
return
        for order in orders:
for item in order.items:
    artist = item.release.artists[0].name if item.release.artists else "Various"
    title = item.release.title.replace(f"{artist} - ", "", 1).strip()
    sale_date = datetime.datetime.strptime(order.data['created'][:10], "%Y-%m-%d").strftime("%d-%m-%Y")
    sale_price = f"{item.price.value} {item.price.currency}"
    values = (order.id, sale_date, order.buyer.username, artist, title, sale_price, item.release.id)
    app.sales_tree.insert("", "end", values=values)
    
    def sync_discogs_sale(self):
        """Sync selected Discogs sale to inventory"""
        selected = app.sales_tree.focus()
        if not selected: return
        release_id = app.sales_tree.item(selected, "values")[6]
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT sku FROM inventory WHERE discogs_release_id = ? AND status = 'For Sale'", (release_id,))
    record = cursor.fetchone()
    if record:
        sku = record[0]
        if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
            app.update_inventory_status("Sold")
            messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
    else:
        messagebox.showwarning("No Match", f"Could not find an unsold item with Release ID: {release_id}.")
        except Exception as e:
logger.error(f"Failed to sync sale: {e}")
messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def check_ebay_sales(self):
        """Check for eBay sales"""
        if not app.ebay_api.test_connection(): return
        try:
start_date = datetime.datetime.strptime(app.ebay_start_date_var.get(), "%d-%m-%Y")
end_date = datetime.datetime.strptime(app.ebay_end_date_var.get(), "%d-%m-%Y")
if (end_date - start_date).days > 30:
    messagebox.showerror("Date Range Error", "The date range cannot exceed 30 days.")
    return
        except ValueError:
messagebox.showerror("Date Format Error", "Please enter dates in DD-MM-YYYY format.")
return
        app.root.config(cursor="watch"); app.root.update()
        def sales_worker():
try:
    orders = app.ebay_api.get_orders(start_date, end_date)
    app.safe_after(0, lambda: app._display_ebay_sales(orders))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_ebay_sales(self, orders):
        """Display eBay sales"""
        for item in app.ebay_sales_tree.get_children(): app.ebay_sales_tree.delete(item)
        if not orders:
messagebox.showinfo("No eBay Sales", "No completed sales found in the specified date range.")
return
        for order in orders:
order_id, created_date, buyer = order.get("orderId"), order.get("creationDate", "")[:10], order.get("buyer", {}).get("username", "")
for line_item in order.get("lineItems", []):
    title, price, currency, item_id = line_item.get("title", ""), line_item.get("lineItemCost", {}).get("value", ""), line_item.get("lineItemCost", {}).get("currency", "GBP"), line_item.get("legacyItemId", "")
    artist, album_title = "", title
    if ":" in title:
        parts = title.split(":", 1)
        artist, album_title = parts[0].strip(), parts[1].strip()
    values = (order_id, created_date, buyer, artist, album_title, f"{price} {currency}", item_id)
    app.ebay_sales_tree.insert("", "end", values=values)
    
    def sync_ebay_sale(self):
        """Sync selected eBay sale to inventory"""
        selected = app.ebay_sales_tree.focus()
        if not selected: return
        _, _, _, artist, title, _, item_id = app.ebay_sales_tree.item(selected, "values")
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT sku FROM inventory WHERE (ebay_listing_id = ? OR (artist LIKE ? AND title LIKE ?)) AND status = 'For Sale'", (item_id, f"%{artist}%", f"%{title}%"))
    record = cursor.fetchone()
    if record:
        sku = record[0]
        if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
            app.update_inventory_status("Sold")
            messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
    else:
        messagebox.showwarning("No Match", f"Could not find an unsold item matching:\n{artist} - {title}")
        except Exception as e:
logger.error(f"Failed to sync sale: {e}")
messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def start_discogs_import(self):
        """Import inventory from Discogs"""
        if not app.discogs_api.is_connected(): return
        if not messagebox.askyesno("Confirm Import", "This will import all 'For Sale' items from Discogs.\nExisting items will be skipped.\n\nContinue?"): return
        app.root.config(cursor="watch"); app.root.update()
        def import_worker():
try:
    inventory = app.discogs_api.get_inventory()
    app.safe_after(0, lambda: app._process_discogs_import(inventory))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Import Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=import_worker, daemon=True).start()
    
    def _process_discogs_import(self, inventory):
        """Process Discogs import"""
        new_items, skipped_items = 0, 0
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    for listing in inventory:
        if listing.status != 'For Sale': continue
        cursor.execute("SELECT COUNT(*) FROM inventory WHERE discogs_listing_id = ?", (listing.id,))
        if cursor.fetchone()[0] > 0:
            skipped_items += 1
            continue
        new_items += 1
        artist = listing.release.artists[0].name if listing.release.artists else "Various"
        title = listing.release.title.replace(f"{artist} - ", "", 1).strip()
        sku = datetime.datetime.now().strftime(f"%Y%m%d-%H%M%S-{new_items}")
        now = datetime.datetime.now(datetime.timezone.utc).isoformat()
        sql = """INSERT INTO inventory (sku, artist, title, cat_no, media_condition, sleeve_condition, price, status, discogs_release_id, discogs_listing_id, date_added, last_modified) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"""
        media_cond = DISCOGS_GRADE_MAP.get(listing.condition, listing.condition)
        sleeve_cond = DISCOGS_GRADE_MAP.get(listing.sleeve_condition, listing.sleeve_condition)
        catno = getattr(listing.release, 'catno', '')
        cursor.execute(sql, (sku, artist, title, catno, media_cond, sleeve_cond, listing.price.value, "For Sale", listing.release.id, listing.id, now, now))
messagebox.showinfo("Import Complete", f"Successfully imported {new_items} new item(s).\nSkipped {skipped_items} existing item(s).")
app.populate_inventory_view()
        except Exception as e:
logger.error(f"Import failed: {e}")
messagebox.showerror("Import Error", f"An error occurred during import:\n{e}")
    
    def toggle_auto_sync(self):
        """Toggle automatic sync"""
        if not app.discogs_api.is_connected():
messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
app.auto_sync_var.set(False)
return
        app.auto_sync_enabled = app.auto_sync_var.get()
        app.config.save({"auto_sync_enabled": app.auto_sync_enabled})
        if app.auto_sync_enabled: app.start_auto_sync()
        else: app.stop_auto_sync()
    
    def toggle_two_way_sync(self):
        """Toggle two-way sync"""
        app.two_way_sync_enabled = app.two_way_sync_var.get()
        app.config.save({"two_way_sync_enabled": app.two_way_sync_enabled})
        app.log_sync_activity(f"Two-way sync {'enabled' if app.two_way_sync_enabled else 'disabled'}")
    
    def toggle_attempt_updates(self):
        """Toggle attempt to update Discogs"""
        app.attempt_discogs_updates = app.attempt_updates_var.get()
        app.config.save({"attempt_discogs_updates": app.attempt_discogs_updates})
        app.log_sync_activity(f"Discogs update attempts {'enabled' if app.attempt_discogs_updates else 'disabled'}")
    
    def update_sync_interval(self):
        """Update sync interval"""
        try:
minutes = int(app.sync_interval_var.get())
app.auto_sync_interval = minutes * 60
app.config.save({"auto_sync_interval": app.auto_sync_interval})
app.log_sync_activity(f"Sync interval set to {minutes} minutes")
        except ValueError: app.sync_interval_var.set("5")
    
    def start_auto_sync(self):
        """Start automatic sync"""
        if app.auto_sync_thread and app.auto_sync_thread.is_alive(): return
        app.auto_sync_stop_event.clear()
        app.auto_sync_thread = threading.Thread(target=app._auto_sync_worker, daemon=True)
        app.auto_sync_thread.start()
        app.sync_status_var.set("Auto-sync enabled - waiting for next sync...")
        app.log_sync_activity("Automatic sync started")
    
    def stop_auto_sync(self):
        """Stop automatic sync"""
        app.auto_sync_stop_event.set()
        app.sync_status_var.set("Auto-sync disabled")
        app.log_sync_activity("Automatic sync stopped")
    
    def _auto_sync_worker(self):
        """Auto sync worker thread"""
        while not app.auto_sync_stop_event.is_set():
try:
    if app.auto_sync_stop_event.wait(app.auto_sync_interval): break
    if app.auto_sync_enabled and app.discogs_api.is_connected():
        app.safe_after(0, lambda: app.sync_status_var.set("Syncing inventory..."))
        sync_result = app._perform_inventory_sync()
        app.safe_after(0, lambda r=sync_result: app._handle_sync_result(r))
except Exception as e:
    app.safe_after(0, lambda msg=f"Auto-sync error: {e}": app.log_sync_activity(msg))
    
    def manual_sync_now(self):
        """Perform manual sync now"""
        if not app.discogs_api.is_connected():
messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
return
        app.sync_status_var.set("Manual sync in progress...")
        app.root.config(cursor="watch"); app.root.update()
        def sync_worker():
try:
    result = app._perform_inventory_sync()
    app.safe_after(0, lambda: app._handle_sync_result(result))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Sync Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=sync_worker, daemon=True).start()
    
    def _perform_inventory_sync(self):
        """Implements true "latest-wins" two-way sync logic."""
        sync_start_time = datetime.datetime.now(datetime.timezone.utc)
        app.log_sync_activity("=== STARTING SYNC (Latest-Wins) ===")
        try:
discogs_inventory = app.discogs_api.get_inventory()
discogs_map = {listing.id: listing for listing in discogs_inventory}
app.log_sync_activity(f"Retrieved {len(discogs_inventory)} active listings from Discogs.")

with app.db.get_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT sku, discogs_listing_id, price, status, notes, last_modified, last_sync_time FROM inventory WHERE discogs_listing_id IS NOT NULL")
    local_items = [dict(row) for row in cursor.fetchall()]
    local_map = {item['discogs_listing_id']: item for item in local_items}
app.log_sync_activity(f"Found {len(local_map)} linked local items.")

updates_to_local, updates_to_discogs, deletions_from_local, new_sales = 0, 0, 0, 0

for local_item in local_items:
    listing_id, last_mod_local_str, last_sync_str = local_item['discogs_listing_id'], local_item.get('last_modified'), app.last_successful_sync_time or local_item.get('last_sync_time')
    if not last_mod_local_str or not last_sync_str: continue
    try:
        last_mod_local, last_sync = datetime.datetime.fromisoformat(last_mod_local_str), datetime.datetime.fromisoformat(last_sync_str)
    except (ValueError, TypeError): continue

    if last_mod_local > last_sync and app.attempt_discogs_updates:
        if listing_id in discogs_map:
            app.log_sync_activity(f"→ Local change detected for SKU {local_item['sku']}. Pushing to Discogs.")
            update_payload = {"price": local_item['price'], "status": app._map_local_to_discogs_status(local_item['status']), "comments": local_item.get('notes', '')}
            if app.discogs_api.update_listing(listing_id, update_payload):
                updates_to_discogs += 1; app.log_sync_activity(f"  ✓ Pushed update for SKU {local_item['sku']} to Discogs.")
            else: app.log_sync_activity(f"  ✗ Failed to push update for SKU {local_item['sku']}.")
        else: app.log_sync_activity(f"  - SKU {local_item['sku']} changed locally but no longer on Discogs. Skipping push.")

    elif listing_id in discogs_map:
        listing = discogs_map[listing_id]
        mapped_status = app.status_mappings.get(listing.status, "Not For Sale")
        if mapped_status != local_item['status']:
            with app.db.get_connection() as conn:
                conn.cursor().execute("UPDATE inventory SET status = ?, last_modified = ? WHERE discogs_listing_id = ?", (mapped_status, sync_start_time.isoformat(), listing_id))
            updates_to_local += 1
            if mapped_status == 'Sold' and local_item['status'] != 'Sold': new_sales += 1
            app.log_sync_activity(f"✓ Sync from Discogs: SKU {local_item['sku']} '{local_item['status']}' → '{mapped_status}'")

ids_to_delete_locally = set(local_map.keys()) - set(discogs_map.keys())
if ids_to_delete_locally:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        for listing_id in ids_to_delete_locally:
            if local_map[listing_id]['status'] == 'For Sale':
                sku = local_map[listing_id]['sku']
                cursor.execute("DELETE FROM inventory WHERE discogs_listing_id = ?", (listing_id,))
                deletions_from_local += 1
                app.log_sync_activity(f"✓ Deleted SKU {sku} locally as it's no longer on Discogs.")

with app.db.get_connection() as conn:
    conn.cursor().execute("UPDATE inventory SET last_sync_time = ? WHERE discogs_listing_id IS NOT NULL", (sync_start_time.isoformat(),))
app.last_successful_sync_time = sync_start_time.isoformat()
app.config.save({"last_successful_sync_time": app.last_successful_sync_time})
if updates_to_local > 0 or deletions_from_local > 0: app.safe_after(0, app.populate_inventory_view)
app.log_sync_activity("=== SYNC COMPLETED ===")
return {'success': True, 'updates_local': updates_to_local, 'updates_discogs': updates_to_discogs, 'deletions': deletions_from_local, 'new_sales': new_sales, 'total_checked': len(discogs_inventory)}
        except Exception as e:
logger.error(f"Sync failed: {e}", exc_info=True)
app.log_sync_activity(f"✗ SYNC ERROR: {e}")
return {'success': False, 'error': str(e)}

    def _map_local_to_discogs_status(self, local_status):
        """Map local status to valid Discogs status"""
        return {'For Sale': 'For Sale', 'Sold': 'Sold'}.get(local_status, 'Draft')
    
    def _handle_sync_result(self, result):
        """Handle sync result"""
        current_time = datetime.datetime.now().strftime("%H:%M:%S")
        if result.get('success'):
updates_local, updates_discogs, deletions = result.get('updates_local', 0), result.get('updates_discogs', 0), result.get('deletions', 0)
total_changes = updates_local + updates_discogs + deletions
if total_changes > 0:
    log_msg = f"[{current_time}] Sync completed: {total_changes} changes from {result['total_checked']} listings"
    if updates_local > 0: log_msg += f"\n  - Pulled from Discogs: {updates_local}"
    if updates_discogs > 0: log_msg += f"\n  - Pushed to Discogs: {updates_discogs}"
    if deletions > 0: log_msg += f"\n  - Items deleted locally: {deletions}"
    if result.get('new_sales', 0) > 0: log_msg += f"\n  - New sales detected: {result['new_sales']}"
    app.log_sync_activity(log_msg)
    status_msg = f"Sync complete - {total_changes} change(s)"
else:
    status_msg = "Sync complete - no changes needed"
    app.log_sync_activity(f"[{current_time}] Sync completed. No changes needed.")
app.sync_status_var.set(f"Last sync: {current_time}. {status_msg}")
        else:
app.sync_status_var.set(f"Last sync: {current_time}. FAILED.")
app.log_sync_activity(f"[{current_time}] Sync FAILED: {result.get('error')}")

    # ========================================================================
    # ENHANCED PUBLISHING ACTION METHODS
    # ========================================================================
    
    def action_ebay_save_unpublished(self):
        """Save eBay listing data locally as 'ready to publish' without sending to eBay"""
        if app.notebook.tab(app.notebook.select(), "text") == "Lister":
# From Lister tab - save current form
app._save_ebay_draft_from_lister()
        else:
# From Inventory tab - mark selected items as ready for eBay
app._save_ebay_draft_from_inventory()

    def action_ebay_publish_live(self):
        """Publish directly to eBay as live listings (Inventory API)"""
        if app.notebook.tab(app.notebook.select(), "text") == "Lister":
# From Lister tab - publish current form directly
app.list_on_ebay()
        else:
# From Inventory tab - publish selected items
app.publish_to_ebay()



    def reconcile_from_ebay(self, skus):


        """Pull eBay state back into local DB so deletions/ends/relists are reflected.


        Chooses ACTIVE offer. Prefers Item ID (listingId); falls back to offerId if listingId hasn't propagated yet.


        Refreshes the grid when done.


        """


        import datetime, logging, requests


        logger = logging.getLogger(__name__)


    


        token = app.ebay_api.get_access_token()


        if not token:


app.append_log("Cannot reconcile: missing eBay token", "red")


return


    


        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}


        changed = False


    


        for sku in (skus or []):


try:


    url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={sku}"


    r = requests.get(url, headers=headers, timeout=30)


    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()


    


    if r.status_code == 200 and r.json().get("offers"):


        offers = r.json()["offers"]


        # Pick ACTIVE offer if available; otherwise first one


        active = None


        for o in offers:


            if (o.get("status") or "").upper() == "ACTIVE":


                active = o


                break


        offer = active or offers[0]


        status = (offer.get("status") or "").upper()


    


        listing_id = offer.get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('legacyItemId') or (offer.get('listing') or {}).get('listingId')


        offer_id = offer.get("offerId") or (offer.get("offer") or {}).get("offerId")


    


        # If ACTIVE but listingId missing, try GET /offer/{offerId} to resolve


        if status in ("ACTIVE","PUBLISHED") and not listing_id and offer_id:


            try:


                resolved = app.ebay_api.get_offer(str(offer_id))


                if resolved.get("success"):


                    listing_id = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')


            except Exception as e:


                logger.warning(f"[reconcile] get_offer failed for offer {offer_id}: {e}")


    


        with app.db.get_connection() as conn:


            c = conn.cursor()


            if status in ("ACTIVE","PUBLISHED"):


                stored_id = listing_id or (offer_id if offer_id else None)


                if stored_id:


                    c.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))


                    changed = True


                else:


                    c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                    changed = True


            else:


                c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                changed = True


    


        shown = listing_id or (offer_id if (status in ("ACTIVE","PUBLISHED") and offer_id) else "—")


        label = "Item ID" if listing_id else ("Offer ID" if shown != "—" else "—")  # live


        app.append_log(f"SKU {sku}: reconciled from eBay ({status}; {label}={shown})", "blue")


    else:


        with app.db.get_connection() as conn:


            c = conn.cursor()


            c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


        changed = True


        app.append_log(f"SKU {sku}: no eBay offer found; cleared local mapping.", "orange")


    


except Exception as e:


    logger.error(f"Reconcile error for {sku}: {e}")


    app.append_log(f"SKU {sku}: reconcile failed: {e}", "red")


    


        if changed:


try:


    app.populate_inventory_view()


except Exception:


    pass



    def action_open_on_ebay_selected(self):



        """Open the selected item's eBay listing in the browser using stored Item ID."""



        import webbrowser, requests, logging



        logger = logging.getLogger(__name__)



        items = app.inventory_tree.selection()



        if not items:



try:



    messagebox.showinfo("Open on eBay", "Please select a row first.")



except Exception:



    pass



return



        iid = items[0]



        vals = app.inventory_tree.item(iid, "values") or []



        item_id = None



        # Try visible column first



        try:



headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



if "eBay ID" in headers:



    idx = headers.index("eBay ID")



    if idx < len(vals):



        item_id = vals[idx]



        except Exception:



item_id = None



        # Fallback: DB lookup by SKU (assumes SKU in first column)



        if not item_id and vals:



sku = vals[0]



try:



    with app.db.get_connection() as conn:



        c = conn.cursor()



        c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



        row = c.fetchone()



        if row and row[0]:



            item_id = row[0]



except Exception:



    pass



        if not item_id:



try:



    messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



except Exception:



    pass



return



        # If it's likely an offerId, try resolve to listingId on the fly



        if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



try:



    token = app.ebay_api.get_access_token()



    if token:



        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



        url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



        r = requests.get(url, headers=headers, timeout=30)



        if r.status_code == 200 and r.json().get("offers"):



            offers = r.json()["offers"]



            active = None



            for o in offers:



                if (o.get("status") or "").upper() == "ACTIVE":



                    active = o



                    break



            off = active or offers[0]



            lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



            if not lid:



                oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                if oid:



                    resolved = app.ebay_api.get_offer(str(oid))



                    if resolved.get("success"):



                        lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



            if lid:



                item_id = lid



except Exception as e:



    logger.warning(f"[open] resolution failed: {e}")



        try:



webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



        except Exception:



try:



    messagebox.showerror("Open on eBay", "Failed to open browser.")



except Exception:



    pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




        try:




offers = app._fetch_all_ebay_offers()




        except Exception as e:




messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




return




        work = []




        with app.db.get_connection() as conn:




c = conn.cursor()




for off in offers:




    sku = (off.get("sku") or "").strip()




    if not sku:




        continue




    c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




    row = c.fetchone()




    if not row or not row[0]:




        work.append(off)




        if not work:




messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




return




        app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




        token = app.ebay_api.get_access_token()




        if not token:




raise RuntimeError("Missing eBay token")




        import requests




        hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




        base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




        offers, limit, offset = [], 200, 0




        while True:




resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




if resp.status_code != 200:




    raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




data = resp.json()




batch = data.get("offers") or []




for o in batch:




    aspects = (o.get("aspects") or {})




    gtin = None




    for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




        v = aspects.get(k)




        if isinstance(v, list) and v:




            gtin = v[0]; break




        if isinstance(v, str) and v.strip():




            gtin = v.strip(); break




    if not gtin:




        prod = o.get("product") or {}




        g = prod.get("gtin")




        if isinstance(g, list) and g:




            gtin = g[0]




        elif isinstance(g, str):




            gtin = g




    offers.append({




        "sku": o.get("sku"),




        "title": o.get("title") or (o.get("name") or ""),




        "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




        "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




        "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




        "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




        "quantity": o.get("availableQuantity"),




        "status": (o.get("status") or "").upper(),




        "gtin": (gtin or "").strip(),




        "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




        "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




        "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




        "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




        "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




    })




total = data.get("total", 0)




offset += len(batch)




if offset >= total or not batch:




    break




        return offers




    




    def _start_import_wizard(self, offers):




        app._import_offers = [o for o in offers]




        app._import_idx = 0




        win = tk.Toplevel(app.root)




        win.title("Import from eBay → Discogs match")




        win.geometry("720x520")




        app._import_win = win




        app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




        app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




        app._imp_info = tk.Text(win, height=10, wrap="word")




        app._imp_info.pack(fill="x", padx=12)




        app._imp_status = tk.Label(win, text="", fg="gray")




        app._imp_status.pack(anchor="w", padx=12, pady=6)




        btns = tk.Frame(win)




        btns.pack(fill="x", padx=12, pady=8)




        tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




        tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




        tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




        tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




        app._import_propose_current()




    




    def _import_propose_current(self):




        if app._import_idx >= len(app._import_offers):




try:




    app.populate_inventory_view()




except Exception:




    pass




messagebox.showinfo("Import from eBay", "Done.")




app._import_win.destroy()




return




        o = app._import_offers[app._import_idx]




        sku = o.get("sku") or ""




        title = o.get("title") or ""




        gtin = o.get("gtin") or ""




        catno = o.get("catno") or ""




        label = o.get("label") or ""




        fmt = o.get("format") or ""




        app._imp_hdr.config(text=f"SKU {sku} — {title}")




        app._imp_info.delete("1.0", "end")




        app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




        app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




        app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




        app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




        try:




cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




        except Exception as e:




app._imp_status.config(text=f"Discogs search failed: {e}")




app._import_candidates = []




return




        app._import_candidates = cands




        if not cands:




app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




        else:




top = cands[0]




app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




        results = []




        if gtin:




res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




for r in list(res)[:10]:




    results.append({"release_id": r.id, "title": r.title,




        "artist": getattr(r, "artist", getattr(r, "artists", "")),




        "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




        "year": getattr(r, "year", "") or "",




        "country": getattr(r, "country", "") or "",




        "method": "barcode", "confidence": 1.0})




        if catno:




res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




for r in list(res)[:10]:




    results.append({"release_id": r.id, "title": r.title,




        "artist": getattr(r, "artist", getattr(r, "artists", "")),




        "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




        "year": getattr(r, "year", "") or "",




        "country": getattr(r, "country", "") or "",




        "method": "catno", "confidence": 0.85 if not label else 0.9})




        if (not results) and title:




res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




for r in list(res)[:10]:




    results.append({"release_id": r.id, "title": r.title,




        "artist": getattr(r, "artist", getattr(r, "artists", "")),




        "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




        "year": getattr(r, "year", "") or "",




        "country": getattr(r, "country", "") or "",




        "method": "fuzzy", "confidence": 0.6})




        seen, ranked = set(), []




        for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




if r["release_id"] in seen: continue




seen.add(r["release_id"]); ranked.append(r)




        return ranked




    




    def _import_accept(self):




        if app._import_idx >= len(app._import_offers): return




        o = app._import_offers[app._import_idx]




        top = (app._import_candidates[0] if app._import_candidates else None)




        if not top:




messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




        sku = (o.get("sku") or "").strip()




        now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




        with app.db.get_connection() as conn:




c = conn.cursor()




c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




exists = c.fetchone() is not None




if exists:




    c.execute("""UPDATE inventory




                 SET discogs_listing_id = ?,




                     discogs_match_method = ?, discogs_match_confidence = ?,




                     barcode = COALESCE(?, barcode),




                     inv_updated_at = ?




                 WHERE sku = ?""", 




              (str(top["release_id"]), top["method"], float(top["confidence"]),




               (o.get("gtin") or None), now_iso, sku))




else:




    c.execute("""INSERT INTO inventory




                 (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                  barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




              (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




               (o.get("listingId") or None), str(top["release_id"]),




               (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




        app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




        app._import_idx += 1




        app._import_propose_current()




    




    def _import_alternatives(self):




        if not app._import_candidates:




messagebox.showinfo("Alternatives", "No candidates available for this item."); return




        top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




        lb = tk.Listbox(top, width=90, height=10)




        for i, r in enumerate(app._import_candidates[:12]):




lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




        lb.pack(fill="both", expand=True)




        def choose():




idx = lb.curselection()




if not idx: return




i = idx[0]




chosen = app._import_candidates[i]




rest = [r for j,r in enumerate(app._import_candidates) if j != i]




app._import_candidates = [chosen] + rest




top.destroy()




app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




        tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




        app._import_idx += 1




        app._import_propose_current()





    def action_ebay_sync_selected(self):

        """Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

        items = app.inventory_tree.selection()

        if not items:

try:

    messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

except Exception:

    pass

return

        skus = []

        for iid in items:

vals = app.inventory_tree.item(iid, "values")

if not vals:

    continue

skus.append(vals[0])

        try:

app.reconcile_from_ebay(skus)

        except Exception as e:

try:

    messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

except Exception:

    pass


    def action_discogs_save_unpublished(self):
        """Create Discogs draft listings"""
        if app.notebook.tab(app.notebook.select(), "text") == "Lister":
app._create_discogs_draft_from_lister()
        else:
app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
        """Create live Discogs listings"""
        if app.notebook.tab(app.notebook.select(), "text") == "Lister":
# Create live listing instead of draft
app._list_on_discogs_live()
        else:
# Modify existing publish_to_discogs to use "For Sale" status
app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
        """Save current lister form as eBay-ready in database with duplicate checking"""
        try:
# Validate required fields
required_fields = ['artist', 'title', 'media_condition']
for field in required_fields:
    if not app.entries[field.replace(' ', '_')].get().strip():
        messagebox.showwarning("Validation Error", f"Please enter {field}")
        return

try:
    price = float(app.price_entry.get())
    if price <= 0:
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

# Generate SKU if needed
sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
if not app.editing_sku and not app.temporary_sku:
    app.sku_display_var.set(sku)

# Check for existing listings and warn user
existing = app._check_existing_listings(sku)
if existing['has_ebay'] or existing['has_ebay_draft']:
    warning_parts = []
    if existing['has_ebay']:
        warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
    if existing['has_ebay_draft']:
        warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
    
    warning_text = "\n".join(warning_parts)
    message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
              f"This will update the existing record. Continue?")
    
    if not messagebox.askyesno("Existing eBay Data Found", message):
        return

# Save to database with special status
payload_json = json.dumps(app._serialize_form_to_payload())

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        if app.editing_sku:
            # Update existing
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?,
                lister_payload = ?
                WHERE sku = ?
            """, (now_iso, payload_json, sku))
            message = f"Updated SKU {sku} as ready for eBay"
        else:
            # Create new with basic info
            cursor.execute("""
                INSERT INTO inventory (
                    sku, artist, title, price, status, date_added, 
                    last_modified, lister_payload
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                sku,
                app.entries["artist"].get().strip(),
                app.entries["title"].get().strip(), 
                price,
                'eBay Ready',
                now_iso,
                now_iso,
                payload_json
            ))
            message = f"Saved SKU {sku} as ready for eBay"
        
        app.populate_inventory_view()
        app.append_log(message, "green")
        messagebox.showinfo("eBay Draft Saved", 
            f"{message}\n\n" +
            f"Note: This creates a local draft in your database.\n" + 
            f"eBay doesn't provide draft functionality via their public API.\n" +
            f"Use 'Publish Live' when ready to list on eBay.")
        
except Exception as e:
    logger.error(f"Failed to save eBay draft: {e}")
    messagebox.showerror("Database Error", f"Failed to save: {e}")
    
        except Exception as e:
logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
        """Mark selected inventory items as ready for eBay"""
        selected = app.inventory_tree.selection()
        if not selected:
messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
return
        
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
    
    updated_count = 0
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        cursor.execute("""
            UPDATE inventory SET 
            status = 'eBay Ready',
            last_modified = ?
            WHERE sku = ?
        """, (now_iso, sku))
        updated_count += 1
    
    app.populate_inventory_view()
    message = f"Marked {updated_count} item(s) as ready for eBay"
    app.append_log(message, "green")
    messagebox.showinfo("Success", message)
    
        except Exception as e:
logger.error(f"Failed to mark items as eBay ready: {e}")
messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
        """Create Discogs draft from current lister form"""
        if not app.discogs_api.is_connected():
messagebox.showwarning("Not Connected", "Please connect to Discogs first")
return

        if not app.current_release_id:
messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
return

        try:
price = float(app.price_entry.get())
media_condition = app.entries["media_condition"].get()
if not media_condition or media_condition not in REVERSE_GRADE_MAP:
    messagebox.showwarning("Validation Error", "Please select a valid media condition")
    return
        except (ValueError, TypeError):
messagebox.showwarning("Validation Error", "Please enter a valid price")
return
        
        listing_data = {
'release_id': app.current_release_id,
'price': price,
'status': 'Draft',  # Explicitly set as draft
'condition': REVERSE_GRADE_MAP.get(media_condition),
'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
'comments': app.full_desc.get("1.0", tk.END).strip()
        }
        
        app.root.config(cursor="watch")
        app.root.update()
        
        def draft_worker():
try:
    listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
    if listing_id:
        app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        
        threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
        """Create Discogs drafts from selected inventory items"""
        selected = app.inventory_tree.selection()
        if not selected:
messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
return
        
        def draft_worker():
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue
        
        errors = validate_listing("discogs", record, app.config)
        if errors:
            app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
            continue
        
        app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
        listing_data = {
            "release_id": record.get("discogs_release_id"),
            "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
            "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
            "price": record.get("price", 0), 
            "status": "Draft",  # Create as draft
            "comments": record.get("description", "")
        }
        
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                        (listing_id, now_iso, sku),
                    )
            except Exception as e:
                logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
        else:
            app.append_log(f"SKU {sku}: Failed to create draft", "red")
    except Exception as e:
        app.append_log(f"SKU {sku}: Error - {e}", "red")

app.safe_after(0, app.populate_inventory_view)
        
        threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
        """Create live Discogs listing (For Sale status) from lister form"""
        if not app.discogs_api.is_connected():
messagebox.showwarning("Not Connected", "Please connect to Discogs first")
return

        if not app.current_release_id:
messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
return

        try:
price = float(app.price_entry.get())
media_condition = app.entries["media_condition"].get()
if not media_condition or media_condition not in REVERSE_GRADE_MAP:
    messagebox.showwarning("Validation Error", "Please select a valid media condition")
    return
        except (ValueError, TypeError):
messagebox.showwarning("Validation Error", "Please enter a valid price")
return
        
        listing_data = {
'release_id': app.current_release_id,
'price': price,
'status': 'For Sale',  # Live listing
'condition': REVERSE_GRADE_MAP.get(media_condition),
'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
'comments': app.full_desc.get("1.0", tk.END).strip()
        }
        
        app.root.config(cursor="watch")
        app.root.update()
        
        def live_worker():
try:
    listing_id = app.discogs_api.create_listing(listing_data)
    if listing_id:
        app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        
        threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
        """Publish selected items to Discogs as live (For Sale) listings"""
        selected = app.inventory_tree.selection()
        if not selected: 
return
        
        def live_worker():
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue
        
        errors = validate_listing("discogs", record, app.config)
        if errors:
            app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
            continue
        
        app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
        listing_data = {
            "release_id": record.get("discogs_release_id"),
            "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
            "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
            "price": record.get("price", 0), 
            "status": "For Sale",  # Live listing
            "comments": record.get("description", "")
        }
        
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                        (listing_id, now_iso, sku),
                    )
            except Exception as e:
                logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
        else:
            app.append_log(f"SKU {sku}: Failed to create live listing", "red")
    except Exception as e:
        app.append_log(f"SKU {sku}: Error - {e}", "red")

app.safe_after(0, app.populate_inventory_view)
        
        threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
        """Handle successful Discogs draft creation"""
        messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
        if app.editing_sku:
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
except Exception as e:
    logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
        """Handle successful Discogs live listing creation"""
        messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
        if app.editing_sku:
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
except Exception as e:
    logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
        """Prepare all eBay listing data from current form"""
        format_val = app.entries["format"].get() or "LP"
        media_cond_str = app.entries["media_condition"].get()
        
        condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
        condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
        category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")
        
        ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
        description_html = app.full_desc.get("1.0", tk.END).strip()

        return {
"sku": sku,
"title": ebay_title[:80],
"description": description_html,
"categoryId": str(category_id),
"price": float(app.price_entry.get()),
"quantity": 1,
"condition_enum": condition_enum,
"condition_id_numeric": condition_id_numeric,
"media_condition": app.entries["media_condition"].get(),
"sleeve_condition": app.entries["sleeve_condition"].get(),
"currency": "GBP",
"marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
"paymentPolicyId": app.config.get("ebay_payment_policy_id"),
"returnPolicyId": app.config.get("ebay_return_policy_id"),
"shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
"images": app.image_paths,
        }


    def refresh_button_states(self):
        """Refresh all button states based on current connection status"""
        app._update_connection_status()
        # Trigger inventory selection update if items are selected
        if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
        """Check what listings already exist for this SKU"""
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("""
        SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
        FROM inventory WHERE sku = ?
    """, (sku,))
    row = cursor.fetchone()
    
    if row:
        return {
            'ebay_listing_id': row[0],
            'discogs_listing_id': row[1], 
            'ebay_draft_id': row[2],
            'status': row[3],
            'has_ebay': bool(row[0]),
            'has_discogs': bool(row[1]),
            'has_ebay_draft': bool(row[2])
        }
    else:
        return {
            'ebay_listing_id': None,
            'discogs_listing_id': None,
            'ebay_draft_id': None,
            'status': None,
            'has_ebay': False,
            'has_discogs': False,
            'has_ebay_draft': False
        }
        except Exception as e:
logger.error(f"Error checking existing listings for {sku}: {e}")
return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
        """Ask user to confirm if they want to overwrite/update existing listing"""
        existing_ids = []
        if platform.lower() == 'ebay':
if existing_info.get('has_ebay'):
    existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
if existing_info.get('has_ebay_draft'):
    existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
        elif platform.lower() == 'discogs':
if existing_info.get('has_discogs'):
    existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")
        
        if not existing_ids:
return True  # No existing listings, safe to proceed
        
        existing_text = "\n".join(existing_ids)
        message = (
f"SKU {sku} already has existing {platform} listing(s):\n\n"
f"{existing_text}\n\n"
f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
f"Choose 'Yes' to update existing listing\n"
f"Choose 'No' to cancel and avoid duplicates"
        )
        
        return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
        """Safely publish to eBay with duplicate prevention"""
        # Check for existing listings
        existing = app._check_existing_listings(sku)
        
        # Determine what action to take
        action_type = "draft" if is_draft else "live"
        
        if existing['has_ebay'] and not is_draft:
# Has live listing, asking to publish live again
if not app._confirm_overwrite_action('eBay', sku, existing):
    return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}

# User wants to update - modify existing listing
app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
# Use existing eBay update logic here
return app.ebay_api.create_draft_listing(listing_data)  # This handles updates

        elif existing['has_ebay_draft'] and is_draft:
# Has draft, asking to create another draft
if not app._confirm_overwrite_action('eBay', sku, existing):
    return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}

app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
# Proceed with update

        elif existing['has_ebay'] and is_draft:
# Has live listing, wants to create draft - warn but allow
message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
          f"Creating a draft will not affect the live listing.\n"
          f"Continue?")
if not messagebox.askyesno("Live Listing Exists", message):
    return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}
        
        # Proceed with creation/update
        result = app.ebay_api.create_draft_listing(listing_data)
        
        # Log the action
        if result.get('success'):
action_desc = "draft saved" if is_draft else "published live"
app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")
        
        return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
        """Safely publish to Discogs with duplicate prevention"""
        existing = app._check_existing_listings(sku)
        
        if existing['has_discogs']:
if not app._confirm_overwrite_action('Discogs', sku, existing):
    app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
    return None

# User wants to update existing listing
discogs_id = existing['discogs_listing_id']
app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")

# Update instead of create
success = app.discogs_api.update_listing(discogs_id, listing_data)
if success:
    app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
    return discogs_id
else:
    app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
    return None
        
        # No existing listing, safe to create new
        action_desc = "draft" if is_draft else "live listing"
        app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")
        
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")
        
        return listing_id


    def log_sync_activity(self, message):
        """Log sync activity to the text widget"""
        def do_log():
timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
app.sync_log_text.config(state="normal")
app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
app.sync_log_text.see(tk.END)
app.sync_log_text.config(state="disabled")
        app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
        messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
        sys.exit(1)
        
    try:
        # Before starting, check for requests_toolbelt
        try:
import requests_toolbelt
        except ImportError:
 messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
 sys.exit(1)

        root = tk.Tk()
        app = VinylToolApp(root)
        root.mainloop()
    except Exception as e:
        # Create a simple Tk window to show the error if the main app fails
        try:
root = tk.Tk()
root.withdraw() # Hide the main window
messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
        except:
# Fallback to console if GUI fails completely
print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
        sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
        src_dir = _Path(__file__).resolve().parent
        backups = src_dir / "backups"
        backups.mkdir(exist_ok=True)
        active_profile = "dev"
        active_file = src_dir / "profiles" / "active_profile.json"
        try:
data = json.loads(active_file.read_text())
if isinstance(data, dict) and data.get("profile"):
    active_profile = str(data["profile"])
        except Exception:
pass
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        fname = backups / f"backup_{ts}.tar.gz"
        with tarfile.open(fname, "w:gz") as tar:
for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
    p = src_dir / name
    if p.exists():
        tar.add(p, arcname=p.name)
prof = src_dir / "profiles" / active_profile / "data"
if prof.exists():
    tar.add(prof, arcname=f"profiles/{active_profile}/data")
        print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
        print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def draft_worker(app):
# Force the eBay API wrapper to refresh the access token on each
# draft creation. This ensures that any newly added scopes (e.g.
# sell.listing) are included in the token. Without this, the
# cached access token may not contain the required scope and
# draft creation can fail silently.
try:
    app.ebay_api.access_token = None
except Exception:
    pass
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue

        # Check latest-wins management: warn if remote data is newer than local
        try:
            local_ts = record.get("inv_updated_at") or record.get("last_modified") or record.get("date_added")
            remote_ts = record.get("ebay_updated_at")
            proceed = True
            if remote_ts and local_ts:
                try:
                    ldt = datetime.datetime.fromisoformat(str(local_ts).replace('Z','+00:00'))
                    rdt = datetime.datetime.fromisoformat(str(remote_ts).replace('Z','+00:00'))
                    if rdt > ldt:
                        msg = (f"SKU {sku}: The eBay data was updated more recently than your local copy.\n"
                               f"Local updated: {ldt.isoformat()}\n"
                               f"eBay updated: {rdt.isoformat()}\n\n"
                               "Proceeding will overwrite eBay with local data. Continue?")
                        proceed = messagebox.askyesno("Potential Conflict", msg)
                except Exception:
                    pass
            if not proceed:
                app.append_log(f"SKU {sku}: Skipped due to newer eBay data.", "orange")
                continue
        except Exception:
            pass

        # Build listing_data similar to publish_to_ebay
        format_val = record.get("format", "LP")
        media_cond_str = record.get("media_condition", "")
        # Map media grade to eBay enums/IDs. Use "USED_GOOD" and 3000 as
        # safe fallbacks for unknown grades. The numeric ID will not be
        # transmitted for the Records category.
        condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
        condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
        category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")
        listing_data = {
            "sku": sku,
            "title": record.get("listing_title") or record.get("title", "")[:80],
            "description": record.get("description", ""),
            "price": record.get("price", 0),
            "quantity": 1,
            "categoryId": category_id,
            "condition_enum": condition_enum,
            "condition_id_numeric": condition_id_numeric,
            "media_condition": record.get("media_condition"),
            "sleeve_condition": record.get("sleeve_condition"),
            "images": record.get("images", []),
            "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
            "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
            "returnPolicyId": app.config.get("ebay_return_policy_id"),
            "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
            "currency": "GBP"
        }
        # Attempt to collect image URLs if necessary
        try:
            # Convert local images to eBay-hosted URLs if none exist
            if not listing_data.get("images") and record.get("image_urls"):
                listing_data["imageUrls"] = record.get("image_urls")
            else:
                # Fallback: rely on eBay API wrapper to upload images
                listing_data["images"] = record.get("images", [])
        except Exception:
            pass

        res = app.ebay_api.create_sell_listing_draft(listing_data)
        if res.get("success"):
            draft_id = res.get("draftId")
            # Write back ID and timestamp
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET ebay_item_draft_id = ?, ebay_updated_at = ? WHERE sku = ?",
                        (draft_id, now_iso, sku),
                    )
                app.append_log(f"SKU {sku}: eBay draft created (Draft ID: {draft_id}).", "green")
            except Exception as e:
                app.append_log(f"SKU {sku}: Draft created but failed to save ID to DB: {e}", "red")
        else:
            err = res.get("error") or res.get("body")
            status = res.get("status")
            if status:
                app.append_log(f"SKU {sku}: Failed to create eBay draft (status {status}): {err}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create eBay draft: {err}", "red")
    except Exception as e:
        app.append_log(f"SKU {sku}: Unexpected error during draft creation: {e}", "red")

# Refresh inventory view on the main thread
app.safe_after(0, lambda: app.populate_inventory_view(app.inventory_search_var.get()))
app.safe_after(0, lambda: app.root.config(cursor=""))

        # Show busy cursor and start background thread
        app.root.config(cursor="watch")
        app.root.update()
        threading.Thread(target=draft_worker, daemon=True).start()

    def open_listing_in_browser(self):
        """
        Open the appropriate listing page in the user's default web browser for the selected
        inventory item. Priority is given to eBay drafts, then live eBay listings,
        then Discogs listings.
        """
        selected = app.inventory_tree.focus()
        if not selected:
return
        sku = app.inventory_tree.item(selected, "values")[0]
        try:
record = app._get_inventory_record(sku)
# Try to open eBay draft if present
draft_id = record.get("ebay_item_draft_id")
if draft_id:
    # eBay does not provide direct draft URLs; open drafts overview
    webbrowser.open_new_tab("https://www.ebay.co.uk/sh/lst/drafts")
    return
live_id = record.get("ebay_listing_id")
if live_id:
    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{live_id}")
    return
discogs_id = record.get("discogs_listing_id")
if discogs_id:
    webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{discogs_id}")
    return
messagebox.showinfo("No Listing", "This item does not have any listing IDs yet.")
        except Exception as e:
logger.error(f"Failed to open listing: {e}")
messagebox.showerror("Error", f"Failed to open listing: {e}")
    
    def append_log(self, message, color="black"):
        """Append message to publish log"""
        def do_append():
timestamp = datetime.datetime.now().strftime("[%H:%M:%S]")
app.publish_log.config(state="normal")
app.publish_log.insert("end", f"{timestamp} {message}\n", (color,))
app.publish_log.tag_configure("red", foreground="red")
app.publish_log.tag_configure("green", foreground="green")
app.publish_log.tag_configure("black", foreground="black")
app.publish_log.see("end")
app.publish_log.config(state="disabled")
        app.safe_after(0, do_append)

    def show_inventory_context_menu(self, event):
        """Show inventory context menu"""
        row_id = app.inventory_tree.identify_row(event.y)
        if row_id:
app.inventory_tree.selection_set(row_id)
app.inventory_tree.focus(row_id)
app.inventory_context_menu.post(event.x_root, event.y_root)
    
    def show_discogs_context_menu(self, event):
        """Show Discogs results context menu"""
        row_id = app.discogs_tree.identify_row(event.y)
        if row_id:
app.discogs_tree.selection_set(row_id)
app.discogs_tree.focus(row_id)
app.discogs_context_menu.post(event.x_root, event.y_root)
    
    def open_discogs_listing(self):
        """Open Discogs listing for selected inventory item"""
        selected = app.inventory_tree.focus()
        if not selected: return
        sku = app.inventory_tree.item(selected, "values")[0]
        try:
record = app._get_inventory_record(sku)
if record.get("discogs_listing_id"):
    webbrowser.open_new_tab(f"https://www.discogs.com/sell/item/{record['discogs_listing_id']}")
else:
    messagebox.showinfo("No Discogs Listing", "This item has no Discogs listing ID.")
        except Exception as e:
logger.error(f"Failed to open Discogs listing: {e}")
    
    def open_ebay_listing(self):
        """Open eBay listing for selected inventory item"""
        selected = app.inventory_tree.focus()
        if not selected: return
        sku = app.inventory_tree.item(selected, "values")[0]
        try:
record = app._get_inventory_record(sku)
if record.get("ebay_listing_id"):
    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{record['ebay_listing_id']}")
else:
    messagebox.showinfo("No eBay Listing", "This item has no eBay listing ID.")
        except Exception as e:
logger.error(f"Failed to open eBay listing: {e}")
    
    def open_discogs_release_from_inventory(self):
        """Open Discogs release page for selected inventory item"""
        selected = app.inventory_tree.focus()
        if not selected: return
        sku = app.inventory_tree.item(selected, "values")[0]
        try:
record = app._get_inventory_record(sku)
if record.get("discogs_release_id"):
    webbrowser.open_new_tab(f"https://www.discogs.com/release/{record['discogs_release_id']}")
else:
    messagebox.showinfo("No Release Linked", "This item has no Discogs release ID.")
        except Exception as e:
logger.error(f"Failed to open release page: {e}")
    
    def open_discogs_release_page(self):
        """Open selected release on Discogs website"""
        selected = app.discogs_tree.focus()
        if not selected: return
        release_id = app.discogs_tree.item(selected, "values")[0]
        webbrowser.open_new_tab(f"https://www.discogs.com/release/{release_id}")
    
    def open_sold_listings_from_selection(self, platform):
        """Open sold listings search for selected Discogs result"""
        selected = app.discogs_tree.focus()
        if not selected: return
        _, artist, title, catno, _, _, _ = app.discogs_tree.item(selected, "values")
        query = f"{artist} {title} {catno}".strip()
        url = f"https://www.ebay.co.uk/sch/i.html?_nkw={quote_plus(query)}&_sacat=176985&LH_Sold=1&LH_Complete=1" if platform == "eBay" else f"https://www.discogs.com/search/?q={quote_plus(query)}&type=all"
        webbrowser.open_new_tab(url)
    
    def get_price_suggestion(self):
        """Get price suggestions for selected release"""
        selected = app.discogs_tree.focus()
        if not selected: return
        release_id = int(app.discogs_tree.item(selected, "values")[0])
        app.root.config(cursor="watch")
        app.root.update()
        def fetch_worker():
try:
    suggestions = app.discogs_api.get_price_suggestions(release_id)
    if suggestions:
        msg = "Price Suggestions:\n\n" + "\n".join([f"{condition}: £{price_data['value']:.2f}" for condition, price_data in suggestions.items()])
        app.safe_after(0, lambda: messagebox.showinfo("Price Suggestions", msg))
    else:
        app.safe_after(0, lambda: messagebox.showinfo("No Data", "No price suggestions available"))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=fetch_worker, daemon=True).start()
    
    def refresh_discogs_view(self, event=None):
        """Refresh Discogs results with filter"""
        filter_text = app.discogs_search_filter_var.get().lower()
        if not app.discogs_search_results: return
        for item in app.discogs_tree.get_children(): app.discogs_tree.delete(item)
        for result in app.discogs_search_results:
artist, title = (result.get("title", "").split(" - ", 1) + [""])[:2]
if filter_text and filter_text not in f"{artist} {title} {result.get('catno', '')} {result.get('year', '')}".lower(): continue
values = (result.get("id"), artist, title, result.get("catno", "N/A"), result.get("year", "N/A"), result.get("country", "N/A"), ", ".join(result.get("format", [])))
app.discogs_tree.insert("", "end", values=values)
    
    def sort_discogs_results(self, col):
        """Sort Discogs results by column"""
        if app.discogs_sort_column == col:
app.discogs_sort_direction = "ASC" if app.discogs_sort_direction == "DESC" else "DESC"
        else:
app.discogs_sort_column, app.discogs_sort_direction = col, "ASC"
        if app.discogs_search_results:
def sort_key(item):
    if col == "Artist": return (item.get("title", "").split(" - ", 1) + [""])[0].lower()
    elif col == "Title": return (item.get("title", "").split(" - ", 1) + [""])[1].lower()
    elif col == "Year":
        try: return int(item.get("year", 0))
        except: return 0
    else: return str(item.get(col.lower(), "")).lower()
app.discogs_search_results.sort(key=sort_key, reverse=(app.discogs_sort_direction == "DESC"))
app.refresh_discogs_view()
    
    def authenticate_discogs(self):
        """Authenticate with Discogs"""
        consumer_key = app.config.get("discogs_consumer_key")
        consumer_secret = app.config.get("discogs_consumer_secret")
        if not consumer_key or not consumer_secret:
messagebox.showerror("Configuration Error", "Discogs Consumer Key/Secret not found in config.json.\nPlease add these to your configuration file.")
return
        try:
client = discogs_client.Client("VinylListingTool/5.1", consumer_key=consumer_key, consumer_secret=consumer_secret)
token, secret, url = client.get_authorize_url()
webbrowser.open(url)
pin = simpledialog.askstring("Discogs Authentication", "Please enter the verification code from Discogs:")
if not pin: return
access_token, access_secret = client.get_access_token(pin)
app.config.save({"discogs_oauth_token": access_token, "discogs_oauth_token_secret": access_secret})
app.discogs_api = DiscogsAPI(app.config)
if app.discogs_api.is_connected():
    app._update_connection_status()
    messagebox.showinfo("Success", "Successfully connected to Discogs!")
else:
    messagebox.showerror("Error", "Failed to connect to Discogs")
        except Exception as e:
logger.error(f"Discogs authentication failed: {e}")
messagebox.showerror("Authentication Error", str(e))
    
    def test_ebay_connection(self):
        """Test eBay connection"""
        if app.ebay_api.test_connection():
app.ebay_auth_status_var.set("Connected")
messagebox.showinfo("Success", "Successfully connected to eBay!")
        else:
app.ebay_auth_status_var.set("Not Connected")
messagebox.showerror("Connection Failed", "Could not connect to eBay.\nPlease check your credentials in config.json")
    
    def check_discogs_sales(self):
        """Check for Discogs sales"""
        if not app.discogs_api.is_connected(): return
        app.root.config(cursor="watch"); app.root.update()
        def sales_worker():
try:
    orders = app.discogs_api.get_orders(['Payment Received', 'Shipped'])
    app.safe_after(0, lambda: app._display_discogs_sales(orders))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_discogs_sales(self, orders):
        """Display Discogs sales"""
        for item in app.sales_tree.get_children(): app.sales_tree.delete(item)
        if not orders:
messagebox.showinfo("No Sales", "No sales with status 'Payment Received' or 'Shipped' found.")
return
        for order in orders:
for item in order.items:
    artist = item.release.artists[0].name if item.release.artists else "Various"
    title = item.release.title.replace(f"{artist} - ", "", 1).strip()
    sale_date = datetime.datetime.strptime(order.data['created'][:10], "%Y-%m-%d").strftime("%d-%m-%Y")
    sale_price = f"{item.price.value} {item.price.currency}"
    values = (order.id, sale_date, order.buyer.username, artist, title, sale_price, item.release.id)
    app.sales_tree.insert("", "end", values=values)
    
    def sync_discogs_sale(self):
        """Sync selected Discogs sale to inventory"""
        selected = app.sales_tree.focus()
        if not selected: return
        release_id = app.sales_tree.item(selected, "values")[6]
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT sku FROM inventory WHERE discogs_release_id = ? AND status = 'For Sale'", (release_id,))
    record = cursor.fetchone()
    if record:
        sku = record[0]
        if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
            app.update_inventory_status("Sold")
            messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
    else:
        messagebox.showwarning("No Match", f"Could not find an unsold item with Release ID: {release_id}.")
        except Exception as e:
logger.error(f"Failed to sync sale: {e}")
messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def check_ebay_sales(self):
        """Check for eBay sales"""
        if not app.ebay_api.test_connection(): return
        try:
start_date = datetime.datetime.strptime(app.ebay_start_date_var.get(), "%d-%m-%Y")
end_date = datetime.datetime.strptime(app.ebay_end_date_var.get(), "%d-%m-%Y")
if (end_date - start_date).days > 30:
    messagebox.showerror("Date Range Error", "The date range cannot exceed 30 days.")
    return
        except ValueError:
messagebox.showerror("Date Format Error", "Please enter dates in DD-MM-YYYY format.")
return
        app.root.config(cursor="watch"); app.root.update()
        def sales_worker():
try:
    orders = app.ebay_api.get_orders(start_date, end_date)
    app.safe_after(0, lambda: app._display_ebay_sales(orders))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=sales_worker, daemon=True).start()
    
    def _display_ebay_sales(self, orders):
        """Display eBay sales"""
        for item in app.ebay_sales_tree.get_children(): app.ebay_sales_tree.delete(item)
        if not orders:
messagebox.showinfo("No eBay Sales", "No completed sales found in the specified date range.")
return
        for order in orders:
order_id, created_date, buyer = order.get("orderId"), order.get("creationDate", "")[:10], order.get("buyer", {}).get("username", "")
for line_item in order.get("lineItems", []):
    title, price, currency, item_id = line_item.get("title", ""), line_item.get("lineItemCost", {}).get("value", ""), line_item.get("lineItemCost", {}).get("currency", "GBP"), line_item.get("legacyItemId", "")
    artist, album_title = "", title
    if ":" in title:
        parts = title.split(":", 1)
        artist, album_title = parts[0].strip(), parts[1].strip()
    values = (order_id, created_date, buyer, artist, album_title, f"{price} {currency}", item_id)
    app.ebay_sales_tree.insert("", "end", values=values)
    
    def sync_ebay_sale(self):
        """Sync selected eBay sale to inventory"""
        selected = app.ebay_sales_tree.focus()
        if not selected: return
        _, _, _, artist, title, _, item_id = app.ebay_sales_tree.item(selected, "values")
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT sku FROM inventory WHERE (ebay_listing_id = ? OR (artist LIKE ? AND title LIKE ?)) AND status = 'For Sale'", (item_id, f"%{artist}%", f"%{title}%"))
    record = cursor.fetchone()
    if record:
        sku = record[0]
        if messagebox.askyesno("Confirm Sync", f"Found matching item (SKU: {sku}). Mark as 'Sold'?"):
            app.update_inventory_status("Sold")
            messagebox.showinfo("Success", f"SKU {sku} marked as Sold.")
    else:
        messagebox.showwarning("No Match", f"Could not find an unsold item matching:\n{artist} - {title}")
        except Exception as e:
logger.error(f"Failed to sync sale: {e}")
messagebox.showerror("Database Error", f"Could not sync sale: {e}")
    
    def start_discogs_import(self):
        """Import inventory from Discogs"""
        if not app.discogs_api.is_connected(): return
        if not messagebox.askyesno("Confirm Import", "This will import all 'For Sale' items from Discogs.\nExisting items will be skipped.\n\nContinue?"): return
        app.root.config(cursor="watch"); app.root.update()
        def import_worker():
try:
    inventory = app.discogs_api.get_inventory()
    app.safe_after(0, lambda: app._process_discogs_import(inventory))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Import Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=import_worker, daemon=True).start()
    
    def _process_discogs_import(self, inventory):
        """Process Discogs import"""
        new_items, skipped_items = 0, 0
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    for listing in inventory:
        if listing.status != 'For Sale': continue
        cursor.execute("SELECT COUNT(*) FROM inventory WHERE discogs_listing_id = ?", (listing.id,))
        if cursor.fetchone()[0] > 0:
            skipped_items += 1
            continue
        new_items += 1
        artist = listing.release.artists[0].name if listing.release.artists else "Various"
        title = listing.release.title.replace(f"{artist} - ", "", 1).strip()
        sku = datetime.datetime.now().strftime(f"%Y%m%d-%H%M%S-{new_items}")
        now = datetime.datetime.now(datetime.timezone.utc).isoformat()
        sql = """INSERT INTO inventory (sku, artist, title, cat_no, media_condition, sleeve_condition, price, status, discogs_release_id, discogs_listing_id, date_added, last_modified) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"""
        media_cond = DISCOGS_GRADE_MAP.get(listing.condition, listing.condition)
        sleeve_cond = DISCOGS_GRADE_MAP.get(listing.sleeve_condition, listing.sleeve_condition)
        catno = getattr(listing.release, 'catno', '')
        cursor.execute(sql, (sku, artist, title, catno, media_cond, sleeve_cond, listing.price.value, "For Sale", listing.release.id, listing.id, now, now))
messagebox.showinfo("Import Complete", f"Successfully imported {new_items} new item(s).\nSkipped {skipped_items} existing item(s).")
app.populate_inventory_view()
        except Exception as e:
logger.error(f"Import failed: {e}")
messagebox.showerror("Import Error", f"An error occurred during import:\n{e}")
    
    def toggle_auto_sync(self):
        """Toggle automatic sync"""
        if not app.discogs_api.is_connected():
messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
app.auto_sync_var.set(False)
return
        app.auto_sync_enabled = app.auto_sync_var.get()
        app.config.save({"auto_sync_enabled": app.auto_sync_enabled})
        if app.auto_sync_enabled: app.start_auto_sync()
        else: app.stop_auto_sync()
    
    def toggle_two_way_sync(self):
        """Toggle two-way sync"""
        app.two_way_sync_enabled = app.two_way_sync_var.get()
        app.config.save({"two_way_sync_enabled": app.two_way_sync_enabled})
        app.log_sync_activity(f"Two-way sync {'enabled' if app.two_way_sync_enabled else 'disabled'}")
    
    def toggle_attempt_updates(self):
        """Toggle attempt to update Discogs"""
        app.attempt_discogs_updates = app.attempt_updates_var.get()
        app.config.save({"attempt_discogs_updates": app.attempt_discogs_updates})
        app.log_sync_activity(f"Discogs update attempts {'enabled' if app.attempt_discogs_updates else 'disabled'}")
    
    def update_sync_interval(self):
        """Update sync interval"""
        try:
minutes = int(app.sync_interval_var.get())
app.auto_sync_interval = minutes * 60
app.config.save({"auto_sync_interval": app.auto_sync_interval})
app.log_sync_activity(f"Sync interval set to {minutes} minutes")
        except ValueError: app.sync_interval_var.set("5")
    
    def start_auto_sync(self):
        """Start automatic sync"""
        if app.auto_sync_thread and app.auto_sync_thread.is_alive(): return
        app.auto_sync_stop_event.clear()
        app.auto_sync_thread = threading.Thread(target=app._auto_sync_worker, daemon=True)
        app.auto_sync_thread.start()
        app.sync_status_var.set("Auto-sync enabled - waiting for next sync...")
        app.log_sync_activity("Automatic sync started")
    
    def stop_auto_sync(self):
        """Stop automatic sync"""
        app.auto_sync_stop_event.set()
        app.sync_status_var.set("Auto-sync disabled")
        app.log_sync_activity("Automatic sync stopped")
    
    def _auto_sync_worker(self):
        """Auto sync worker thread"""
        while not app.auto_sync_stop_event.is_set():
try:
    if app.auto_sync_stop_event.wait(app.auto_sync_interval): break
    if app.auto_sync_enabled and app.discogs_api.is_connected():
        app.safe_after(0, lambda: app.sync_status_var.set("Syncing inventory..."))
        sync_result = app._perform_inventory_sync()
        app.safe_after(0, lambda r=sync_result: app._handle_sync_result(r))
except Exception as e:
    app.safe_after(0, lambda msg=f"Auto-sync error: {e}": app.log_sync_activity(msg))
    
    def manual_sync_now(self):
        """Perform manual sync now"""
        if not app.discogs_api.is_connected():
messagebox.showwarning("Not Connected", "Please connect to your Discogs account first.")
return
        app.sync_status_var.set("Manual sync in progress...")
        app.root.config(cursor="watch"); app.root.update()
        def sync_worker():
try:
    result = app._perform_inventory_sync()
    app.safe_after(0, lambda: app._handle_sync_result(result))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Sync Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        threading.Thread(target=sync_worker, daemon=True).start()
    
    def _perform_inventory_sync(self):
        """Implements true "latest-wins" two-way sync logic."""
        sync_start_time = datetime.datetime.now(datetime.timezone.utc)
        app.log_sync_activity("=== STARTING SYNC (Latest-Wins) ===")
        try:
discogs_inventory = app.discogs_api.get_inventory()
discogs_map = {listing.id: listing for listing in discogs_inventory}
app.log_sync_activity(f"Retrieved {len(discogs_inventory)} active listings from Discogs.")

with app.db.get_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT sku, discogs_listing_id, price, status, notes, last_modified, last_sync_time FROM inventory WHERE discogs_listing_id IS NOT NULL")
    local_items = [dict(row) for row in cursor.fetchall()]
    local_map = {item['discogs_listing_id']: item for item in local_items}
app.log_sync_activity(f"Found {len(local_map)} linked local items.")

updates_to_local, updates_to_discogs, deletions_from_local, new_sales = 0, 0, 0, 0

for local_item in local_items:
    listing_id, last_mod_local_str, last_sync_str = local_item['discogs_listing_id'], local_item.get('last_modified'), app.last_successful_sync_time or local_item.get('last_sync_time')
    if not last_mod_local_str or not last_sync_str: continue
    try:
        last_mod_local, last_sync = datetime.datetime.fromisoformat(last_mod_local_str), datetime.datetime.fromisoformat(last_sync_str)
    except (ValueError, TypeError): continue

    if last_mod_local > last_sync and app.attempt_discogs_updates:
        if listing_id in discogs_map:
            app.log_sync_activity(f"→ Local change detected for SKU {local_item['sku']}. Pushing to Discogs.")
            update_payload = {"price": local_item['price'], "status": app._map_local_to_discogs_status(local_item['status']), "comments": local_item.get('notes', '')}
            if app.discogs_api.update_listing(listing_id, update_payload):
                updates_to_discogs += 1; app.log_sync_activity(f"  ✓ Pushed update for SKU {local_item['sku']} to Discogs.")
            else: app.log_sync_activity(f"  ✗ Failed to push update for SKU {local_item['sku']}.")
        else: app.log_sync_activity(f"  - SKU {local_item['sku']} changed locally but no longer on Discogs. Skipping push.")

    elif listing_id in discogs_map:
        listing = discogs_map[listing_id]
        mapped_status = app.status_mappings.get(listing.status, "Not For Sale")
        if mapped_status != local_item['status']:
            with app.db.get_connection() as conn:
                conn.cursor().execute("UPDATE inventory SET status = ?, last_modified = ? WHERE discogs_listing_id = ?", (mapped_status, sync_start_time.isoformat(), listing_id))
            updates_to_local += 1
            if mapped_status == 'Sold' and local_item['status'] != 'Sold': new_sales += 1
            app.log_sync_activity(f"✓ Sync from Discogs: SKU {local_item['sku']} '{local_item['status']}' → '{mapped_status}'")

ids_to_delete_locally = set(local_map.keys()) - set(discogs_map.keys())
if ids_to_delete_locally:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        for listing_id in ids_to_delete_locally:
            if local_map[listing_id]['status'] == 'For Sale':
                sku = local_map[listing_id]['sku']
                cursor.execute("DELETE FROM inventory WHERE discogs_listing_id = ?", (listing_id,))
                deletions_from_local += 1
                app.log_sync_activity(f"✓ Deleted SKU {sku} locally as it's no longer on Discogs.")

with app.db.get_connection() as conn:
    conn.cursor().execute("UPDATE inventory SET last_sync_time = ? WHERE discogs_listing_id IS NOT NULL", (sync_start_time.isoformat(),))
app.last_successful_sync_time = sync_start_time.isoformat()
app.config.save({"last_successful_sync_time": app.last_successful_sync_time})
if updates_to_local > 0 or deletions_from_local > 0: app.safe_after(0, app.populate_inventory_view)
app.log_sync_activity("=== SYNC COMPLETED ===")
return {'success': True, 'updates_local': updates_to_local, 'updates_discogs': updates_to_discogs, 'deletions': deletions_from_local, 'new_sales': new_sales, 'total_checked': len(discogs_inventory)}
        except Exception as e:
logger.error(f"Sync failed: {e}", exc_info=True)
app.log_sync_activity(f"✗ SYNC ERROR: {e}")
return {'success': False, 'error': str(e)}

    def _map_local_to_discogs_status(self, local_status):
        """Map local status to valid Discogs status"""
        return {'For Sale': 'For Sale', 'Sold': 'Sold'}.get(local_status, 'Draft')
    
    def _handle_sync_result(self, result):
        """Handle sync result"""
        current_time = datetime.datetime.now().strftime("%H:%M:%S")
        if result.get('success'):
updates_local, updates_discogs, deletions = result.get('updates_local', 0), result.get('updates_discogs', 0), result.get('deletions', 0)
total_changes = updates_local + updates_discogs + deletions
if total_changes > 0:
    log_msg = f"[{current_time}] Sync completed: {total_changes} changes from {result['total_checked']} listings"
    if updates_local > 0: log_msg += f"\n  - Pulled from Discogs: {updates_local}"
    if updates_discogs > 0: log_msg += f"\n  - Pushed to Discogs: {updates_discogs}"
    if deletions > 0: log_msg += f"\n  - Items deleted locally: {deletions}"
    if result.get('new_sales', 0) > 0: log_msg += f"\n  - New sales detected: {result['new_sales']}"
    app.log_sync_activity(log_msg)
    status_msg = f"Sync complete - {total_changes} change(s)"
else:
    status_msg = "Sync complete - no changes needed"
    app.log_sync_activity(f"[{current_time}] Sync completed. No changes needed.")
app.sync_status_var.set(f"Last sync: {current_time}. {status_msg}")
        else:
app.sync_status_var.set(f"Last sync: {current_time}. FAILED.")
app.log_sync_activity(f"[{current_time}] Sync FAILED: {result.get('error')}")

    # ========================================================================
    # ENHANCED PUBLISHING ACTION METHODS
    # ========================================================================
    
    def action_ebay_save_unpublished(self):
        """Save eBay listing data locally as 'ready to publish' without sending to eBay"""
        if app.notebook.tab(app.notebook.select(), "text") == "Lister":
# From Lister tab - save current form
app._save_ebay_draft_from_lister()
        else:
# From Inventory tab - mark selected items as ready for eBay
app._save_ebay_draft_from_inventory()

    def action_ebay_publish_live(self):
        """Publish directly to eBay as live listings (Inventory API)"""
        if app.notebook.tab(app.notebook.select(), "text") == "Lister":
# From Lister tab - publish current form directly
app.list_on_ebay()
        else:
# From Inventory tab - publish selected items
app.publish_to_ebay()



    def reconcile_from_ebay(self, skus):


        """Pull eBay state back into local DB so deletions/ends/relists are reflected.


        Chooses ACTIVE offer. Prefers Item ID (listingId); falls back to offerId if listingId hasn't propagated yet.


        Refreshes the grid when done.


        """


        import datetime, logging, requests


        logger = logging.getLogger(__name__)


    


        token = app.ebay_api.get_access_token()


        if not token:


app.append_log("Cannot reconcile: missing eBay token", "red")


return


    


        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}


        changed = False


    


        for sku in (skus or []):


try:


    url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={sku}"


    r = requests.get(url, headers=headers, timeout=30)


    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()


    


    if r.status_code == 200 and r.json().get("offers"):


        offers = r.json()["offers"]


        # Pick ACTIVE offer if available; otherwise first one


        active = None


        for o in offers:


            if (o.get("status") or "").upper() == "ACTIVE":


                active = o


                break


        offer = active or offers[0]


        status = (offer.get("status") or "").upper()


    


        listing_id = offer.get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('legacyItemId') or (offer.get('listing') or {}).get('listingId')


        offer_id = offer.get("offerId") or (offer.get("offer") or {}).get("offerId")


    


        # If ACTIVE but listingId missing, try GET /offer/{offerId} to resolve


        if status in ("ACTIVE","PUBLISHED") and not listing_id and offer_id:


            try:


                resolved = app.ebay_api.get_offer(str(offer_id))


                if resolved.get("success"):


                    listing_id = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')


            except Exception as e:


                logger.warning(f"[reconcile] get_offer failed for offer {offer_id}: {e}")


    


        with app.db.get_connection() as conn:


            c = conn.cursor()


            if status in ("ACTIVE","PUBLISHED"):


                stored_id = listing_id or (offer_id if offer_id else None)


                if stored_id:


                    c.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))


                    changed = True


                else:


                    c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                    changed = True


            else:


                c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                changed = True


    


        shown = listing_id or (offer_id if (status in ("ACTIVE","PUBLISHED") and offer_id) else "—")


        label = "Item ID" if listing_id else ("Offer ID" if shown != "—" else "—")  # live


        app.append_log(f"SKU {sku}: reconciled from eBay ({status}; {label}={shown})", "blue")


    else:


        with app.db.get_connection() as conn:


            c = conn.cursor()


            c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


        changed = True


        app.append_log(f"SKU {sku}: no eBay offer found; cleared local mapping.", "orange")


    


except Exception as e:


    logger.error(f"Reconcile error for {sku}: {e}")


    app.append_log(f"SKU {sku}: reconcile failed: {e}", "red")


    


        if changed:


try:


    app.populate_inventory_view()


except Exception:


    pass



    def action_open_on_ebay_selected(self):



        """Open the selected item's eBay listing in the browser using stored Item ID."""



        import webbrowser, requests, logging



        logger = logging.getLogger(__name__)



        items = app.inventory_tree.selection()



        if not items:



try:



    messagebox.showinfo("Open on eBay", "Please select a row first.")



except Exception:



    pass



return



        iid = items[0]



        vals = app.inventory_tree.item(iid, "values") or []



        item_id = None



        # Try visible column first



        try:



headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



if "eBay ID" in headers:



    idx = headers.index("eBay ID")



    if idx < len(vals):



        item_id = vals[idx]



        except Exception:



item_id = None



        # Fallback: DB lookup by SKU (assumes SKU in first column)



        if not item_id and vals:



sku = vals[0]



try:



    with app.db.get_connection() as conn:



        c = conn.cursor()



        c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



        row = c.fetchone()



        if row and row[0]:



            item_id = row[0]



except Exception:



    pass



        if not item_id:



try:



    messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



except Exception:



    pass



return



        # If it's likely an offerId, try resolve to listingId on the fly



        if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



try:



    token = app.ebay_api.get_access_token()



    if token:



        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



        url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



        r = requests.get(url, headers=headers, timeout=30)



        if r.status_code == 200 and r.json().get("offers"):



            offers = r.json()["offers"]



            active = None



            for o in offers:



                if (o.get("status") or "").upper() == "ACTIVE":



                    active = o



                    break



            off = active or offers[0]



            lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



            if not lid:



                oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                if oid:



                    resolved = app.ebay_api.get_offer(str(oid))



                    if resolved.get("success"):



                        lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



            if lid:



                item_id = lid



except Exception as e:



    logger.warning(f"[open] resolution failed: {e}")



        try:



webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



        except Exception:



try:



    messagebox.showerror("Open on eBay", "Failed to open browser.")



except Exception:



    pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




        try:




offers = app._fetch_all_ebay_offers()




        except Exception as e:




messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




return




        work = []




        with app.db.get_connection() as conn:




c = conn.cursor()




for off in offers:




    sku = (off.get("sku") or "").strip()




    if not sku:




        continue




    c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




    row = c.fetchone()




    if not row or not row[0]:




        work.append(off)




        if not work:




messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




return




        app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




        token = app.ebay_api.get_access_token()




        if not token:




raise RuntimeError("Missing eBay token")




        import requests




        hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




        base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




        offers, limit, offset = [], 200, 0




        while True:




resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




if resp.status_code != 200:




    raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




data = resp.json()




batch = data.get("offers") or []




for o in batch:




    aspects = (o.get("aspects") or {})




    gtin = None




    for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




        v = aspects.get(k)




        if isinstance(v, list) and v:




            gtin = v[0]; break




        if isinstance(v, str) and v.strip():




            gtin = v.strip(); break




    if not gtin:




        prod = o.get("product") or {}




        g = prod.get("gtin")




        if isinstance(g, list) and g:




            gtin = g[0]




        elif isinstance(g, str):




            gtin = g




    offers.append({




        "sku": o.get("sku"),




        "title": o.get("title") or (o.get("name") or ""),




        "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




        "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




        "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




        "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




        "quantity": o.get("availableQuantity"),




        "status": (o.get("status") or "").upper(),




        "gtin": (gtin or "").strip(),




        "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




        "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




        "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




        "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




        "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




    })




total = data.get("total", 0)




offset += len(batch)




if offset >= total or not batch:




    break




        return offers




    




    def _start_import_wizard(self, offers):




        app._import_offers = [o for o in offers]




        app._import_idx = 0




        win = tk.Toplevel(app.root)




        win.title("Import from eBay → Discogs match")




        win.geometry("720x520")




        app._import_win = win




        app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




        app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




        app._imp_info = tk.Text(win, height=10, wrap="word")




        app._imp_info.pack(fill="x", padx=12)




        app._imp_status = tk.Label(win, text="", fg="gray")




        app._imp_status.pack(anchor="w", padx=12, pady=6)




        btns = tk.Frame(win)




        btns.pack(fill="x", padx=12, pady=8)




        tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




        tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




        tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




        tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




        app._import_propose_current()




    




    def _import_propose_current(self):




        if app._import_idx >= len(app._import_offers):




try:




    app.populate_inventory_view()




except Exception:




    pass




messagebox.showinfo("Import from eBay", "Done.")




app._import_win.destroy()




return




        o = app._import_offers[app._import_idx]




        sku = o.get("sku") or ""




        title = o.get("title") or ""




        gtin = o.get("gtin") or ""




        catno = o.get("catno") or ""




        label = o.get("label") or ""




        fmt = o.get("format") or ""




        app._imp_hdr.config(text=f"SKU {sku} — {title}")




        app._imp_info.delete("1.0", "end")




        app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




        app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




        app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




        app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




        try:




cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




        except Exception as e:




app._imp_status.config(text=f"Discogs search failed: {e}")




app._import_candidates = []




return




        app._import_candidates = cands




        if not cands:




app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




        else:




top = cands[0]




app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




        results = []




        if gtin:




res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




for r in list(res)[:10]:




    results.append({"release_id": r.id, "title": r.title,




        "artist": getattr(r, "artist", getattr(r, "artists", "")),




        "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




        "year": getattr(r, "year", "") or "",




        "country": getattr(r, "country", "") or "",




        "method": "barcode", "confidence": 1.0})




        if catno:




res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




for r in list(res)[:10]:




    results.append({"release_id": r.id, "title": r.title,




        "artist": getattr(r, "artist", getattr(r, "artists", "")),




        "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




        "year": getattr(r, "year", "") or "",




        "country": getattr(r, "country", "") or "",




        "method": "catno", "confidence": 0.85 if not label else 0.9})




        if (not results) and title:




res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




for r in list(res)[:10]:




    results.append({"release_id": r.id, "title": r.title,




        "artist": getattr(r, "artist", getattr(r, "artists", "")),




        "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




        "year": getattr(r, "year", "") or "",




        "country": getattr(r, "country", "") or "",




        "method": "fuzzy", "confidence": 0.6})




        seen, ranked = set(), []




        for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




if r["release_id"] in seen: continue




seen.add(r["release_id"]); ranked.append(r)




        return ranked




    




    def _import_accept(self):




        if app._import_idx >= len(app._import_offers): return




        o = app._import_offers[app._import_idx]




        top = (app._import_candidates[0] if app._import_candidates else None)




        if not top:




messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




        sku = (o.get("sku") or "").strip()




        now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




        with app.db.get_connection() as conn:




c = conn.cursor()




c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




exists = c.fetchone() is not None




if exists:




    c.execute("""UPDATE inventory




                 SET discogs_listing_id = ?,




                     discogs_match_method = ?, discogs_match_confidence = ?,




                     barcode = COALESCE(?, barcode),




                     inv_updated_at = ?




                 WHERE sku = ?""", 




              (str(top["release_id"]), top["method"], float(top["confidence"]),




               (o.get("gtin") or None), now_iso, sku))




else:




    c.execute("""INSERT INTO inventory




                 (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                  barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




              (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




               (o.get("listingId") or None), str(top["release_id"]),




               (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




        app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




        app._import_idx += 1




        app._import_propose_current()




    




    def _import_alternatives(self):




        if not app._import_candidates:




messagebox.showinfo("Alternatives", "No candidates available for this item."); return




        top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




        lb = tk.Listbox(top, width=90, height=10)




        for i, r in enumerate(app._import_candidates[:12]):




lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




        lb.pack(fill="both", expand=True)




        def choose():




idx = lb.curselection()




if not idx: return




i = idx[0]




chosen = app._import_candidates[i]




rest = [r for j,r in enumerate(app._import_candidates) if j != i]




app._import_candidates = [chosen] + rest




top.destroy()




app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




        tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




        app._import_idx += 1




        app._import_propose_current()





    def action_ebay_sync_selected(self):

        """Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

        items = app.inventory_tree.selection()

        if not items:

try:

    messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

except Exception:

    pass

return

        skus = []

        for iid in items:

vals = app.inventory_tree.item(iid, "values")

if not vals:

    continue

skus.append(vals[0])

        try:

app.reconcile_from_ebay(skus)

        except Exception as e:

try:

    messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

except Exception:

    pass


    def action_discogs_save_unpublished(self):
        """Create Discogs draft listings"""
        if app.notebook.tab(app.notebook.select(), "text") == "Lister":
app._create_discogs_draft_from_lister()
        else:
app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
        """Create live Discogs listings"""
        if app.notebook.tab(app.notebook.select(), "text") == "Lister":
# Create live listing instead of draft
app._list_on_discogs_live()
        else:
# Modify existing publish_to_discogs to use "For Sale" status
app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
        """Save current lister form as eBay-ready in database with duplicate checking"""
        try:
# Validate required fields
required_fields = ['artist', 'title', 'media_condition']
for field in required_fields:
    if not app.entries[field.replace(' ', '_')].get().strip():
        messagebox.showwarning("Validation Error", f"Please enter {field}")
        return

try:
    price = float(app.price_entry.get())
    if price <= 0:
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

# Generate SKU if needed
sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
if not app.editing_sku and not app.temporary_sku:
    app.sku_display_var.set(sku)

# Check for existing listings and warn user
existing = app._check_existing_listings(sku)
if existing['has_ebay'] or existing['has_ebay_draft']:
    warning_parts = []
    if existing['has_ebay']:
        warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
    if existing['has_ebay_draft']:
        warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
    
    warning_text = "\n".join(warning_parts)
    message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
              f"This will update the existing record. Continue?")
    
    if not messagebox.askyesno("Existing eBay Data Found", message):
        return

# Save to database with special status
payload_json = json.dumps(app._serialize_form_to_payload())

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        if app.editing_sku:
            # Update existing
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?,
                lister_payload = ?
                WHERE sku = ?
            """, (now_iso, payload_json, sku))
            message = f"Updated SKU {sku} as ready for eBay"
        else:
            # Create new with basic info
            cursor.execute("""
                INSERT INTO inventory (
                    sku, artist, title, price, status, date_added, 
                    last_modified, lister_payload
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                sku,
                app.entries["artist"].get().strip(),
                app.entries["title"].get().strip(), 
                price,
                'eBay Ready',
                now_iso,
                now_iso,
                payload_json
            ))
            message = f"Saved SKU {sku} as ready for eBay"
        
        app.populate_inventory_view()
        app.append_log(message, "green")
        messagebox.showinfo("eBay Draft Saved", 
            f"{message}\n\n" +
            f"Note: This creates a local draft in your database.\n" + 
            f"eBay doesn't provide draft functionality via their public API.\n" +
            f"Use 'Publish Live' when ready to list on eBay.")
        
except Exception as e:
    logger.error(f"Failed to save eBay draft: {e}")
    messagebox.showerror("Database Error", f"Failed to save: {e}")
    
        except Exception as e:
logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
        """Mark selected inventory items as ready for eBay"""
        selected = app.inventory_tree.selection()
        if not selected:
messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
return
        
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
    
    updated_count = 0
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        cursor.execute("""
            UPDATE inventory SET 
            status = 'eBay Ready',
            last_modified = ?
            WHERE sku = ?
        """, (now_iso, sku))
        updated_count += 1
    
    app.populate_inventory_view()
    message = f"Marked {updated_count} item(s) as ready for eBay"
    app.append_log(message, "green")
    messagebox.showinfo("Success", message)
    
        except Exception as e:
logger.error(f"Failed to mark items as eBay ready: {e}")
messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
        """Create Discogs draft from current lister form"""
        if not app.discogs_api.is_connected():
messagebox.showwarning("Not Connected", "Please connect to Discogs first")
return

        if not app.current_release_id:
messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
return

        try:
price = float(app.price_entry.get())
media_condition = app.entries["media_condition"].get()
if not media_condition or media_condition not in REVERSE_GRADE_MAP:
    messagebox.showwarning("Validation Error", "Please select a valid media condition")
    return
        except (ValueError, TypeError):
messagebox.showwarning("Validation Error", "Please enter a valid price")
return
        
        listing_data = {
'release_id': app.current_release_id,
'price': price,
'status': 'Draft',  # Explicitly set as draft
'condition': REVERSE_GRADE_MAP.get(media_condition),
'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
'comments': app.full_desc.get("1.0", tk.END).strip()
        }
        
        app.root.config(cursor="watch")
        app.root.update()
        
        def draft_worker():
try:
    listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
    if listing_id:
        app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        
        threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
        """Create Discogs drafts from selected inventory items"""
        selected = app.inventory_tree.selection()
        if not selected:
messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
return
        
        def draft_worker():
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue
        
        errors = validate_listing("discogs", record, app.config)
        if errors:
            app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
            continue
        
        app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
        listing_data = {
            "release_id": record.get("discogs_release_id"),
            "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
            "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
            "price": record.get("price", 0), 
            "status": "Draft",  # Create as draft
            "comments": record.get("description", "")
        }
        
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                        (listing_id, now_iso, sku),
                    )
            except Exception as e:
                logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
        else:
            app.append_log(f"SKU {sku}: Failed to create draft", "red")
    except Exception as e:
        app.append_log(f"SKU {sku}: Error - {e}", "red")

app.safe_after(0, app.populate_inventory_view)
        
        threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
        """Create live Discogs listing (For Sale status) from lister form"""
        if not app.discogs_api.is_connected():
messagebox.showwarning("Not Connected", "Please connect to Discogs first")
return

        if not app.current_release_id:
messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
return

        try:
price = float(app.price_entry.get())
media_condition = app.entries["media_condition"].get()
if not media_condition or media_condition not in REVERSE_GRADE_MAP:
    messagebox.showwarning("Validation Error", "Please select a valid media condition")
    return
        except (ValueError, TypeError):
messagebox.showwarning("Validation Error", "Please enter a valid price")
return
        
        listing_data = {
'release_id': app.current_release_id,
'price': price,
'status': 'For Sale',  # Live listing
'condition': REVERSE_GRADE_MAP.get(media_condition),
'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
'comments': app.full_desc.get("1.0", tk.END).strip()
        }
        
        app.root.config(cursor="watch")
        app.root.update()
        
        def live_worker():
try:
    listing_id = app.discogs_api.create_listing(listing_data)
    if listing_id:
        app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
except Exception as e:
    app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
finally:
    app.safe_after(0, lambda: app.root.config(cursor=""))
        
        threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
        """Publish selected items to Discogs as live (For Sale) listings"""
        selected = app.inventory_tree.selection()
        if not selected: 
return
        
        def live_worker():
for item in selected:
    sku = app.inventory_tree.item(item, "values")[0]
    try:
        record = app._get_inventory_record(sku)
        if not record:
            app.append_log(f"SKU {sku}: Could not find record.", "red")
            continue
        
        errors = validate_listing("discogs", record, app.config)
        if errors:
            app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
            continue
        
        app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
        listing_data = {
            "release_id": record.get("discogs_release_id"),
            "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
            "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
            "price": record.get("price", 0), 
            "status": "For Sale",  # Live listing
            "comments": record.get("description", "")
        }
        
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
            try:
                now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                with app.db.get_connection() as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                        (listing_id, now_iso, sku),
                    )
            except Exception as e:
                logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
        else:
            app.append_log(f"SKU {sku}: Failed to create live listing", "red")
    except Exception as e:
        app.append_log(f"SKU {sku}: Error - {e}", "red")

app.safe_after(0, app.populate_inventory_view)
        
        threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
        """Handle successful Discogs draft creation"""
        messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
        if app.editing_sku:
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
except Exception as e:
    logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
        """Handle successful Discogs live listing creation"""
        messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
        if app.editing_sku:
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
except Exception as e:
    logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
        """Prepare all eBay listing data from current form"""
        format_val = app.entries["format"].get() or "LP"
        media_cond_str = app.entries["media_condition"].get()
        
        condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
        condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
        category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")
        
        ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
        description_html = app.full_desc.get("1.0", tk.END).strip()

        return {
"sku": sku,
"title": ebay_title[:80],
"description": description_html,
"categoryId": str(category_id),
"price": float(app.price_entry.get()),
"quantity": 1,
"condition_enum": condition_enum,
"condition_id_numeric": condition_id_numeric,
"media_condition": app.entries["media_condition"].get(),
"sleeve_condition": app.entries["sleeve_condition"].get(),
"currency": "GBP",
"marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
"paymentPolicyId": app.config.get("ebay_payment_policy_id"),
"returnPolicyId": app.config.get("ebay_return_policy_id"),
"shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
"images": app.image_paths,
        }


    def refresh_button_states(self):
        """Refresh all button states based on current connection status"""
        app._update_connection_status()
        # Trigger inventory selection update if items are selected
        if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
        """Check what listings already exist for this SKU"""
        try:
with app.db.get_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("""
        SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
        FROM inventory WHERE sku = ?
    """, (sku,))
    row = cursor.fetchone()
    
    if row:
        return {
            'ebay_listing_id': row[0],
            'discogs_listing_id': row[1], 
            'ebay_draft_id': row[2],
            'status': row[3],
            'has_ebay': bool(row[0]),
            'has_discogs': bool(row[1]),
            'has_ebay_draft': bool(row[2])
        }
    else:
        return {
            'ebay_listing_id': None,
            'discogs_listing_id': None,
            'ebay_draft_id': None,
            'status': None,
            'has_ebay': False,
            'has_discogs': False,
            'has_ebay_draft': False
        }
        except Exception as e:
logger.error(f"Error checking existing listings for {sku}: {e}")
return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
        """Ask user to confirm if they want to overwrite/update existing listing"""
        existing_ids = []
        if platform.lower() == 'ebay':
if existing_info.get('has_ebay'):
    existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
if existing_info.get('has_ebay_draft'):
    existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
        elif platform.lower() == 'discogs':
if existing_info.get('has_discogs'):
    existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")
        
        if not existing_ids:
return True  # No existing listings, safe to proceed
        
        existing_text = "\n".join(existing_ids)
        message = (
f"SKU {sku} already has existing {platform} listing(s):\n\n"
f"{existing_text}\n\n"
f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
f"Choose 'Yes' to update existing listing\n"
f"Choose 'No' to cancel and avoid duplicates"
        )
        
        return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
        """Safely publish to eBay with duplicate prevention"""
        # Check for existing listings
        existing = app._check_existing_listings(sku)
        
        # Determine what action to take
        action_type = "draft" if is_draft else "live"
        
        if existing['has_ebay'] and not is_draft:
# Has live listing, asking to publish live again
if not app._confirm_overwrite_action('eBay', sku, existing):
    return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}

# User wants to update - modify existing listing
app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
# Use existing eBay update logic here
return app.ebay_api.create_draft_listing(listing_data)  # This handles updates

        elif existing['has_ebay_draft'] and is_draft:
# Has draft, asking to create another draft
if not app._confirm_overwrite_action('eBay', sku, existing):
    return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}

app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
# Proceed with update

        elif existing['has_ebay'] and is_draft:
# Has live listing, wants to create draft - warn but allow
message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
          f"Creating a draft will not affect the live listing.\n"
          f"Continue?")
if not messagebox.askyesno("Live Listing Exists", message):
    return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}
        
        # Proceed with creation/update
        result = app.ebay_api.create_draft_listing(listing_data)
        
        # Log the action
        if result.get('success'):
action_desc = "draft saved" if is_draft else "published live"
app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")
        
        return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
        """Safely publish to Discogs with duplicate prevention"""
        existing = app._check_existing_listings(sku)
        
        if existing['has_discogs']:
if not app._confirm_overwrite_action('Discogs', sku, existing):
    app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
    return None

# User wants to update existing listing
discogs_id = existing['discogs_listing_id']
app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")

# Update instead of create
success = app.discogs_api.update_listing(discogs_id, listing_data)
if success:
    app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
    return discogs_id
else:
    app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
    return None
        
        # No existing listing, safe to create new
        action_desc = "draft" if is_draft else "live listing"
        app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")
        
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")
        
        return listing_id


    def log_sync_activity(self, message):
        """Log sync activity to the text widget"""
        def do_log():
timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
app.sync_log_text.config(state="normal")
app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
app.sync_log_text.see(tk.END)
app.sync_log_text.config(state="disabled")
        app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
        messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
        sys.exit(1)
        
    try:
        # Before starting, check for requests_toolbelt
        try:
import requests_toolbelt
        except ImportError:
 messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
 sys.exit(1)

        root = tk.Tk()
        app = VinylToolApp(root)
        root.mainloop()
    except Exception as e:
        # Create a simple Tk window to show the error if the main app fails
        try:
root = tk.Tk()
root.withdraw() # Hide the main window
messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
        except:
# Fallback to console if GUI fails completely
print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
        sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
        src_dir = _Path(__file__).resolve().parent
        backups = src_dir / "backups"
        backups.mkdir(exist_ok=True)
        active_profile = "dev"
        active_file = src_dir / "profiles" / "active_profile.json"
        try:
data = json.loads(active_file.read_text())
if isinstance(data, dict) and data.get("profile"):
    active_profile = str(data["profile"])
        except Exception:
pass
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        fname = backups / f"backup_{ts}.tar.gz"
        with tarfile.open(fname, "w:gz") as tar:
for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
    p = src_dir / name
    if p.exists():
        tar.add(p, arcname=p.name)
prof = src_dir / "profiles" / active_profile / "data"
if prof.exists():
    tar.add(prof, arcname=f"profiles/{active_profile}/data")
        print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
        print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def action_ebay_publish_live(app):
"""Publish directly to eBay as live listings (Inventory API)"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - publish current form directly
    app.list_on_ebay()
else:
    # From Inventory tab - publish selected items
    app.publish_to_ebay()



    def reconcile_from_ebay(self, skus):


"""Pull eBay state back into local DB so deletions/ends/relists are reflected.


Chooses ACTIVE offer. Prefers Item ID (listingId); falls back to offerId if listingId hasn't propagated yet.


Refreshes the grid when done.


"""


import datetime, logging, requests


logger = logging.getLogger(__name__)


    


token = app.ebay_api.get_access_token()


if not token:


    app.append_log("Cannot reconcile: missing eBay token", "red")


    return


    


headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}


changed = False


    


for sku in (skus or []):


    try:


        url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={sku}"


        r = requests.get(url, headers=headers, timeout=30)


        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()


    


        if r.status_code == 200 and r.json().get("offers"):


            offers = r.json()["offers"]


            # Pick ACTIVE offer if available; otherwise first one


            active = None


            for o in offers:


                if (o.get("status") or "").upper() == "ACTIVE":


                    active = o


                    break


            offer = active or offers[0]


            status = (offer.get("status") or "").upper()


    


            listing_id = offer.get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('legacyItemId') or (offer.get('listing') or {}).get('listingId')


            offer_id = offer.get("offerId") or (offer.get("offer") or {}).get("offerId")


    


            # If ACTIVE but listingId missing, try GET /offer/{offerId} to resolve


            if status in ("ACTIVE","PUBLISHED") and not listing_id and offer_id:


                try:


                    resolved = app.ebay_api.get_offer(str(offer_id))


                    if resolved.get("success"):


                        listing_id = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')


                except Exception as e:


                    logger.warning(f"[reconcile] get_offer failed for offer {offer_id}: {e}")


    


            with app.db.get_connection() as conn:


                c = conn.cursor()


                if status in ("ACTIVE","PUBLISHED"):


                    stored_id = listing_id or (offer_id if offer_id else None)


                    if stored_id:


                        c.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))


                        changed = True


                    else:


                        c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                        changed = True


                else:


                    c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                    changed = True


    


            shown = listing_id or (offer_id if (status in ("ACTIVE","PUBLISHED") and offer_id) else "—")


            label = "Item ID" if listing_id else ("Offer ID" if shown != "—" else "—")  # live


            app.append_log(f"SKU {sku}: reconciled from eBay ({status}; {label}={shown})", "blue")


        else:


            with app.db.get_connection() as conn:


                c = conn.cursor()


                c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


            changed = True


            app.append_log(f"SKU {sku}: no eBay offer found; cleared local mapping.", "orange")


    


    except Exception as e:


        logger.error(f"Reconcile error for {sku}: {e}")


        app.append_log(f"SKU {sku}: reconcile failed: {e}", "red")


    


if changed:


    try:


        app.populate_inventory_view()


    except Exception:


        pass



    def action_open_on_ebay_selected(self):



"""Open the selected item's eBay listing in the browser using stored Item ID."""



import webbrowser, requests, logging



logger = logging.getLogger(__name__)



items = app.inventory_tree.selection()



if not items:



    try:



        messagebox.showinfo("Open on eBay", "Please select a row first.")



    except Exception:



        pass



    return



iid = items[0]



vals = app.inventory_tree.item(iid, "values") or []



item_id = None



# Try visible column first



try:



    headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



    if "eBay ID" in headers:



        idx = headers.index("eBay ID")



        if idx < len(vals):



            item_id = vals[idx]



except Exception:



    item_id = None



# Fallback: DB lookup by SKU (assumes SKU in first column)



if not item_id and vals:



    sku = vals[0]



    try:



        with app.db.get_connection() as conn:



            c = conn.cursor()



            c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



            row = c.fetchone()



            if row and row[0]:



                item_id = row[0]



    except Exception:



        pass



if not item_id:



    try:



        messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



    except Exception:



        pass



    return



# If it's likely an offerId, try resolve to listingId on the fly



if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



    try:



        token = app.ebay_api.get_access_token()



        if token:



            headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



            url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



            r = requests.get(url, headers=headers, timeout=30)



            if r.status_code == 200 and r.json().get("offers"):



                offers = r.json()["offers"]



                active = None



                for o in offers:



                    if (o.get("status") or "").upper() == "ACTIVE":



                        active = o



                        break



                off = active or offers[0]



                lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



                if not lid:



                    oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                    if oid:



                        resolved = app.ebay_api.get_offer(str(oid))



                        if resolved.get("success"):



                            lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



                if lid:



                    item_id = lid



    except Exception as e:



        logger.warning(f"[open] resolution failed: {e}")



try:



    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



except Exception:



    try:



        messagebox.showerror("Open on eBay", "Failed to open browser.")



    except Exception:



        pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




try:




    offers = app._fetch_all_ebay_offers()




except Exception as e:




    messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




    return




work = []




with app.db.get_connection() as conn:




    c = conn.cursor()




    for off in offers:




        sku = (off.get("sku") or "").strip()




        if not sku:




            continue




        c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




        row = c.fetchone()




        if not row or not row[0]:




            work.append(off)




if not work:




    messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




    return




app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def action_ebay_save_unpublished(app):
"""Save eBay listing data locally as 'ready to publish' without sending to eBay"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - save current form
    app._save_ebay_draft_from_lister()
else:
    # From Inventory tab - mark selected items as ready for eBay
    app._save_ebay_draft_from_inventory()

    def action_ebay_publish_live(self):
"""Publish directly to eBay as live listings (Inventory API)"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # From Lister tab - publish current form directly
    app.list_on_ebay()
else:
    # From Inventory tab - publish selected items
    app.publish_to_ebay()



    def reconcile_from_ebay(self, skus):


"""Pull eBay state back into local DB so deletions/ends/relists are reflected.


Chooses ACTIVE offer. Prefers Item ID (listingId); falls back to offerId if listingId hasn't propagated yet.


Refreshes the grid when done.


"""


import datetime, logging, requests


logger = logging.getLogger(__name__)


    


token = app.ebay_api.get_access_token()


if not token:


    app.append_log("Cannot reconcile: missing eBay token", "red")


    return


    


headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}


changed = False


    


for sku in (skus or []):


    try:


        url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={sku}"


        r = requests.get(url, headers=headers, timeout=30)


        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()


    


        if r.status_code == 200 and r.json().get("offers"):


            offers = r.json()["offers"]


            # Pick ACTIVE offer if available; otherwise first one


            active = None


            for o in offers:


                if (o.get("status") or "").upper() == "ACTIVE":


                    active = o


                    break


            offer = active or offers[0]


            status = (offer.get("status") or "").upper()


    


            listing_id = offer.get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('legacyItemId') or (offer.get('listing') or {}).get('listingId')


            offer_id = offer.get("offerId") or (offer.get("offer") or {}).get("offerId")


    


            # If ACTIVE but listingId missing, try GET /offer/{offerId} to resolve


            if status in ("ACTIVE","PUBLISHED") and not listing_id and offer_id:


                try:


                    resolved = app.ebay_api.get_offer(str(offer_id))


                    if resolved.get("success"):


                        listing_id = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')


                except Exception as e:


                    logger.warning(f"[reconcile] get_offer failed for offer {offer_id}: {e}")


    


            with app.db.get_connection() as conn:


                c = conn.cursor()


                if status in ("ACTIVE","PUBLISHED"):


                    stored_id = listing_id or (offer_id if offer_id else None)


                    if stored_id:


                        c.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))


                        changed = True


                    else:


                        c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                        changed = True


                else:


                    c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                    changed = True


    


            shown = listing_id or (offer_id if (status in ("ACTIVE","PUBLISHED") and offer_id) else "—")


            label = "Item ID" if listing_id else ("Offer ID" if shown != "—" else "—")  # live


            app.append_log(f"SKU {sku}: reconciled from eBay ({status}; {label}={shown})", "blue")


        else:


            with app.db.get_connection() as conn:


                c = conn.cursor()


                c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


            changed = True


            app.append_log(f"SKU {sku}: no eBay offer found; cleared local mapping.", "orange")


    


    except Exception as e:


        logger.error(f"Reconcile error for {sku}: {e}")


        app.append_log(f"SKU {sku}: reconcile failed: {e}", "red")


    


if changed:


    try:


        app.populate_inventory_view()


    except Exception:


        pass



    def action_open_on_ebay_selected(self):



"""Open the selected item's eBay listing in the browser using stored Item ID."""



import webbrowser, requests, logging



logger = logging.getLogger(__name__)



items = app.inventory_tree.selection()



if not items:



    try:



        messagebox.showinfo("Open on eBay", "Please select a row first.")



    except Exception:



        pass



    return



iid = items[0]



vals = app.inventory_tree.item(iid, "values") or []



item_id = None



# Try visible column first



try:



    headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



    if "eBay ID" in headers:



        idx = headers.index("eBay ID")



        if idx < len(vals):



            item_id = vals[idx]



except Exception:



    item_id = None



# Fallback: DB lookup by SKU (assumes SKU in first column)



if not item_id and vals:



    sku = vals[0]



    try:



        with app.db.get_connection() as conn:



            c = conn.cursor()



            c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



            row = c.fetchone()



            if row and row[0]:



                item_id = row[0]



    except Exception:



        pass



if not item_id:



    try:



        messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



    except Exception:



        pass



    return



# If it's likely an offerId, try resolve to listingId on the fly



if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



    try:



        token = app.ebay_api.get_access_token()



        if token:



            headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



            url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



            r = requests.get(url, headers=headers, timeout=30)



            if r.status_code == 200 and r.json().get("offers"):



                offers = r.json()["offers"]



                active = None



                for o in offers:



                    if (o.get("status") or "").upper() == "ACTIVE":



                        active = o



                        break



                off = active or offers[0]



                lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



                if not lid:



                    oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                    if oid:



                        resolved = app.ebay_api.get_offer(str(oid))



                        if resolved.get("success"):



                            lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



                if lid:



                    item_id = lid



    except Exception as e:



        logger.warning(f"[open] resolution failed: {e}")



try:



    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



except Exception:



    try:



        messagebox.showerror("Open on eBay", "Failed to open browser.")



    except Exception:



        pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




try:




    offers = app._fetch_all_ebay_offers()




except Exception as e:




    messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




    return




work = []




with app.db.get_connection() as conn:




    c = conn.cursor()




    for off in offers:




        sku = (off.get("sku") or "").strip()




        if not sku:




            continue




        c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




        row = c.fetchone()




        if not row or not row[0]:




            work.append(off)




if not work:




    messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




    return




app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def action_ebay_sync_selected(app):
"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def reconcile_from_ebay(app, skus):
"""Pull eBay state back into local DB so deletions/ends/relists are reflected.


Chooses ACTIVE offer. Prefers Item ID (listingId); falls back to offerId if listingId hasn't propagated yet.


Refreshes the grid when done.


"""


import datetime, logging, requests


logger = logging.getLogger(__name__)


    


token = app.ebay_api.get_access_token()


if not token:


    app.append_log("Cannot reconcile: missing eBay token", "red")


    return


    


headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}


changed = False


    


for sku in (skus or []):


    try:


        url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={sku}"


        r = requests.get(url, headers=headers, timeout=30)


        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()


    


        if r.status_code == 200 and r.json().get("offers"):


            offers = r.json()["offers"]


            # Pick ACTIVE offer if available; otherwise first one


            active = None


            for o in offers:


                if (o.get("status") or "").upper() == "ACTIVE":


                    active = o


                    break


            offer = active or offers[0]


            status = (offer.get("status") or "").upper()


    


            listing_id = offer.get('legacyItemId') or offer.get('listingId') or (offer.get('listing') or {}).get('legacyItemId') or (offer.get('listing') or {}).get('listingId')


            offer_id = offer.get("offerId") or (offer.get("offer") or {}).get("offerId")


    


            # If ACTIVE but listingId missing, try GET /offer/{offerId} to resolve


            if status in ("ACTIVE","PUBLISHED") and not listing_id and offer_id:


                try:


                    resolved = app.ebay_api.get_offer(str(offer_id))


                    if resolved.get("success"):


                        listing_id = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')


                except Exception as e:


                    logger.warning(f"[reconcile] get_offer failed for offer {offer_id}: {e}")


    


            with app.db.get_connection() as conn:


                c = conn.cursor()


                if status in ("ACTIVE","PUBLISHED"):


                    stored_id = listing_id or (offer_id if offer_id else None)


                    if stored_id:


                        c.execute("UPDATE inventory SET ebay_listing_id = ?, ebay_updated_at = ? WHERE sku = ?", (stored_id, now_iso, sku))


                        changed = True


                    else:


                        c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                        changed = True


                else:


                    c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


                    changed = True


    


            shown = listing_id or (offer_id if (status in ("ACTIVE","PUBLISHED") and offer_id) else "—")


            label = "Item ID" if listing_id else ("Offer ID" if shown != "—" else "—")  # live


            app.append_log(f"SKU {sku}: reconciled from eBay ({status}; {label}={shown})", "blue")


        else:


            with app.db.get_connection() as conn:


                c = conn.cursor()


                c.execute("UPDATE inventory SET ebay_listing_id = NULL, ebay_updated_at = ? WHERE sku = ?", (now_iso, sku))


            changed = True


            app.append_log(f"SKU {sku}: no eBay offer found; cleared local mapping.", "orange")


    


    except Exception as e:


        logger.error(f"Reconcile error for {sku}: {e}")


        app.append_log(f"SKU {sku}: reconcile failed: {e}", "red")


    


if changed:


    try:


        app.populate_inventory_view()


    except Exception:


        pass



    def action_open_on_ebay_selected(self):



"""Open the selected item's eBay listing in the browser using stored Item ID."""



import webbrowser, requests, logging



logger = logging.getLogger(__name__)



items = app.inventory_tree.selection()



if not items:



    try:



        messagebox.showinfo("Open on eBay", "Please select a row first.")



    except Exception:



        pass



    return



iid = items[0]



vals = app.inventory_tree.item(iid, "values") or []



item_id = None



# Try visible column first



try:



    headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



    if "eBay ID" in headers:



        idx = headers.index("eBay ID")



        if idx < len(vals):



            item_id = vals[idx]



except Exception:



    item_id = None



# Fallback: DB lookup by SKU (assumes SKU in first column)



if not item_id and vals:



    sku = vals[0]



    try:



        with app.db.get_connection() as conn:



            c = conn.cursor()



            c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



            row = c.fetchone()



            if row and row[0]:



                item_id = row[0]



    except Exception:



        pass



if not item_id:



    try:



        messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



    except Exception:



        pass



    return



# If it's likely an offerId, try resolve to listingId on the fly



if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



    try:



        token = app.ebay_api.get_access_token()



        if token:



            headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



            url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



            r = requests.get(url, headers=headers, timeout=30)



            if r.status_code == 200 and r.json().get("offers"):



                offers = r.json()["offers"]



                active = None



                for o in offers:



                    if (o.get("status") or "").upper() == "ACTIVE":



                        active = o



                        break



                off = active or offers[0]



                lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



                if not lid:



                    oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                    if oid:



                        resolved = app.ebay_api.get_offer(str(oid))



                        if resolved.get("success"):



                            lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



                if lid:



                    item_id = lid



    except Exception as e:



        logger.warning(f"[open] resolution failed: {e}")



try:



    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



except Exception:



    try:



        messagebox.showerror("Open on eBay", "Failed to open browser.")



    except Exception:



        pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




try:




    offers = app._fetch_all_ebay_offers()




except Exception as e:




    messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




    return




work = []




with app.db.get_connection() as conn:




    c = conn.cursor()




    for off in offers:




        sku = (off.get("sku") or "").strip()




        if not sku:




            continue




        c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




        row = c.fetchone()




        if not row or not row[0]:




            work.append(off)




if not work:




    messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




    return




app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def action_open_on_ebay_selected(app):
"""Open the selected item's eBay listing in the browser using stored Item ID."""



import webbrowser, requests, logging



logger = logging.getLogger(__name__)



items = app.inventory_tree.selection()



if not items:



    try:



        messagebox.showinfo("Open on eBay", "Please select a row first.")



    except Exception:



        pass



    return



iid = items[0]



vals = app.inventory_tree.item(iid, "values") or []



item_id = None



# Try visible column first



try:



    headers = [app.inventory_tree.heading(c)["text"] for c in app.inventory_tree["columns"]]



    if "eBay ID" in headers:



        idx = headers.index("eBay ID")



        if idx < len(vals):



            item_id = vals[idx]



except Exception:



    item_id = None



# Fallback: DB lookup by SKU (assumes SKU in first column)



if not item_id and vals:



    sku = vals[0]



    try:



        with app.db.get_connection() as conn:



            c = conn.cursor()



            c.execute("SELECT ebay_listing_id FROM inventory WHERE sku = ?", (sku,))



            row = c.fetchone()



            if row and row[0]:



                item_id = row[0]



    except Exception:



        pass



if not item_id:



    try:



        messagebox.showinfo("Open on eBay", "No eBay Item ID stored for the selected row.")



    except Exception:



        pass



    return



# If it's likely an offerId, try resolve to listingId on the fly



if not (str(item_id).isdigit() and len(str(item_id)) >= 12) and vals:



    try:



        token = app.ebay_api.get_access_token()



        if token:



            headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}



            url = f"{app.ebay_api.base_url}/sell/inventory/v1/offer?sku={{vals[0]}}"



            r = requests.get(url, headers=headers, timeout=30)



            if r.status_code == 200 and r.json().get("offers"):



                offers = r.json()["offers"]



                active = None



                for o in offers:



                    if (o.get("status") or "").upper() == "ACTIVE":



                        active = o



                        break



                off = active or offers[0]



                lid = off.get('legacyItemId') or off.get('listingId') or (off.get('listing') or {}).get('legacyItemId') or (off.get('listing') or {}).get('listingId')



                if not lid:



                    oid = off.get("offerId") or (off.get("offer") or {}).get("offerId")



                    if oid:



                        resolved = app.ebay_api.get_offer(str(oid))



                        if resolved.get("success"):



                            lid = resolved.get('legacyItemId') or (resolved.get('listing') or {}).get('legacyItemId') or resolved.get('listingId') or (resolved.get('listing') or {}).get('listingId')



                if lid:



                    item_id = lid



    except Exception as e:



        logger.warning(f"[open] resolution failed: {e}")



try:



    webbrowser.open_new_tab(f"https://www.ebay.co.uk/itm/{item_id}")



except Exception:



    try:



        messagebox.showerror("Open on eBay", "Failed to open browser.")



    except Exception:



        pass




    # ------------------------------




    # eBay → Discogs Import (Wizard)




    # ------------------------------




    def action_import_from_ebay(self):




try:




    offers = app._fetch_all_ebay_offers()




except Exception as e:




    messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




    return




work = []




with app.db.get_connection() as conn:




    c = conn.cursor()




    for off in offers:




        sku = (off.get("sku") or "").strip()




        if not sku:




            continue




        c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




        row = c.fetchone()




        if not row or not row[0]:




            work.append(off)




if not work:




    messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




    return




app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def action_import_from_ebay(app):
try:




    offers = app._fetch_all_ebay_offers()




except Exception as e:




    messagebox.showerror("Import from eBay", f"Failed to fetch eBay offers:\n{e}")




    return




work = []




with app.db.get_connection() as conn:




    c = conn.cursor()




    for off in offers:




        sku = (off.get("sku") or "").strip()




        if not sku:




            continue




        c.execute("SELECT discogs_listing_id FROM inventory WHERE sku = ?", (sku,))




        row = c.fetchone()




        if not row or not row[0]:




            work.append(off)




if not work:




    messagebox.showinfo("Import from eBay", "No eligible eBay listings found (all mapped).")




    return




app._start_import_wizard(work)




    




    def _fetch_all_ebay_offers(self):




token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def _fetch_all_ebay_offers(app):
token = app.ebay_api.get_access_token()




if not token:




    raise RuntimeError("Missing eBay token")




import requests




hdrs = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}




base = f"{app.ebay_api.base_url}/sell/inventory/v1/offer"




offers, limit, offset = [], 200, 0




while True:




    resp = requests.get(f"{base}?limit={limit}&offset={offset}", headers=hdrs, timeout=30)




    if resp.status_code != 200:




        raise RuntimeError(f"eBay API error {resp.status_code}: {resp.text[:300]}")




    data = resp.json()




    batch = data.get("offers") or []




    for o in batch:




        aspects = (o.get("aspects") or {})




        gtin = None




        for k in ("EAN","UPC","GTIN","ean","upc","gtin"):




            v = aspects.get(k)




            if isinstance(v, list) and v:




                gtin = v[0]; break




            if isinstance(v, str) and v.strip():




                gtin = v.strip(); break




        if not gtin:




            prod = o.get("product") or {}




            g = prod.get("gtin")




            if isinstance(g, list) and g:




                gtin = g[0]




            elif isinstance(g, str):




                gtin = g




        offers.append({




            "sku": o.get("sku"),




            "title": o.get("title") or (o.get("name") or ""),




            "offerId": o.get("offerId") or (o.get("offer") or {}).get("offerId"),




            "listingId": o.get("legacyItemId") or o.get("listingId") or (o.get("listing") or {}).get("legacyItemId") or (o.get("listing") or {}).get("listingId"),




            "price": ((o.get("pricingSummary") or {}).get("price") or {}).get("value"),




            "currency": ((o.get("pricingSummary") or {}).get("price") or {}).get("currency"),




            "quantity": o.get("availableQuantity"),




            "status": (o.get("status") or "").upper(),




            "gtin": (gtin or "").strip(),




            "catno": (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or [""])[0] if isinstance(aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No"), list) else (aspects.get("Catalogue Number") or aspects.get("Catalog Number") or aspects.get("Cat No") or ""),




            "label": (aspects.get("Record Label") or aspects.get("Label") or [""])[0] if isinstance(aspects.get("Record Label") or aspects.get("Label"), list) else (aspects.get("Record Label") or aspects.get("Label") or ""),




            "format": (aspects.get("Format") or [""])[0] if isinstance(aspects.get("Format"), list) else (aspects.get("Format") or ""),




            "country": (aspects.get("Country/Region of Manufacture") or [""])[0] if isinstance(aspects.get("Country/Region of Manufacture"), list) else (aspects.get("Country/Region of Manufacture") or ""),




            "year": (aspects.get("Release Year") or [""])[0] if isinstance(aspects.get("Release Year"), list) else (aspects.get("Release Year") or ""),




        })




    total = data.get("total", 0)




    offset += len(batch)




    if offset >= total or not batch:




        break




return offers




    




    def _start_import_wizard(self, offers):




app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def _start_import_wizard(app, offers):
app._import_offers = [o for o in offers]




app._import_idx = 0




win = tk.Toplevel(app.root)




win.title("Import from eBay → Discogs match")




win.geometry("720x520")




app._import_win = win




app._imp_hdr = tk.Label(win, text="", font=("Helvetica", 14, "bold"))




app._imp_hdr.pack(anchor="w", padx=12, pady=(10, 6))




app._imp_info = tk.Text(win, height=10, wrap="word")




app._imp_info.pack(fill="x", padx=12)




app._imp_status = tk.Label(win, text="", fg="gray")




app._imp_status.pack(anchor="w", padx=12, pady=6)




btns = tk.Frame(win)




btns.pack(fill="x", padx=12, pady=8)




tk.Button(btns, text="Accept", command=app._import_accept).pack(side="left", padx=4)




tk.Button(btns, text="See Alternatives…", command=app._import_alternatives).pack(side="left", padx=4)




tk.Button(btns, text="Skip", command=app._import_skip).pack(side="left", padx=4)




tk.Button(btns, text="Cancel", command=win.destroy).pack(side="right", padx=4)




app._import_propose_current()




    




    def _import_propose_current(self):




if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def _import_propose_current(app):
if app._import_idx >= len(app._import_offers):




    try:




        app.populate_inventory_view()




    except Exception:




        pass




    messagebox.showinfo("Import from eBay", "Done.")




    app._import_win.destroy()




    return




o = app._import_offers[app._import_idx]




sku = o.get("sku") or ""




title = o.get("title") or ""




gtin = o.get("gtin") or ""




catno = o.get("catno") or ""




label = o.get("label") or ""




fmt = o.get("format") or ""




app._imp_hdr.config(text=f"SKU {sku} — {title}")




app._imp_info.delete("1.0", "end")




app._imp_info.insert("end", f"eBay ID: {o.get('listingId') or o.get('offerId')}\n")




app._imp_info.insert("end", f"GTIN/Barcode: {gtin or '—'}\n")




app._imp_info.insert("end", f"Cat No: {catno or '—'}\n")




app._imp_info.insert("end", f"Label: {label or '—'} | Format: {fmt or '—'}\n\n")




try:




    cands = app._discogs_find_candidates(gtin=gtin, catno=catno, title=title, label=label or None)




except Exception as e:




    app._imp_status.config(text=f"Discogs search failed: {e}")




    app._import_candidates = []




    return




app._import_candidates = cands




if not cands:




    app._imp_status.config(text="No candidates found. Click ‘See Alternatives…’ to search manually.")




else:




    top = cands[0]




    app._imp_status.config(text=f"Proposed: {top['artist']} – {top['title']} [{top['label']} • {top['year']} • {top['country']}]  ({top['method']}, {int(top['confidence']*100)}%)")




    




    def _discogs_find_candidates(self, gtin: str = "", catno: str = "", title: str = "", label: str = None):




results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def _import_accept(app):
if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def _import_alternatives(app):
if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def _import_skip(app):
app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---


def _discogs_find_candidates(app, gtin: str = "", catno: str = "", title: str = "", label: str = None):
results = []




if gtin:




    res = app.discogs_client.search(barcode=gtin, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "barcode", "confidence": 1.0})




if catno:




    res = app.discogs_client.search(catno=catno, type="release", format="Vinyl")




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "catno", "confidence": 0.85 if not label else 0.9})




if (not results) and title:




    res = app.discogs_client.search(title=title, type="release", format="Vinyl", label=label or None)




    for r in list(res)[:10]:




        results.append({"release_id": r.id, "title": r.title,




            "artist": getattr(r, "artist", getattr(r, "artists", "")),




            "label": ", ".join(getattr(r, "label", getattr(r, "labels", [])) or []),




            "year": getattr(r, "year", "") or "",




            "country": getattr(r, "country", "") or "",




            "method": "fuzzy", "confidence": 0.6})




seen, ranked = set(), []




for r in sorted(results, key=lambda x: x["confidence"], reverse=True):




    if r["release_id"] in seen: continue




    seen.add(r["release_id"]); ranked.append(r)




return ranked




    




    def _import_accept(self):




if app._import_idx >= len(app._import_offers): return




o = app._import_offers[app._import_idx]




top = (app._import_candidates[0] if app._import_candidates else None)




if not top:




    messagebox.showinfo("Import from eBay", "No candidate to accept for this item."); return




sku = (o.get("sku") or "").strip()




now_iso = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()




with app.db.get_connection() as conn:




    c = conn.cursor()




    c.execute("SELECT 1 FROM inventory WHERE sku = ?", (sku,))




    exists = c.fetchone() is not None




    if exists:




        c.execute("""UPDATE inventory




                     SET discogs_listing_id = ?,




                         discogs_match_method = ?, discogs_match_confidence = ?,




                         barcode = COALESCE(?, barcode),




                         inv_updated_at = ?




                     WHERE sku = ?""", 




                  (str(top["release_id"]), top["method"], float(top["confidence"]),




                   (o.get("gtin") or None), now_iso, sku))




    else:




        c.execute("""INSERT INTO inventory




                     (sku, artist, title, price, status, ebay_listing_id, discogs_listing_id,




                      barcode, discogs_match_method, discogs_match_confidence, inv_updated_at, date_added)




                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 




                  (sku, "", o.get("title") or "", o.get("price") or 0.0, "For Sale",




                   (o.get("listingId") or None), str(top["release_id"]),




                   (o.get("gtin") or None), top["method"], float(top["confidence"]), now_iso, now_iso))




app.append_log(f"Imported {sku} → Discogs {top['release_id']} ({top['method']}, {int(top['confidence']*100)}%)", "green")




app._import_idx += 1




app._import_propose_current()




    




    def _import_alternatives(self):




if not app._import_candidates:




    messagebox.showinfo("Alternatives", "No candidates available for this item."); return




top = tk.Toplevel(app._import_win); top.title("Choose a Discogs release")




lb = tk.Listbox(top, width=90, height=10)




for i, r in enumerate(app._import_candidates[:12]):




    lb.insert("end", f"{i+1}. {r['artist']} – {r['title']}  [{r['label']} • {r['year']} • {r['country']}]  ({r['method']}, {int(r['confidence']*100)}%)")




lb.pack(fill="both", expand=True)




def choose():




    idx = lb.curselection()




    if not idx: return




    i = idx[0]




    chosen = app._import_candidates[i]




    rest = [r for j,r in enumerate(app._import_candidates) if j != i]




    app._import_candidates = [chosen] + rest




    top.destroy()




    app._imp_status.config(text=f"Chosen: {chosen['artist']} – {chosen['title']} [{chosen['label']} • {chosen['year']} • {chosen['country']}]  ({chosen['method']}, {int(chosen['confidence']*100)}%)")




tk.Button(top, text="Use Selected", command=choose).pack(pady=6)




    




    def _import_skip(self):




app._import_idx += 1




app._import_propose_current()





    def action_ebay_sync_selected(self):

"""Sync selected inventory SKUs from eBay into local DB (status/listingId)."""

items = app.inventory_tree.selection()

if not items:

    try:

        messagebox.showinfo("Sync from eBay", "Please select one or more items in the inventory list.")

    except Exception:

        pass

    return

skus = []

for iid in items:

    vals = app.inventory_tree.item(iid, "values")

    if not vals:

        continue

    skus.append(vals[0])

try:

    app.reconcile_from_ebay(skus)

except Exception as e:

    try:

        messagebox.showerror("Sync from eBay", f"Failed to sync: {e}")

    except Exception:

        pass


    def action_discogs_save_unpublished(self):
"""Create Discogs draft listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    app._create_discogs_draft_from_lister()
else:
    app._create_discogs_draft_from_inventory()

    def action_discogs_publish_live(self):
"""Create live Discogs listings"""
if app.notebook.tab(app.notebook.select(), "text") == "Lister":
    # Create live listing instead of draft
    app._list_on_discogs_live()
else:
    # Modify existing publish_to_discogs to use "For Sale" status
    app._publish_to_discogs_live()

    def _save_ebay_draft_from_lister(self):
"""Save current lister form as eBay-ready in database with duplicate checking"""
try:
    # Validate required fields
    required_fields = ['artist', 'title', 'media_condition']
    for field in required_fields:
        if not app.entries[field.replace(' ', '_')].get().strip():
            messagebox.showwarning("Validation Error", f"Please enter {field}")
            return
    
    try:
        price = float(app.price_entry.get())
        if price <= 0:
            messagebox.showwarning("Validation Error", "Please enter a valid price")
            return
    except (ValueError, TypeError):
        messagebox.showwarning("Validation Error", "Please enter a valid price")
        return

    # Generate SKU if needed
    sku = app.editing_sku or app.sku_display_var.get() or datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    if not app.editing_sku and not app.temporary_sku:
        app.sku_display_var.set(sku)

    # Check for existing listings and warn user
    existing = app._check_existing_listings(sku)
    if existing['has_ebay'] or existing['has_ebay_draft']:
        warning_parts = []
        if existing['has_ebay']:
            warning_parts.append(f"Live eBay listing: {existing['ebay_listing_id']}")
        if existing['has_ebay_draft']:
            warning_parts.append(f"eBay draft: {existing['ebay_draft_id']}")
        
        warning_text = "\n".join(warning_parts)
        message = (f"SKU {sku} already has:\n\n{warning_text}\n\n"
                  f"This will update the existing record. Continue?")
        
        if not messagebox.askyesno("Existing eBay Data Found", message):
            return

    # Save to database with special status
    payload_json = json.dumps(app._serialize_form_to_payload())
    
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            
            if app.editing_sku:
                # Update existing
                cursor.execute("""
                    UPDATE inventory SET 
                    status = 'eBay Ready',
                    last_modified = ?,
                    lister_payload = ?
                    WHERE sku = ?
                """, (now_iso, payload_json, sku))
                message = f"Updated SKU {sku} as ready for eBay"
            else:
                # Create new with basic info
                cursor.execute("""
                    INSERT INTO inventory (
                        sku, artist, title, price, status, date_added, 
                        last_modified, lister_payload
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    sku,
                    app.entries["artist"].get().strip(),
                    app.entries["title"].get().strip(), 
                    price,
                    'eBay Ready',
                    now_iso,
                    now_iso,
                    payload_json
                ))
                message = f"Saved SKU {sku} as ready for eBay"
            
            app.populate_inventory_view()
            app.append_log(message, "green")
            messagebox.showinfo("eBay Draft Saved", 
                f"{message}\n\n" +
                f"Note: This creates a local draft in your database.\n" + 
                f"eBay doesn't provide draft functionality via their public API.\n" +
                f"Use 'Publish Live' when ready to list on eBay.")
            
    except Exception as e:
        logger.error(f"Failed to save eBay draft: {e}")
        messagebox.showerror("Database Error", f"Failed to save: {e}")
        
except Exception as e:
    logger.error(f"Error in _save_ebay_draft_from_lister: {e}")
    messagebox.showerror("Error", f"An error occurred: {e}")

    def _save_ebay_draft_from_inventory(self):
"""Mark selected inventory items as ready for eBay"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to prepare for eBay")
    return

try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        updated_count = 0
        for item in selected:
            sku = app.inventory_tree.item(item, "values")[0]
            cursor.execute("""
                UPDATE inventory SET 
                status = 'eBay Ready',
                last_modified = ?
                WHERE sku = ?
            """, (now_iso, sku))
            updated_count += 1
        
        app.populate_inventory_view()
        message = f"Marked {updated_count} item(s) as ready for eBay"
        app.append_log(message, "green")
        messagebox.showinfo("Success", message)
        
except Exception as e:
    logger.error(f"Failed to mark items as eBay ready: {e}")
    messagebox.showerror("Database Error", f"Failed to update items: {e}")

    def _create_discogs_draft_from_lister(self):
"""Create Discogs draft from current lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'Draft',  # Explicitly set as draft
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def draft_worker():
    try:
        listing_id = app._safe_discogs_publish(app.editing_sku or "NEW", listing_data, is_draft=True)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_draft_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Draft Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=draft_worker, daemon=True).start()

    def _create_discogs_draft_from_inventory(self):
"""Create Discogs drafts from selected inventory items"""
selected = app.inventory_tree.selection()
if not selected:
    messagebox.showwarning("No Selection", "Please select items to create Discogs drafts")
    return

def draft_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Creating Discogs draft for SKU {sku}...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "Draft",  # Create as draft
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Created Discogs draft (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create draft", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=draft_worker, daemon=True).start()

    def _list_on_discogs_live(self):
"""Create live Discogs listing (For Sale status) from lister form"""
if not app.discogs_api.is_connected():
    messagebox.showwarning("Not Connected", "Please connect to Discogs first")
    return
    
if not app.current_release_id:
    messagebox.showerror("Missing Release", "You must select a specific Discogs release variant first")
    return
    
try:
    price = float(app.price_entry.get())
    media_condition = app.entries["media_condition"].get()
    if not media_condition or media_condition not in REVERSE_GRADE_MAP:
        messagebox.showwarning("Validation Error", "Please select a valid media condition")
        return
except (ValueError, TypeError):
    messagebox.showwarning("Validation Error", "Please enter a valid price")
    return

listing_data = {
    'release_id': app.current_release_id,
    'price': price,
    'status': 'For Sale',  # Live listing
    'condition': REVERSE_GRADE_MAP.get(media_condition),
    'sleeve_condition': REVERSE_GRADE_MAP.get(app.entries["sleeve_condition"].get(), 'Generic'),
    'comments': app.full_desc.get("1.0", tk.END).strip()
}

app.root.config(cursor="watch")
app.root.update()

def live_worker():
    try:
        listing_id = app.discogs_api.create_listing(listing_data)
        if listing_id:
            app.safe_after(0, lambda: app._handle_discogs_live_success(listing_id))
    except Exception as e:
        app.safe_after(0, lambda: messagebox.showerror("Listing Error", str(e)))
    finally:
        app.safe_after(0, lambda: app.root.config(cursor=""))

threading.Thread(target=live_worker, daemon=True).start()

    def _publish_to_discogs_live(self):
"""Publish selected items to Discogs as live (For Sale) listings"""
selected = app.inventory_tree.selection()
if not selected: 
    return

def live_worker():
    for item in selected:
        sku = app.inventory_tree.item(item, "values")[0]
        try:
            record = app._get_inventory_record(sku)
            if not record:
                app.append_log(f"SKU {sku}: Could not find record.", "red")
                continue
            
            errors = validate_listing("discogs", record, app.config)
            if errors:
                app.append_log(f"SKU {sku}: {', '.join(errors)}", "red")
                continue
            
            app.append_log(f"Publishing SKU {sku} live to Discogs...", "black")
            listing_data = {
                "release_id": record.get("discogs_release_id"),
                "condition": REVERSE_GRADE_MAP.get(record.get("media_condition"), "Good (G)"),
                "sleeve_condition": REVERSE_GRADE_MAP.get(record.get("sleeve_condition"), "Good (G)"),
                "price": record.get("price", 0), 
                "status": "For Sale",  # Live listing
                "comments": record.get("description", "")
            }
            
            listing_id = app.discogs_api.create_listing(listing_data)
            if listing_id:
                app.append_log(f"SKU {sku}: Published live to Discogs (ID: {listing_id})", "green")
                try:
                    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
                    with app.db.get_connection() as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE inventory SET discogs_listing_id = ?, discogs_updated_at = ? WHERE sku = ?",
                            (listing_id, now_iso, sku),
                        )
                except Exception as e:
                    logger.error(f"Failed to update inventory with Discogs listing ID: {e}")
                    app.append_log(f"SKU {sku}: Failed to save Discogs listing ID to DB: {e}", "red")
            else:
                app.append_log(f"SKU {sku}: Failed to create live listing", "red")
        except Exception as e:
            app.append_log(f"SKU {sku}: Error - {e}", "red")
    
    app.safe_after(0, app.populate_inventory_view)

threading.Thread(target=live_worker, daemon=True).start()

    def _handle_discogs_draft_success(self, listing_id):
"""Handle successful Discogs draft creation"""
messagebox.showinfo("Success", f"Successfully created Discogs DRAFT (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _handle_discogs_live_success(self, listing_id):
"""Handle successful Discogs live listing creation"""
messagebox.showinfo("Success", f"Successfully published LIVE to Discogs (Listing ID: {listing_id})")
if app.editing_sku:
    try:
        with app.db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE inventory SET discogs_listing_id = ? WHERE sku = ?", (listing_id, app.editing_sku))
    except Exception as e:
        logger.error(f"Failed to update inventory with listing ID: {e}")

    def _prepare_ebay_listing_data(self, sku):
"""Prepare all eBay listing data from current form"""
format_val = app.entries["format"].get() or "LP"
media_cond_str = app.entries["media_condition"].get()

condition_enum = EBAY_INVENTORY_CONDITION_MAP.get(media_cond_str, "USED_GOOD")
condition_id_numeric = EBAY_CONDITION_MAP_NUMERIC.get(media_cond_str, "3000")
category_id = EBAY_VINYL_CATEGORIES.get(format_val, "176985")

ebay_title = app.entries["listing_title"].get() or f"{app.entries['artist'].get()} - {app.entries['title'].get()}"
description_html = app.full_desc.get("1.0", tk.END).strip()

return {
    "sku": sku,
    "title": ebay_title[:80],
    "description": description_html,
    "categoryId": str(category_id),
    "price": float(app.price_entry.get()),
    "quantity": 1,
    "condition_enum": condition_enum,
    "condition_id_numeric": condition_id_numeric,
    "media_condition": app.entries["media_condition"].get(),
    "sleeve_condition": app.entries["sleeve_condition"].get(),
    "currency": "GBP",
    "marketplaceId": app.config.get("marketplace_id", "EBAY_GB"),
    "paymentPolicyId": app.config.get("ebay_payment_policy_id"),
    "returnPolicyId": app.config.get("ebay_return_policy_id"),
    "shippingPolicyId": app.config.get("ebay_shipping_policy_id"),
    "images": app.image_paths,
}


    def refresh_button_states(self):
"""Refresh all button states based on current connection status"""
app._update_connection_status()
# Trigger inventory selection update if items are selected
if hasattr(self, 'inventory_tree') and app.inventory_tree.selection():
    app.on_inventory_selection()


    # ========================================================================
    # DUPLICATE PREVENTION SYSTEM
    # ========================================================================
    
    def _check_existing_listings(self, sku: str) -> dict:
"""Check what listings already exist for this SKU"""
try:
    with app.db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT ebay_listing_id, discogs_listing_id, ebay_item_draft_id, status 
            FROM inventory WHERE sku = ?
        """, (sku,))
        row = cursor.fetchone()
        
        if row:
            return {
                'ebay_listing_id': row[0],
                'discogs_listing_id': row[1], 
                'ebay_draft_id': row[2],
                'status': row[3],
                'has_ebay': bool(row[0]),
                'has_discogs': bool(row[1]),
                'has_ebay_draft': bool(row[2])
            }
        else:
            return {
                'ebay_listing_id': None,
                'discogs_listing_id': None,
                'ebay_draft_id': None,
                'status': None,
                'has_ebay': False,
                'has_discogs': False,
                'has_ebay_draft': False
            }
except Exception as e:
    logger.error(f"Error checking existing listings for {sku}: {e}")
    return {'has_ebay': False, 'has_discogs': False, 'has_ebay_draft': False}

    def _confirm_overwrite_action(self, platform: str, sku: str, existing_info: dict) -> bool:
"""Ask user to confirm if they want to overwrite/update existing listing"""
existing_ids = []
if platform.lower() == 'ebay':
    if existing_info.get('has_ebay'):
        existing_ids.append(f"Live eBay listing: {existing_info.get('ebay_listing_id')}")
    if existing_info.get('has_ebay_draft'):
        existing_ids.append(f"eBay draft: {existing_info.get('ebay_draft_id')}")
elif platform.lower() == 'discogs':
    if existing_info.get('has_discogs'):
        existing_ids.append(f"Discogs listing: {existing_info.get('discogs_listing_id')}")

if not existing_ids:
    return True  # No existing listings, safe to proceed

existing_text = "\n".join(existing_ids)
message = (
    f"SKU {sku} already has existing {platform} listing(s):\n\n"
    f"{existing_text}\n\n"
    f"Do you want to UPDATE the existing listing instead of creating a duplicate?\n\n"
    f"Choose 'Yes' to update existing listing\n"
    f"Choose 'No' to cancel and avoid duplicates"
)

return messagebox.askyesno(f"Existing {platform} Listing Found", message)

    def _safe_ebay_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> dict:
"""Safely publish to eBay with duplicate prevention"""
# Check for existing listings
existing = app._check_existing_listings(sku)

# Determine what action to take
action_type = "draft" if is_draft else "live"

if existing['has_ebay'] and not is_draft:
    # Has live listing, asking to publish live again
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    # User wants to update - modify existing listing
    app.append_log(f"SKU {sku}: Updating existing eBay listing {existing['ebay_listing_id']}", "blue")
    # Use existing eBay update logic here
    return app.ebay_api.create_draft_listing(listing_data)  # This handles updates
    
elif existing['has_ebay_draft'] and is_draft:
    # Has draft, asking to create another draft
    if not app._confirm_overwrite_action('eBay', sku, existing):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled to avoid duplicate'}
    
    app.append_log(f"SKU {sku}: Updating existing eBay draft", "blue")
    # Proceed with update
    
elif existing['has_ebay'] and is_draft:
    # Has live listing, wants to create draft - warn but allow
    message = (f"SKU {sku} already has a LIVE eBay listing.\n\n"
              f"Creating a draft will not affect the live listing.\n"
              f"Continue?")
    if not messagebox.askyesno("Live Listing Exists", message):
        return {'success': False, 'cancelled': True, 'reason': 'User cancelled'}

# Proceed with creation/update
result = app.ebay_api.create_draft_listing(listing_data)

# Log the action
if result.get('success'):
    action_desc = "draft saved" if is_draft else "published live"
    app.append_log(f"SKU {sku}: eBay listing {action_desc} successfully", "green")

return result

    def _safe_discogs_publish(self, sku: str, listing_data: dict, is_draft: bool = False) -> int:
"""Safely publish to Discogs with duplicate prevention"""
existing = app._check_existing_listings(sku)

if existing['has_discogs']:
    if not app._confirm_overwrite_action('Discogs', sku, existing):
        app.append_log(f"SKU {sku}: Discogs publish cancelled to avoid duplicate", "orange")
        return None
    
    # User wants to update existing listing
    discogs_id = existing['discogs_listing_id']
    app.append_log(f"SKU {sku}: Updating existing Discogs listing {discogs_id}", "blue")
    
    # Update instead of create
    success = app.discogs_api.update_listing(discogs_id, listing_data)
    if success:
        app.append_log(f"SKU {sku}: Discogs listing updated successfully", "green")
        return discogs_id
    else:
        app.append_log(f"SKU {sku}: Failed to update Discogs listing", "red") 
        return None

# No existing listing, safe to create new
action_desc = "draft" if is_draft else "live listing"
app.append_log(f"SKU {sku}: Creating new Discogs {action_desc}", "black")

listing_id = app.discogs_api.create_listing(listing_data)
if listing_id:
    app.append_log(f"SKU {sku}: Discogs {action_desc} created successfully (ID: {listing_id})", "green")

return listing_id


    def log_sync_activity(self, message):
"""Log sync activity to the text widget"""
def do_log():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    app.sync_log_text.config(state="normal")
    app.sync_log_text.insert(tk.END, f"[{timestamp}] {message}\n")
    app.sync_log_text.see(tk.END)
    app.sync_log_text.config(state="disabled")
app.safe_after(0, do_log)

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    if sys.version_info < (3, 7):
messagebox.showerror("Unsupported Python Version", "This application requires Python 3.7 or higher.")
sys.exit(1)

    try:
# Before starting, check for requests_toolbelt
try:
    import requests_toolbelt
except ImportError:
     messagebox.showerror("Missing Dependency", "The 'requests-toolbelt' library is required for this version.\n\nPlease install it by running:\npip install requests-toolbelt")
     sys.exit(1)

root = tk.Tk()
app = VinylToolApp(root)
root.mainloop()
    except Exception as e:
# Create a simple Tk window to show the error if the main app fails
try:
    root = tk.Tk()
    root.withdraw() # Hide the main window
    messagebox.showerror("Fatal Application Error", f"A critical error occurred:\n\n{e}\n\n{traceback.format_exc()}")
except:
    # Fallback to console if GUI fails completely
    print(f"FATAL ERROR: {e}\n{traceback.format_exc()}")
sys.exit(1)

# --- Auto-backup on exit (active profile + core files) ---
import atexit, tarfile, datetime, json
from pathlib import Path as _Path

def _auto_backup_to_backups_dir():
    try:
src_dir = _Path(__file__).resolve().parent
backups = src_dir / "backups"
backups.mkdir(exist_ok=True)
active_profile = "dev"
active_file = src_dir / "profiles" / "active_profile.json"
try:
    data = json.loads(active_file.read_text())
    if isinstance(data, dict) and data.get("profile"):
        active_profile = str(data["profile"])
except Exception:
    pass
ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
fname = backups / f"backup_{ts}.tar.gz"
with tarfile.open(fname, "w:gz") as tar:
    for name in ["config.json","api_clients.py","inventory.db","geometry.conf"]:
        p = src_dir / name
        if p.exists():
            tar.add(p, arcname=p.name)
    prof = src_dir / "profiles" / active_profile / "data"
    if prof.exists():
        tar.add(prof, arcname=f"profiles/{active_profile}/data")
print(f"[AutoBackup] Saved {fname}")
    except Exception as e:
print("[AutoBackup] Failed:", e)

atexit.register(_auto_backup_to_backups_dir)
# --- End auto-backup ---

